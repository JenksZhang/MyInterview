# MMO 后端要点速览（每项 2–6 条，便于快速阅读）

## 1) 项目架构简介
- 常见分层：Gateway → Auth/Login → Director/Route → Logic/Scene → DB/Storage → 支撑服务（邮件/推送/成就/排行榜/监控）。
- 水平拆分：功能微服务化 + 按玩家/区服/地图分片（sharding）。
- 非功能：长连接使用 epoll、cpu pinning、内存局部化、零拷贝优化。
- 实例：战斗服强调实时性（少量节点、高 CPU），社交/邮件强调吞吐（多实例、队列化）。

## 2) Redis 事务 vs MySQL 事务
- Redis 事务：MULTI/EXEC，将命令排队后一次性执行（无回滚）；WATCH 提供乐观锁（abort on change）。
- MySQL 事务：完整 ACID，支持回滚与隔离级别（READ/REPEATABLE/SERIALIZABLE）。
- 要点：Redis 快但无回滚；关键操作（扣款等）用 DB+两阶段/补偿，Redis 适合缓存/计数/临时状态。

## 3) Redis 批处理
- Pipeline：减少 RTT，批量发命令（适合大量写/读）。
- MGET/MSET、HMSET、ZADD 多元素用法。
- Lua 脚本：服务端原子执行复杂批量逻辑，避免往返。
- 注意：pipeline 会占内存缓冲，需限流与分片。

## 4) MySQL 性能瓶颈排查
- 观察指标：CPU、IOPS、磁盘延迟、innodb row lock、Threads_connected、慢查询（slow_query_log）。
- 工具：EXPLAIN、pt-query-digest、SHOW ENGINE INNODB STATUS。
- 优化：索引/覆盖索引、拆表/分区、batch insert、innodb_buffer_pool_size 调优、读写分离 + 缓存。
- 业务层：限流、异步/队列化、批量化写入。

## 5) 业务数据入库流程（典型）
- 验证 → 事务写主表 + 日志表（或 WAL 到 MQ）→ 异步索引/缓存更新。
- 幂等 key（订单 id）防重入。
- 大批量写用 bulk insert，并异步处理后续索引/派发。

## 6) struct x{int a,int b} 两线程访问不同字段问题
- 只读不同字段安全；若有写则产生 data race（未定义行为）。
- 可能发生伪共享（false sharing）导致性能下降（同一 cache line 被频繁无效化）。
- 解决：使用原子变量/锁，或按 cache line 对齐分离字段（padding）。

## 7) 从 n 中随机抽取 m 个
- Fisher–Yates 洗牌（shuffle）取前 m，复杂度 O(n)。
- m ≪ n：Reservoir Sampling（水塘抽样），一次遍历 O(n)，内存 O(m)。
- 适用场景根据 n、m、是否流式决定算法。

## 8) 二维数组按行 vs 按列遍历（谁快）
- Row-major（如 C/C++）：按行遍历更快（内存连续，cache 友好，预取器有效）。
- 列遍历会跨页/跨 cache-line，导致更多 cache miss 与 TLB miss。
- 结论：优先按语言存储顺序遍历以提升局部性。

## 9) 内存屏障（memory barrier）
- 屏障类型：load fence (rmb)、store fence (wmb)、full fence (mfence/dmb)。
- 作用：禁止编译器/CPU 重排，保证可见性与顺序（实现锁/发布-订阅）。
- 用户态用语言原子库（C++ atomic/thread_fence）或原子 API。

## 10) CAS（Compare-And-Swap）
- 原子比较并交换，用于无锁数据结构（计数器、stack）。
- ABA 问题：值 A->B->A 导致误判，常用版本号/tag 或 double-CAS 解决。
- 在高并发场景常配合回退策略（exponential backoff）。

## 11) False sharing（伪共享）
- 不同线程频繁写同一 cache line 上不同变量，会导致 cache-line bounce，性能下降。
- 解决：padding/align，按线程/分区布局热数据，避免小而频繁写的共享变量聚集。

## 12) 设计 DB 服务器处理玩家请求（多线程与回调）
- 模式 A（同步线程池）：IO 接收 → push to worker pool → worker 同步 DB → 回调网络发送响应。
- 模式 B（异步 IO + 回调）：IO 线程发 DB 请求到 DB worker/连接池并注册 callback，完成后触发回调/事件。
- 细节：per-shard worker 池、连接池、请求合并、事务幂等、错误重试与补偿队列。

## 13) 开服时确定各类服数量配比
- 基于容量测试：测出 1 gate 可承载的并发连接、1 logic 能承载的并发玩家/战斗数、DB 吞吐等。
- 经验：gateway 横向扩展多、logic CPU 密集少、login 轻量多副本、DB 根据吞吐与 R/W 比做分片/读写分离。
- 实操：负载建模 + 承载测试 + 预留弹性系数。

## 14) 写个 LRU（要点）
- 数据结构：哈希表 + 双向链表（O(1) 查找与更新）。
- Python 推荐使用 `collections.OrderedDict` 或 `functools.lru_cache`；并发场景用分片 LRU 或加锁。
- 生产级别注意并发、过期策略和内存控制。

## 15) Python 函数装饰器（示例）
```python
def log(func):
    def wrapper(*args, **kwargs):
        print("call", func.__name__)
        return func(*args, **kwargs)
    return wrapper

@log
def foo(x): return x+1
```

## 16) Python GIL
- CPython 有全局解释器锁，导致多线程 CPU-bound 无法并行执行字节码。
- IO-bound 可并发；解决方式：多进程、C 扩展释放 GIL、async IO、替代实现（PyPy/Jython）。

## 17) 客户端突然关机：服务器消息与状态
- TCP：server send 会先写内核发送缓冲区，内核尝试发送；若网络不可达或产生 RST/超时，最终报错。
- 服务器通常在未检测到 FIN/RST 前仍显示连接 ESTABLISHED；靠心跳/keepalive/应用超时判断离线并释放资源。
- 设计建议：心跳与较短超时以快速发现断线并做保存/回滚。

## 18) 第三次握手丢包，服务器行为与查看方法
- 第三次 ACK 丢失：server 在发送 SYN-ACK 后处于 `SYN-RECV` 状态，等待 ACK；若超时无 ACK，会重传 SYN-ACK 并最终放弃连接。
- 查看：用 `tcpdump`/`wireshark` 抓包，或 `ss -tan`/`netstat` 查看 `SYN-RECV` 状态。

## 19) TCP RST
- 用途：立即终止连接（对端无对应 socket、出错或防火墙产生）。
- 收到 RST 连接立即被内核移除，并向应用返回 `ECONNRESET`。
- 调试：抓包查 RST 源，检查应用是否 close 或防火墙行为。

## 20) Linux awk 常用
- 基本：`awk '{print $1}' file`，按条件 `awk '$3>100{print $1,$3}'`。
- 场景：处理 `ss -tan`、解析日志、做快速统计。

## 21) gdb: 进入某函数
- 常用命令：`break func`、`run`、`step`（进入）、`next`（跳过）、`finish`（运行到返回）、`bt`（栈）。
- 多线程：`info threads` / `thread <id>`，共享库尚未加载可在运行后再设置断点。

## 22) epoll 实现原理（要点）
- 内核维护 interest list 与 ready list；用户注册 fd 到 epoll 实例，内核把就绪 fd 放到 ready list，`epoll_wait` 返回就绪集合。
- 使用建议：ET + 非阻塞 IO，读写直到 EAGAIN，避免阻塞事件循环。

## 23) AOI（Area of Interest）设计
- 数据结构：网格（spatial hash）、四叉树/八叉树、KD-tree。
- 优化：分区 zone（避免锁）、稀疏/阈值更新、批量/差分合并、只维护邻格集合再做局部排序（如 top-k）。
- 有序列表：按距离或优先级维护小堆/skip-list；尽量 O(1) 的邻格集合并局部排序。

---

> 若你要我展开某一项（代码示例、压力测试脚本、并发实现或常见问题复现），告诉我“只展开第 N 项”，我将依你指定的学习闭环方式分步给出：  
> - 每次回答不超过 3 段短内容；  
> - 出现不懂的点立刻问我并精确定位问题后继续。  