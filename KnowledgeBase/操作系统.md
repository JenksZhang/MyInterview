# 操作系统

## 进程与线程

### fork函数的作用？

- 创建一个和当前**进程**一样的子**进程**
- 调用一次，返回两次 `pid = fork();` pid>0为父进程，pid=0为子进程
- 子进程会复制父进程所有的代码段、数据段，堆栈环境变量等等，并且有完全独立的地址空间，现代大部分操作系统优化了fork，采用COPY ON Write机制，降低fork的开销
- 通常fork + exec来在子进程中执行新的任务

### 僵尸进程是什么？

- 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程PID仍然保存在系统中并且是Z+状态。这种进程称之为僵死进程
- 无法通过kill -9杀死僵尸进程，因为他已经终止，仅有有残留的信息
- 父进程也可以通过注册SIGCHILD信号处理函数，异步的去wait，进而回收子进程残留数据
- 如果是父进程提前退出，则子进程会被init(PID为1)进程收养，init进程会注册子进程的退出信号

### 僵尸进程

- 僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。
- 如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源

### 进程和线程的区别

- 进程是执行中的一段程序，而一个进程中执行中的每个任务即为一个线程
- 一个线程只可以属于一个进程，但一个进程能包含多个线程
- 线程无地址空间，它包括在进程的地址空间里
- 线程的开销或代价比进程的小

### 进程，线程，协程

- 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
- 线程是指进程内的一个执行单元,也是进程内的可调度实体。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
- 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。从技术的角度来说，"协程就是你可以暂停执行的函数"。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

### 进程和线程的区别（详细版）

- 1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。
- 2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
- 3.进程是资源分配的最小单位，线程是CPU调度的最小单位；
- 4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。
- 5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预
- 6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。
- 7进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉
- 8.进程适应于多核、多机分布；线程适用于多核

### 协程和线程的区别

- \1.  一个线程可以多个协程，一个进程也可以单独拥有多个协程。
- \2. 线程进程都是同步机制，而协程则是异步。
- \3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。
- 4.线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。
- 5.协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。
- 6.线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。

### fork 的过程

![fork过程](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=ODE2NGZhYmI2NDMzY2M0NTNkNmI1MDkzM2Q4OTYzYTNfQzFyaWxyZnZxZ05GQ3F3bmlJRmNOeE5tQVhkSnNRWHNfVG9rZW46Ym94Y25kVkFhUmcwekVrU0xHUWZyV2VUZFhnXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

### 进程的三种状态和状态转换

### 进程通信方式，哪种最快

- 信号、共享内存、socket、管道、信号量、最快是共享内存

### 进程间的通讯方式（详细版）

- 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
- 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
- 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
- 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
- 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

### 线程间通信

- 1.互斥锁
  - mutex;
  - lock_guard (在构造函数里加锁，在析构函数里解锁）
  - `unique_lock` 自动加锁、解锁
- 2.读写锁
  - `shared_lock`
- 3.信号量
  - c++11中未实现，可以自己使用mutex和conditon_variable 实现

### 多线程同步、多进程通信方式

- 线程共享代码段、数据段、堆
- 临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；
- 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
- 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
- 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

### 信号量本质是什么？锁和信号量的区别是什么？

- 本质：内核维护的整形计数器，用来控制同时访问某个共享资源的线程数
- 锁必须谁拿谁还，并且同时只能有一方持有
- 信号量可以多方持有，并且归还无需持有方，信号量计数为0时，进入队列等候，计数>0时唤醒队列中成员

### CPU 的最小调度单位

- 线程

### kill一个进程的过程是什么样子的

- 发送信号给这个进程，这个进程对信号进行处理

## 内存管理

### timestamp,  datetime的区别

- timestamp（时间戳）本质是数值型（整数或浮点数），表示从某个「基准时间点」开始经过的秒数（或毫秒数、微秒数）。最常用的基准是「Unix 纪元时间」：`1970-01-01 00:00:00 UTC`。例如：`1620000000` 表示从 Unix 纪元开始经过 1620000000 秒，对应北京时间 `2021-05-03 16:00:00`。
- datetime（日期时间）本质是结构化数据，直接存储「年 - 月 - 日 时：分: 秒」（可能包含毫秒 / 微秒），是人类可直接阅读的时间格式。例如：`2021-05-03 16:00:00` 或 `2023-10-01T08:30:00.123`。

### 内存泄漏诊断

- 静态代码检查工具
- 动态内存检查工具valgrand
- gperftools+pprof查看内存消耗大的块

### 内存泄漏的处理方法

- 使用varglind，mtrace检测

### 请你来回答一下什么是memory leak，也就是内存泄漏

- 内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏的分类：
- \1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.
- \2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
- \3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

### 造成内存泄漏的原因

- 程序循环new创建出来的对象没有及时的delete掉，导致了内存的泄露；
- delete掉一个void*类型的指针，导致没有调用到对象的析构函数，析构的所有清理工作都没有去执行从而导致内存的泄露；
- new创建了一组对象数组，内存回收的时候却只调用了delete而非delete []来处理，导致只有对象数组的第一个对象的析构函数得到执行并回收了内存占用，数组的其他对象所占内存得不到回收，导致内存泄露；
- 没有将基类的析构函数定义为虚函数
- new一个数组的时候，中途发生异常，会导致之前初始化的部分泄漏
- new了一个对象，执行中途发生异常，在处理异常的地方没有处理

### 内存分配malloc流程

1. 获取分配区的锁，防止多线程冲突。
2. 计算出实际需要分配的内存的chunk实际大小。
3. 判断chunk的大小，如果小于max_fast（64Ｂ），则尝试去fast bins上取适合的chunk，如果有则分配结束。否则，下一步；
4. 判断chunk大小是否小于512B，如果是，则从small bins上去查找chunk，如果有合适的，则分配结束。否则下一步；
5. ptmalloc首先会遍历fast bins中的chunk，将相邻的chunk进行合并，并链接到unsorted bin中然后遍历 unsorted bins。如果unsorted bins上只有一个chunk并且大于待分配的chunk，则进行切割，并且剩余的chunk继续扔回unsorted bins；如果unsorted bins上有大小和待分配chunk相等的，则返回，并从unsorted bins删除；如果unsorted bins中的某一chunk大小 属于small bins的范围，则放入small bins的头部；如果unsorted bins中的某一chunk大小 属于large bins的范围，则找到合适的位置放入。若未分配成功，转入下一步；
6. 从large bins中查找找到合适的chunk之后，然后进行切割，一部分分配给用户，剩下的放入unsorted bin中。
7. 如果搜索fast bins和bins都没有找到合适的chunk，那么就需要操作top chunk来进行分配了
8. 当top chunk大小比用户所请求大小还大的时候，top chunk会分为两个部分：User chunk（用户请求大小）和Remainder chunk（剩余大小）。其中Remainder chunk成为新的top chunk。
9. 当top chunk大小小于用户所请求的大小时，top chunk就通过sbrk（main arena）或mmap（thread arena）系统调用来扩容。
10. 到了这一步，说明 top chunk 也不能满足分配要求，所以，于是就有了两个选择: 如 果是主分配区，调用 sbrk()，增加 top chunk 大小；如果是非主分配区，调用 mmap 来分配一个新的 sub-heap，增加 top chunk 大小；或者使用 mmap()来直接分配。在 这里，需要依靠 chunk 的大小来决定到底使用哪种方法。判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值，如果是的话，则转下一步，调用 mmap 分配， 否则跳到第 10 步，增加 top chunk 的大小。
11. 使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。 然后将内存指针返回给用户。
12. 判断是否为第一次调用 malloc，若是主分配区，则需要进行一次初始化工作，分配 一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap。若已经初 始化过了，主分配区则调用 sbrk()增加 heap 空间，分主分配区则在 top chunk 中切 割出一个 chunk，使之满足分配需求，并将内存指针返回给用户。

### 怎么通过逻辑地址找到物理地址

- 逻辑地址由段基值和偏移量组成，16乘以段基值加上偏移量就是物理地址。<------得看分页还是分段还是段页式

### linux是怎么分配内存的

- 内存
- 虚拟内存
- Buffer cache

### 什么是虚拟内存，作用

- 虚拟内存是一种计算机系统内存管理技术。它使得应用程序认为它拥有连续可用的内存，即一个连续完整的地址空间。而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。
  - 虚拟内存地址空间是连续的，没有碎片
  - 虚拟内存的最大空间就是cpu的最大寻址空间，不受内存大小的限制，能提供比内存更大的地址空间

### 什么情况下会发生缺页中断，具体流程

- 当访问一个还末调入（还不在）内存区的页面时便会发生缺页中断.当发生这种缺页中断时，操作系统检验该访问是否合法，若不合法，则中止该程序；若合法，则查寻出一空闲块并请求I/O把所需的页面读入该空闲块，一量I/O完成就更新进程表和页表并重新执行这一指令.

### 如何判断逻辑地址是否已经映射在物理地址上了

- 逻辑地址：在具有地址变换功能的计算机中，访问指令给出的操作数。
- 物理地址：用于内存芯片级单元寻址，与CPU连接的地址总线相对应。
- 线性地址：逻辑地址和物理地址转换的中间层，即硬件平台页式转换前的地址。

### 内存置换算法

- 最佳置换算法(OPT)
- 先进先出(FIFO)页面置换算法
- 最近最久未使用(LRU)置换算法
- 时钟(CLOCK)置换算法

### 页表所在的位置

- 进程内存空间里

### 段页式存储一般要访问几次内存

- 一般是三次
  - 第一次由段表地址寄存器得段表始址后访问段表，由此取出对应段的页表在内存中的地址。
  - 第二次则是访问页表得到所要访问的物理地址。
  - 第三次才能访问真正需要访问的物理单元。

### 段页式管理的实现原理

- 虚地址的构成
  - 虚拟空间的最小单位是页而不是段，从而内存可用区也就被划分成为着干个大小相等的页面，且每段所拥有的程序和数据在内存中可以分开存放。分段的大小也不再受内存可用区的限制。
- 段表和页表
  - 系统必须为每个作业或进程建立一张段表以管理内存分配与释放、缺段处理、存储保护相地址变换等。另外，由于一个段又被划分成了若干页，每个段又必须建立一张页表以把段中的虚页变换成内存中的实际页面。
- 动态地址变换过程
  - 在一般使用段页式存储管理方式的计算机系统中，都在内存中辟出一块固定的区域存放进程的段表和页表。

## 用户态与内核态

### 用户态和内核态的区别

- 内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态**；**
- 当程序运行在0级特权级上时，就可以称之为运行在内核态
- 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。
- **处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的**
- **处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。**

### 用户态和内核态切换的代价

- 系统调用一般都需要保存用户程序得上下文(context), 在进入内核得时候需要保存用户态得寄存器，在内核态返回用户态得时候会恢复这些寄存器得内容。这是一个开销的地方。 如果需要在不同用户程序间切换的话，那么还要更新cr3寄存器，这样会更换每个程序的虚拟内存到物理内存映射表的地址，也是一个比较高负担的操作

### 内核态和用户态的区别，如何切换，什么情况下会进行切换

- 系统调用
- 异常
- 外围设备的中断

## 文件系统

### 软，硬链接

## 中断

### 什么是中断

- 中断是外部设备向处理器发起的请求事件。就是处理器的标准输入接口。

### 键盘输入一个字符到显示在显示器上的全过程

- 键盘输入 ：外中断
- OS中断流程
- 调用ioctl系列函数在屏幕上显示

### 中断

- 中断分内中断和外中断
- 外中断一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备 的中断请求。
- 内部中断：是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断是不可屏蔽的中断。 软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序
- 内中断有异常，陷阱，故障，终止

## I/O多路复用

### Select，poll，epoll的区别

### epoll 的 LT 和 ET 的区别

- ET： fd成non_blocking,且epoll_wait返回后把事件read到EAGAIN为止
- 应用层缓冲区不够，需要在应用层记录下该fd还未读完

### select的限制

- 文件描述符上限
- select中的fd_set**集合容量的限制**
- select是轮询的，当并发量高的时候效率低

### epoll相对于select的优势

- 文件描述符数量上限取决于内存大小，比select大
- 轮询机制不同，epoll使用红黑树来存放节点，有读写消息时会把文件描述符放入链表中，在epoll_wait时进行处理，select轮询每个文件描述符，效率较低

## 其他

### errno

- errno 是记录系统调用的最后一次错误代码
- 什么时候会修改
  - 所以在用 errno 时必须调用放手动置 errno 为 0, 系统提供的 api 内部是不会去将 errno 置为 0 的
  - 因为 errno 是全局的，整个线程都生效，在一个很大的项目中，errno 在哪里不小心被置为非 0 值是极有可能的，因此，需要使用者非常小心。

### C++ 内存空间布局

### C++对象内存布局？

- 内核空间，栈，堆，内存映射段(动态静态链接库，文件映射)，bss段，数据段，代码段
- 问了C++对象布局的一些东西，回答得还行，涉及到了虚函数指针、空对象的大小以及vector容器、三五法则。

### 操作系统的栈和堆的区别

- **栈（操作系统）**：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈，栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放
- **堆（操作系统）**： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些

### 环形缓冲区的好处（循环队列）

- 数据迁移少

### 动态链接和静态链接

- 静态链接的缺点很明显，一是浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本；另一方面就是更新比较困难，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。
- 动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失

### C++的静态链接和动态链接讲一下

- 将目标文件链接成二进制的过程是静态链接
- 静态链接比动态链接有更大的空间浪费，每个二进制都会包含一份静态链接的代码和数据，动态链接装载到内存中可同时供多个进程使用
- 静态链接主要做的事情是根据符号表的信息进行引用符号的重定位
- 动态链接利用fPIC参数可以生成地址无关的代码，保证多个进程可以使用同一个动态链接库

### 怎么查看端口号占用情况

- Netstat -nap | grep xxx

### 死锁

- 是指两个或两个以上的进程（线程）在执行过程中，因**争夺资源**而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。 由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程（线程）在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。
- 原因
  - 系统资源不足；
  - 进程（线程）推进的顺序不恰当；
  - 资源分配不当。
- 形成场景
  - 忘记释放锁：在申请锁和释放锁之间直接return
  - 单线程重复申请锁：一个线程，刚出临界区，又去申请资源。
  - 多线程多锁申请：两个线程，两个锁，他们都已经申请了一个锁了，都想申请对方的锁
  - 环形锁的申请：多个线程申请锁的顺序形成相互依赖的环形
- 死锁的条件
  - **互斥条件：**简单的说就是进程抢夺的资源必须是临界资源，一段时间内，该资源只能同时被一个进程所占有。
  - **请求和保持条件**：当一个进程持有了一个（或者更多）资源，申请另外的资源的时候发现申请的资源被其他进程所持有，当前进程阻塞，但不会释放自己所持有的资源。
  - **不可抢占条件：**进程已经获得的资源在未使用完毕的情况下不可被其他进程所抢占在很多情况下这些条件都是合乎要求的
  - **循环等待条件：**存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源。
- 预防死锁
  - 打破条件。。哈哈哈
- 死锁避免
  - 有序资源分配法
  - 银行家算法（最具有代表性）

### 函数调用过程

函数调用大致包括以下几个步骤：

参数入栈：将参数从右向左依次压入系统栈中

返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行

代码区跳转：处理器从当前代码区跳转到被调用函数的入口处

栈帧调整：具体包括保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP入栈）

将当前栈帧切换到新栈帧。（将ESP值装入EBP，更新栈帧底部）

给新栈帧分配空间。（把ESP减去所需空间的大小，抬高栈顶）

### 函数返回的步骤如下

<1>保存返回值，通常将函数的返回值保存在寄存器EAX中。

<2>弹出当前帧，恢复上一个栈帧。具体包括：

    (1)在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间。

    (2)将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复出上一个栈帧。

    (3)将函数返回地址弹给EIP寄存器。

<3>跳转：按照函数返回地址跳回母函数中继续执行。

### 排查线上某进程CPU为100%。

- 先查看哪个进程100%
- 用gperftools抓热点
- 根据工具提供的数据去对应占用高的函数看代码

### Linux下用什么工具排查问题呢？

- 主要用GDB，也会用Linux相关命令查询系统状态，比如netstat、tcpdump
- free、df等

### 操作系统（shell命令---好几个不会：查内存、磁盘使用情况什么的、同一进程下线程共享哪些东西、线程同步问题）

- free、df -hT
- 线程共享代码段、数据段、堆
- 临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；
- 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
- 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
- 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

### liunx下如何shell下查看cpu内存资源使用情况用什么命令

- top

### 已知进程名，使用命令查看当前进程打开的文件句柄？

- lsof|grep xxx

### 已知进程名，使用命令查看当前进程的网络连接状态？

- netstat -anp|grep xxx

### 已知进程名，查看eth0网卡与ip10.10.10.10:10653之间的TCP数据包？

- Tcpdump -i eth0 host 10.10.10.10 and port 10653

### docker

- Linux容器
  - Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离，就像是给正常的进程外面套了一个保护层，对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。
- Docker和Linux容器是什么关系
  - Docker属于Linux容器一种封装，提供简单易用的容器使用接口；它将应用程序与该程序的依赖打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机运行一样
- docker与虚拟机的区别
  - Docker 是一个能把开发的应用程序自动部署到容器的开源引擎
  - 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作

![docker vs 虚拟机](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ5OGFlOTBiZGMxMTkwMDc2ZTE0NDE0MDUwYTZiMWZfZk4zUlRMb2pWWDhIZEs5Vk1IbDNDRjlIUFprZ2dLcGNfVG9rZW46Ym94Y25JbzRHb1IzS0J1VnFiNmpNUHMzVzFYXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

- 虚拟机是在一台物理机上，利用虚拟化技术，虚拟出来多个操作系统，每个操作系统之间是隔离的。
- (1) docker是开源的应用容器引擎，依然需要先在电脑上安装操作系统，然后安装Docker容器管理器。
- (2) 虚拟机是在硬件级别进行虚拟化,而docker是在操作系统的层面虚拟化
- (3) 虚拟机是通过模拟硬件搭建操作系统,而docker则是复用操作系统
- (4) 虚拟机实现了操作系统之间的隔离,docker只是进程之间的隔离,所以虚拟机的隔离级别更高,安全性更强
- (5) docker的运行速度更快
- (6) docker的文件要小的多,虚拟机要大

### 在两个进程中，申请的指针，可能指向同一片内存吗

- 不会，进程间内存独立

### swap （不知道）linux的虚拟内存
