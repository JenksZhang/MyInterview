# 操作系统-jk复习版
```
📦 计算机全栈底层体系 (Full-Stack System Architecture)
 ┃
 ┣━━ 🖥️ 1. 硬件基础与寄存器 (Hardware & Registers)
 ┃    ┣━━ 物理核心 (Core)
 ┃    ┃    ┣━━ 性质：真正的执行工人，拥有一套独立的硬件资源 (寄存器组)。
 ┃    ┃    ┗━━ [用户提问] 寄存器属于 OS 还是核心？ -> ✅ 属于物理核心，OS 只是管理者（租客），进程切换即"换租"。
 ┃    ┣━━ 🧰 关键寄存器组 (The Toolbox)
 ┃    ┃    ┣━━ RIP (PC): 指令指针，永远指向"下一条"汇编指令 (执行进度的唯一凭证)。
 ┃    ┃    ┣━━ RSP/RBP: 栈指针，指向当前线程的栈顶/栈底。
 ┃    ┃    ┣━━ CR3: [核心知识] 指向内存中页表的基地址 (TLB 的靠山)。
 ┃    ┃    ┗━━ 通用寄存器 (RAX/RBX...): 存放运算的临时数据。
 ┃    ┣━━ ⚛️ 原子性 (Atomicity)
 ┃    ┃    ┗━━ [用户提问] 指令执行一半会被打断吗？ -> ❌ 不会。中断只发生在指令边界；超长指令通过保存中间状态实现"断点续传"。
 ┃    ┗━━ 总线 (Bus): 连接 CPU、内存和外设，同时负责核心间的广播通讯 (MESI 嗅探)。
 ┃
 ┣━━ 🧱 2. 进程与线程模型 (Process & Thread)
 ┃    ┣━━ 🏠 进程 (Process) = 合租房 (资源单位)
 ┃    ┃    ┣━━ 隔离性: 拥有独立的虚拟地址空间 (页表不同)。
 ┃    ┃    ┣━━ 代码段 (Text): 只读，共享指令。
 ┃    ┃    ┗━━ 数据段/堆 (Data/Heap): 全局共享区域，所有线程可见。
 ┃    ┗━━ 👤 线程 (Thread) = 租客 (调度单位)
 ┃         ┣━━ 栈 (Stack): ❌ 私有。存放局部变量、函数调用链 (SP指针控制)。
 ┃         ┣━━ TLS (Thread Local Storage): 私有全局变量副本。
 ┃         ┗━━ 共享权: 可以访问同一进程的堆和全局变量 (需同步)。
 ┃
 ┣━━ ⏱️ 3. 调度与切换机制 (Scheduling & Switching)
 ┃    ┣━━ 🔔 时钟中断 (Tick)
 ┃    ┃    ┣━━ 来源: 硬件晶振产生的周期性信号。
 ┃    ┃    ┗━━ 作用: 强制 CPU 暂停当前作业，跳转到 OS 调度程序。
 ┃    ┣━━ ⚖️ 时间片 (Time Slice)
 ┃    ┃    ┣━━ 分配: 由调度算法 (如 Linux CFS) 动态决定，不平均。
 ┃    ┃    ┗━━ [用户提问] 能保证 Tick 频率一致吗？ -> ❌ 普通 OS 不能 (受抢占、负载影响)；只有 RTOS 可以。
 ┃    ┗━━ 🔄 上下文切换 (Context Switch)
 ┃         ┣━━ 本质: 保存 A 的寄存器现场 -> 加载 B 的寄存器现场。
 ┃         ┣━━ 步骤 1 (冻结): 硬件自动把 PC (RIP) 压入内核栈。
 ┃         ┣━━ 步骤 2 (存档): OS 把通用寄存器保存到 PCB。
 ┃         ┣━━ 步骤 3 (切图): [核心] 修改 CR3 (切换页表) -> 导致 TLB 变冷 (切换代价的主要来源)。
 ┃         ┗━━ 步骤 4 (读档): 恢复寄存器 -> 执行 IRET -> PC 指回新进程代码。
 ┃
 ┣━━ 🗺️ 4. 寻址系统 (The Mapping System) —— 负责"找路"
 ┃    ┣━━ 虚拟地址 (Virtual Address)
 ┃    ┃    ┗━━ [用户误解与修正] ❌ 误以为地址是运行时随机找的 -> ✅ 修正：编译器生成相对偏移，CPU 硬件自动切分索引。
 ┃    ┣━━ 页表体系 (Page Tables)
 ┃    ┃    ┣━━ [用户误解与修正] ❌ 误以为页表在 CPU 里 -> ✅ 修正：在内存 (RAM) 中，CPU 只有 CR3 指针。
 ┃    ┃    ┗━━ PTE (页表项): Present=1 指向内存 PFN；Present=0 指向磁盘 Swap Offset。
 ┃    ┗━━ TLB (快表)
 ┃         ┣━━ [用户误解与修正] ❌ 误以为 L1/L2 就是 TLB -> ✅ 修正：TLB 是专用地址缓存，L1/L2 是数据缓存。
 ┃         ┗━━ 优化: PCID 技术允许不同进程条目共存，减少 CR3 切换后的损耗。
 ┃
 ┣━━ 🚚 5. 数据缓存系统 (The Logistics System) —— 负责"运货"
 ┃    ┣━━ [用户提问] 既然有了物理地址，为什么不直接读内存？
 ┃    ┃    ┗━━ 原因: 速度鸿沟。CPU (纳秒级) vs 内存 (百纳秒级)。
 ┃    ┣━━ 缓存层级 (L1/L2/L3)
 ┃    ┃    ┗━━ 命中原理:
 ┃    ┃         ┣━━ 时间局部性: 刚访问过的变量 (如累加器) 马上再用。
 ┃    ┃         ┗━━ 空间局部性: [用户提问] 什么时候频繁工作？ -> 遍历数组时，Cache Line 预读 (64字节) 发挥极致性能。
 ┃
 ┣━━ ⚔️ 6. 并发与底层一致性 (Concurrency & Coherence) —— 负责"防打架"
 ┃    ┣━━ 📏 Cache Line (缓存行)
 ┃    ┃    ┣━━ 定义: 数据搬运和一致性管理的最小单位 (64 字节)。
 ┃    ┃    ┗━━ 机制: 总线嗅探 (Bus Snooping) + MESI 协议负责通知失效。
 ┃    ┣━━ 🚫 伪共享 (False Sharing)
 ┃    ┃    ┣━━ [用户提问] 什么是缓存行失效？ -> 现象：核 A 改数据，核 B 对应的整行缓存被迫 Invalid。
 ┃    ┃    ┗━━ [用户直觉解法] ✅ Padding (填充): 强制变量分居不同 Cache Line，物理隔离避免乒乓效应。
 ┃    ┗━━ 🔓 无锁编程 (Lock-Free)
 ┃         ┗━━ 本质: 利用原子指令 (CAS) 精细控制 Cache Line 状态，配合内存屏障 (禁止乱序)，替代互斥锁。
 ┃
 ┗━━ 📦 7. 兜底机制 (Swapping & Loading)
      ┣━━ 按需加载 (Lazy Loading): [用户误解修正] 程序启动不加载，用到时触发缺页异常才加载。
      ┗━━ 交换机制 (Swapping): 内存不足时 Swap Out 到共享交换区，PTE 记录磁盘偏移。
```