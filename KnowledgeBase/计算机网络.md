# 计算机网络

## TCP/UDP

## 📌 TCP三次握手（⭐⭐⭐⭐⭐ 必考）

### 🎯 得分关键词
> **SYN** | **SYN+ACK** | **ACK** | **半连接队列** | **全连接队列** | **防止旧连接** | **同步序列号** | **ISN** | **SYN_SENT** | **SYN_RCVD** | **ESTABLISHED**

### ✅ 核心流程（必须记住）

```
客户端                          服务器
  │                              │
  │────── SYN (seq=x) ──────────>│  第一次握手
  │                              │  🔑 客户端: CLOSED → SYN_SENT
  │                              │  🔑 服务器: LISTEN → SYN_RCVD
  │                              │  🔑 服务器分配资源，进入半连接队列
  │                              │
  │<──── SYN+ACK (seq=y,ack=x+1) │  第二次握手
  │                              │  🔑 服务器回复SYN+ACK，确认客户端序列号
  │                              │
  │─────── ACK (ack=y+1) ────────>│  第三次握手
  │                              │  🔑 双方: ESTABLISHED
  │                              │  🔑 连接从半连接队列→全连接队列
  │<══════ 开始传输数据 ═════════>│
```

**关键状态转换：**
```
客户端：CLOSED → SYN_SENT → ESTABLISHED
服务器：CLOSED → LISTEN → SYN_RCVD → ESTABLISHED
```

### 💡 深入理解（⭐⭐⭐⭐⭐ 高频追问）

#### 1️⃣ **为什么需要三次握手？** （⭐核心原因）

**原因1：防止旧连接建立**（最重要）

```
问题场景：
1. 客户端发送SYN1（网络延迟，滞留在网络中）
2. 客户端超时，重发SYN2
3. SYN2先到达，完成三次握手，建立连接
4. 连接使用完毕，四次挥手断开
5. 延迟的SYN1终于到达服务器

两次握手的问题：
❌ 服务器收到SYN1，回复SYN+ACK
❌ 服务器认为连接建立，分配资源
❌ 客户端已经关闭，不会响应
❌ 服务器资源被浪费

三次握手的解决：
✅ 服务器收到SYN1，回复SYN+ACK
✅ 客户端收到过期的SYN+ACK，发现不是自己的连接
✅ 客户端发送RST拒绝连接
✅ 服务器收到RST，释放资源
```

**原因2：同步初始序列号（ISN）**

```
TCP需要双方确认彼此的ISN（Initial Sequence Number）

第一次握手：客户端告诉服务器 "我的ISN是x"
第二次握手：服务器告诉客户端 "我收到你的x，我的ISN是y"
第三次握手：客户端告诉服务器 "我收到你的y"

🔑 ISN的作用：
- 数据包排序（按序列号重组）
- 去重（丢弃重复序列号的包）
- 确认机制（ACK = 期望收到的下一个序列号）
```

**原因3：确认双方收发能力**

```
第一次握手：服务器确认 ✅ 客户端发送能力OK，服务器接收能力OK
第二次握手：客户端确认 ✅ 双方收发能力都OK
第三次握手：服务器确认 ✅ 服务器发送能力OK，客户端接收能力OK

🔑 只有三次握手才能让双方都确认对方的收发能力正常
```

### 🔥 面试追问点

#### 1️⃣ 第三次握手ACK丢失怎么办？（⭐⭐⭐⭐⭐ 必问）

**服务器端：**
```
状态：SYN_RCVD（等待第三次ACK）

行为：
1. 重传SYN+ACK（默认5次，tcp_synack_retries配置）
2. 重传间隔：3s、6s、12s、24s、48s（指数退避）
3. 超时后：关闭连接，释放资源

代码示例：
// 查看配置
cat /proc/sys/net/ipv4/tcp_synack_retries
// 输出：5

// 修改重传次数
echo 3 > /proc/sys/net/ipv4/tcp_synack_retries
```

**客户端：**
```
状态：ESTABLISHED（connect()已返回）

问题：
❌ 客户端认为连接已建立，可以发送数据
❌ 但服务器还在SYN_RCVD状态，未完成握手
❌ 服务器收到数据包，发现连接不存在，回复RST

解决：
✅ 阻塞IO：connect()等待三次握手完成才返回
✅ 非阻塞IO：需要用 getsockopt(SO_ERROR) 检查连接状态

代码示例：
// 非阻塞connect检查
int error = 0;
socklen_t len = sizeof(error);
getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &error, &len);
if (error == 0) {
    // 连接成功
} else {
    // 连接失败，需要重连
}
```

**🔑 得分点：**
- 客户端需要处理服务器发来的RST，进行重连
- 非阻塞connect必须用getsockopt检查

#### 2️⃣ SYN洪水攻击如何防范？（⭐⭐⭐⭐⭐ 核心）

**攻击原理：**
```
攻击者发送大量SYN → 服务器回复SYN+ACK → 攻击者不回ACK
→ 半连接队列被占满 → 正常用户无法连接

示意图：
攻击者1 ──SYN──> 服务器（半连接队列：1/128）
攻击者2 ──SYN──> 服务器（半连接队列：2/128）
攻击者3 ──SYN──> 服务器（半连接队列：3/128）
...
攻击者N ──SYN──> 服务器（半连接队列：128/128 满了！）
正常用户 ──SYN──X 服务器（拒绝连接）
```

**防御手段：**

**方法1：SYN Cookies**（⭐⭐⭐⭐⭐ 最重要）
```cpp
原理：
1. 不分配资源，不进入半连接队列
2. 将连接信息编码到ISN序列号中
3. 收到ACK后，从序列号解码出连接信息
4. 验证通过后再分配资源

ISN编码公式：
ISN = hash(源IP, 源端口, 目的IP, 目的端口, 时间戳) + MSS编码

✅ 优点：
- 完全不占用半连接队列
- 可以应对无限SYN攻击

❌ 缺点：
- 无法使用TCP选项（如窗口缩放、SACK）
- ISN计算有性能开销

开启SYN Cookies：
echo 1 > /proc/sys/net/ipv4/tcp_syncookies
```

**方法2：调整内核参数**
```bash
# 半连接队列大小
net.ipv4.tcp_max_syn_backlog = 8192  # 默认128，调大到8192

# 全连接队列大小
net.core.somaxconn = 1024  # 默认128

# 减少SYN+ACK重传次数
net.ipv4.tcp_synack_retries = 2  # 默认5，减少到2

# 快速回收TIME_WAIT连接
net.ipv4.tcp_tw_reuse = 1
```

**方法3：使用防火墙**
```bash
# iptables限制单IP的SYN速率
iptables -A INPUT -p tcp --syn -m limit --limit 10/s --limit-burst 20 -j ACCEPT
iptables -A INPUT -p tcp --syn -j DROP
```

#### 3️⃣ 为什么不是两次握手？（⭐⭐⭐⭐⭐ 必问）

**两次握手的致命问题：**
```
场景：旧SYN包延迟到达

时间线：
T1: 客户端发送SYN1（延迟在网络中）
T2: 客户端超时，发送SYN2
T3: SYN2到达，完成两次握手，建立连接
T4: 连接使用完毕，关闭
T5: 延迟的SYN1到达服务器

两次握手：
❌ 服务器收到SYN1
❌ 服务器回复SYN+ACK（认为握手完成）
❌ 服务器进入ESTABLISHED，分配资源
❌ 客户端已关闭，不会发送数据
❌ 服务器资源永久浪费，直到超时

三次握手：
✅ 服务器收到SYN1
✅ 服务器回复SYN+ACK
✅ 客户端收到SYN+ACK，发现不是自己的连接
✅ 客户端回复RST拒绝
✅ 服务器收到RST，立即释放资源
```

**形象比喻：**
```
两次握手（电话）：
A: "喂，你能听到吗？"
B: "能听到，我们开始聊吧"
B开始说话，但A已经挂断了
❌ B白白浪费时间

三次握手（确认通话）：
A: "喂，你能听到吗？"
B: "能听到，你能听到我吗？"
A: "能听到"
✅ 双方确认都能通话，才开始聊天
```

#### 4️⃣ 半连接队列和全连接队列的区别？（⭐⭐⭐⭐）

**半连接队列（SYN Queue）：**
```cpp
定义：存储处于SYN_RCVD状态的连接

时机：
1. 服务器收到SYN
2. 服务器回复SYN+ACK
3. 连接进入半连接队列，等待第三次ACK

大小配置：
net.ipv4.tcp_max_syn_backlog = 8192

队列满的后果：
❌ 新的SYN包被丢弃
❌ 客户端connect超时
❌ 或者启用SYN Cookies

代码查看半连接队列：
netstat -n | grep SYN_RCVD | wc -l
```

**全连接队列（Accept Queue）：**
```cpp
定义：存储ESTABLISHED状态、等待accept()的连接

时机：
1. 服务器收到第三次ACK
2. 连接从半连接队列移到全连接队列
3. 等待应用层调用accept()取走

大小配置：
全连接队列大小 = min(somaxconn, listen的backlog参数)

代码示例：
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
bind(sockfd, ...);
listen(sockfd, 128);  // backlog=128
// 实际队列大小 = min(128, somaxconn)

队列满的后果：
❌ 第三次ACK被丢弃（或发送RST）
❌ 客户端会重传ACK
❌ 应用层accept()太慢导致队列溢出

查看全连接队列溢出次数：
netstat -s | grep "times the listen queue of a socket overflowed"
```

**图示对比：**
```
SYN包到达
    │
    ▼
┌────────────────┐
│  半连接队列     │ ← SYN_RCVD状态
│  等待第三次ACK  │
└────────┬───────┘
         │ 收到ACK
         ▼
┌────────────────┐
│  全连接队列     │ ← ESTABLISHED状态
│  等待accept()  │
└────────┬───────┘
         │ accept()取走
         ▼
    应用层处理
```

### 📊 状态转换图

```
客户端状态机：
CLOSED
  │ (主动发起连接)
  │ 发送SYN
  ▼
SYN_SENT
  │ 收到SYN+ACK
  │ 发送ACK
  ▼
ESTABLISHED ─────> 开始数据传输


服务器状态机：
CLOSED
  │ (调用listen)
  ▼
LISTEN
  │ 收到SYN
  │ 发送SYN+ACK
  ▼
SYN_RCVD
  │ 收到ACK
  ▼
ESTABLISHED ─────> 开始数据传输
```

### 🎓 面试回答模板

```
【标准回答】（30秒版本）
TCP三次握手是建立连接的过程，主要目的是：

1. 防止旧连接建立
   如果只有两次握手，网络中滞留的旧SYN包到达后，
   服务器会误认为是新连接请求，造成资源浪费。
   三次握手让客户端可以通过RST拒绝过期连接。

2. 同步初始序列号（ISN）
   双方需要确认彼此的ISN，用于后续数据传输的
   排序、去重和确认机制。

3. 确认双方收发能力正常
   三次握手让双方都确认对方的发送和接收能力。

【追问-第三次ACK丢失】
服务器会重传SYN+ACK（默认5次，间隔3s、6s、12s...），
如果客户端此时发送数据，服务器会回复RST。
客户端需要处理RST并重新建立连接。

【追问-SYN Flood攻击】
核心防御手段是SYN Cookies：
不分配资源，将连接信息编码到序列号中，
收到ACK后再验证并分配资源。
这样可以完全避免半连接队列被占满。

【追问-为什么不是两次】
两次握手无法防止旧连接：
延迟的SYN包到达后，服务器会误认为新连接，
分配资源后客户端不会响应，造成资源永久浪费。

【追问-半连接vs全连接队列】
半连接队列：存储SYN_RCVD状态，等待第三次ACK
全连接队列：存储ESTABLISHED状态，等待accept()取走
队列大小可通过tcp_max_syn_backlog和somaxconn配置。
```

### ⚠️ 常见误区

❌ **错误1**：说"三次握手是为了可靠传输"
✅ **正确**：三次握手是为了建立连接，可靠传输靠确认重传机制

❌ **错误2**：说"两次握手就够了"
✅ **正确**：必须说明两次握手的具体问题（无法防止旧连接建立）

❌ **错误3**：说"客户端发送第三次ACK后连接就建立了"
✅ **正确**：客户端在发送ACK后进入ESTABLISHED，但服务器收到ACK后才进入ESTABLISHED

❌ **错误4**：说"半连接队列就是listen的backlog参数"
✅ **正确**：backlog控制的是全连接队列，半连接队列由tcp_max_syn_backlog控制

### 🌟 加分点

- 提到半连接队列和全连接队列的具体实现
- 说出SYN Cookies的编码公式
- 知道非阻塞connect需要getsockopt检查
- 了解tcp_synack_retries等内核参数
- 能画出状态转换图
- 提到ISN的随机化（防止序列号预测攻击）

---

## 📌 TCP四次挥手（⭐⭐⭐⭐⭐ 必考）

### 🎯 得分关键词
> **FIN** | **ACK** | **TIME_WAIT** | **CLOSE_WAIT** | **2MSL** | **主动关闭** | **被动关闭** | **FIN_WAIT_1** | **FIN_WAIT_2** | **LAST_ACK**

### ✅ 核心流程（必须记住）

```
客户端(主动关闭)                    服务器(被动关闭)
  │                                │
  │────── FIN (seq=u) ────────────>│  第一次挥手
  │                                │  🔑 客户端: ESTABLISHED → FIN_WAIT_1
  │                                │  🔑 服务器: ESTABLISHED → CLOSE_WAIT
  │                                │
  │<────── ACK (ack=u+1) ──────────│  第二次挥手
  │                                │  🔑 客户端: FIN_WAIT_1 → FIN_WAIT_2
  │                                │  🔑 服务器保持CLOSE_WAIT状态
  │                                │
  │<────── FIN (seq=w) ────────────│  第三次挥手
  │                                │  🔑 服务器: CLOSE_WAIT → LAST_ACK
  │                                │  🔑 客户端: FIN_WAIT_2 → TIME_WAIT
  │                                │
  │─────── ACK (ack=w+1) ─────────>│  第四次挥手
  │                                │  🔑 服务器: LAST_ACK → CLOSED
  │  TIME_WAIT (等待2MSL)           │
  │  ├─ 60秒倒计时                  │
  │  └─> CLOSED                    │
```

**关键状态转换：**
```
主动关闭方：ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED
被动关闭方：ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED
```

### 💡 深入理解（⭐⭐⭐⭐⭐ 高频追问）

#### 1️⃣ **为什么需要四次挥手？**（⭐核心原因）

```
为什么不是三次？

原因：TCP是全双工通信，双向都需要独立关闭

三次握手建立连接：
客户端 → 服务器：SYN（我要连接）
服务器 → 客户端：SYN+ACK（同意连接+我也要连接）✅ 合并
客户端 → 服务器：ACK（同意连接）

四次挥手断开连接：
客户端 → 服务器：FIN（我不发数据了）
服务器 → 客户端：ACK（知道了）
❌ 不能合并！服务器可能还有数据要发
服务器 → 客户端：FIN（我也不发数据了）
客户端 → 服务器：ACK（知道了）

🔑 关键：
- 握手时：SYN+ACK可以合并（服务器主动建立反向连接）
- 挥手时：ACK+FIN不能合并（被动方可能还有数据发送）
```

**形象比喻：**
```
握手（打电话）：
A: "喂，我是A，能听到吗？"（SYN）
B: "能听到，我是B"（SYN+ACK）✅ B同时确认+建立连接
A: "好的"（ACK）

挥手（挂电话）：
A: "我说完了"（FIN）
B: "我知道了"（ACK）
B: "等等，我还有话要说..."（继续发送数据）
B: "好了，我也说完了"（FIN）
A: "知道了，挂了"（ACK）
```

#### 2️⃣ **TIME_WAIT状态详解**（⭐⭐⭐⭐⭐ 核心）

**TIME_WAIT存在的两个原因：**

**原因1：确保最后的ACK送达**
```
场景：主动关闭方发送最后的ACK后，如果立即CLOSED

时间线：
1. 主动方发送ACK → 进入TIME_WAIT
2. ACK在网络中丢失
3. 被动方等待ACK超时，重发FIN
4. 主动方已CLOSED，收到FIN后：
   - 如果无TIME_WAIT：回复RST（连接不存在）
   - 有TIME_WAIT：重新发送ACK ✅

🔑 TIME_WAIT期间：
- 保持连接状态
- 如果收到重传的FIN，重新发送ACK
- 确保被动方能正常关闭
```

**原因2：防止旧连接数据干扰新连接**
```cpp
// 场景：端口复用问题

// 旧连接
客户端(192.168.1.100:12345) → 服务器(192.168.1.200:80)
发送数据包（seq=1000）→ 网络延迟

// 立即建立新连接（相同四元组）
客户端(192.168.1.100:12345) → 服务器(192.168.1.200:80)
发送数据包（seq=10）

// 问题：
延迟的旧包（seq=1000）到达
→ 新连接收到脏数据 ❌

// TIME_WAIT解决：
等待2MSL（2 × 报文最大生存时间）
→ 所有旧包都已过期失效
→ 新连接不会收到旧包 ✅

// 2MSL计算：
MSL = 30秒（Linux默认）
2MSL = 60秒
- 去程：ACK到达对方（最多1MSL）
- 回程：如果ACK丢失，FIN重传回来（最多1MSL）
```

**TIME_WAIT的代价：**
```cpp
// 问题：TIME_WAIT过多

// 场景：高并发短连接服务器
每秒10000个连接，每个连接1秒完成
→ 主动关闭后进入TIME_WAIT（60秒）
→ 累积：10000 × 60 = 60万个TIME_WAIT连接

// 危害：
1. 占用端口资源
   - 客户端可用端口：28232个（1024-65535，去掉保留）
   - 60万个TIME_WAIT → 端口耗尽

2. 占用内存
   - 每个TIME_WAIT：约4KB内核结构
   - 60万 × 4KB = 2.4GB内存

// 查看TIME_WAIT数量
netstat -n | grep TIME_WAIT | wc -l

// 解决方案：
1. 使用长连接（HTTP Keep-Alive）
2. 让客户端主动关闭（服务器被动关闭）
3. 调整内核参数：
   net.ipv4.tcp_tw_reuse = 1      // 复用TIME_WAIT
   net.ipv4.tcp_tw_recycle = 1    // 快速回收（不推荐，NAT环境有问题）
4. SO_LINGER选项（谨慎使用）
```

#### 3️⃣ **CLOSE_WAIT状态详解**（⭐⭐⭐⭐⭐ 实际问题）

**CLOSE_WAIT产生原因：**
```cpp
// 状态转换
被动关闭方：ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED
                          ↑
                    收到对方FIN，回复ACK
                    但自己还没调用close()

// 正常流程：
1. 对方发送FIN
2. 内核自动回复ACK → 进入CLOSE_WAIT
3. 应用层调用close() → 发送FIN → 进入LAST_ACK
4. 收到对方ACK → CLOSED

// ❌ 问题流程：
1. 对方发送FIN
2. 内核自动回复ACK → 进入CLOSE_WAIT
3. 应用层忘记调用close() ❌
4. 永远停留在CLOSE_WAIT状态
```

**CLOSE_WAIT堆积原因（应用层Bug）：**
```cpp
// 错误示例1：忘记关闭连接
void HandleClient(int sockfd) {
    char buf[1024];

    while (true) {
        int n = recv(sockfd, buf, sizeof(buf), 0);
        if (n <= 0) {
            // ❌ 错误：收到FIN后，没有close(sockfd)
            break;  // 直接退出，sockfd泄漏
        }

        process(buf, n);
    }

    // ❌ 从未执行到这里
    close(sockfd);
}

// ✅ 正确写法
void HandleClient(int sockfd) {
    char buf[1024];

    while (true) {
        int n = recv(sockfd, buf, sizeof(buf), 0);
        if (n <= 0) {
            close(sockfd);  // ✅ 立即关闭
            break;
        }

        process(buf, n);
    }
}

// 错误示例2：异常退出未关闭
void HandleRequest() {
    int sockfd = accept(...);

    if (someCondition) {
        return;  // ❌ 异常退出，未关闭sockfd
    }

    process(sockfd);
    close(sockfd);
}

// ✅ 正确写法：使用RAII
class SocketGuard {
    int fd;
public:
    SocketGuard(int f) : fd(f) {}
    ~SocketGuard() { if (fd >= 0) close(fd); }
};

void HandleRequest() {
    int sockfd = accept(...);
    SocketGuard guard(sockfd);  // ✅ 自动关闭

    if (someCondition) {
        return;  // ✅ 析构函数自动close
    }

    process(sockfd);
}
```

**诊断CLOSE_WAIT问题：**
```bash
# 查看CLOSE_WAIT数量
netstat -n | grep CLOSE_WAIT | wc -l

# 查看具体连接
netstat -antp | grep CLOSE_WAIT

# 找出进程
lsof -i | grep CLOSE_WAIT

# 🔑 诊断方法：
如果CLOSE_WAIT持续增长 → 应用层Bug
如果TIME_WAIT持续增长 → 架构问题（主动关闭过多）
```

### 🔥 面试追问点

#### 1️⃣ 2MSL的值是多少？为什么是2倍？（⭐⭐⭐⭐⭐ 必问）

**2MSL的值：**
```
MSL（Maximum Segment Lifetime）：报文最大生存时间

RFC 793标准：MSL = 2分钟
Linux实现：MSL = 30秒 → 2MSL = 60秒
Windows：MSL = 120秒 → 2MSL = 240秒

// 查看Linux配置
cat /proc/sys/net/ipv4/tcp_fin_timeout
# 输出：60（秒）
```

**为什么是2倍MSL？**
```
时间线分析：

T0: 主动方发送最后的ACK
    ├─ 最坏情况：ACK在网络中传输1MSL后到达被动方
    │
T0+MSL: 被动方收到ACK，正常关闭 ✅

    但如果ACK丢失：
T0+MSL: 被动方超时，重传FIN
    ├─ FIN在网络中传输1MSL后到达主动方
    │
T0+2MSL: 主动方收到重传的FIN，重新发送ACK

🔑 2MSL保证：
- 去程：ACK消失（1MSL）
- 回程：重传FIN到达（1MSL）
- 总计：2MSL

如果只等1MSL：
T0: 发送ACK
T0+MSL: ACK丢失，被动方重传FIN，但主动方已CLOSED
→ 主动方回复RST ❌
→ 被动方异常关闭 ❌
```

#### 2️⃣ 如果第二次挥手ACK丢失怎么办？（⭐⭐⭐⭐）

```cpp
// 场景：主动方发送FIN，被动方的ACK丢失

时间线：
T0: 主动方发送FIN，进入FIN_WAIT_1
T1: 被动方收到FIN，发送ACK，进入CLOSE_WAIT
T2: ACK在网络中丢失 ❌
T3: 主动方等待ACK超时

// 主动方行为：
主动方在FIN_WAIT_1状态等待ACK
如果超时（RTO），重传FIN

重传机制：
1. 第1次重传：等待1个RTO（约200ms）
2. 第2次重传：等待2个RTO（约400ms）
3. 第3次重传：等待4个RTO（约800ms）
...
最多重传：tcp_orphan_retries次（默认8次）

// 被动方行为：
已经进入CLOSE_WAIT状态，ACK丢失不影响
如果收到重传的FIN：
→ 重新发送ACK ✅

// 🔑 关键点：
1. 第二次挥手（ACK）丢失，主动方会重传FIN
2. 被动方收到重传FIN，会重新回复ACK
3. 机制与三次握手的第三次ACK丢失类似

// 代码验证：
// 主动方
shutdown(sockfd, SHUT_WR);  // 发送FIN
// 进入FIN_WAIT_1，等待ACK
// 如果ACK丢失，内核自动重传FIN
```

#### 3️⃣ 能否把四次挥手优化成三次？（⭐⭐⭐⭐⭐ 高频）

**可以，在特定情况下！**

```cpp
// 场景：被动方收到FIN时，没有数据要发送

正常四次挥手：
客户端 → FIN
服务器 → ACK         // 第2次
（服务器继续发送数据）
服务器 → FIN         // 第3次
客户端 → ACK

优化成三次（延迟确认）：
客户端 → FIN
服务器 → ACK+FIN     // ✅ 合并第2、3次
客户端 → ACK

// 🔑 条件：
1. 被动方收到FIN时，没有数据要发送
2. 被动方的应用层立即调用close()
3. 使用TCP_QUICKACK选项

// Linux实现：
setsockopt(sockfd, IPPROTO_TCP, TCP_QUICKACK, &val, sizeof(val));

// 实际中：
大部分情况下，被动方收到FIN时：
- 可能还有数据在发送缓冲区
- 应用层可能还在处理请求
→ 无法立即发送FIN
→ 必须分两步：ACK + FIN
```

**状态转换对比：**
```
四次挥手（正常）：
主动方：ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED
被动方：ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED

三次挥手（优化）：
主动方：ESTABLISHED → FIN_WAIT_1 → TIME_WAIT → CLOSED
被动方：ESTABLISHED → LAST_ACK → CLOSED

🔑 差异：
- 主动方跳过FIN_WAIT_2（直接收到FIN+ACK）
- 被动方跳过CLOSE_WAIT（立即发送FIN）
```

#### 4️⃣ SO_LINGER选项的作用？（⭐⭐⭐⭐ 重要）

```cpp
// SO_LINGER：控制close()的行为

struct linger {
    int l_onoff;    // 0=关闭，1=开启
    int l_linger;   // 等待时间（秒）
};

// 场景1：默认行为（l_onoff=0）
close(sockfd);
// 立即返回
// 内核负责发送剩余数据和FIN
// 正常四次挥手

// 场景2：优雅关闭（l_onoff=1, l_linger>0）
struct linger lg;
lg.l_onoff = 1;
lg.l_linger = 5;  // 等待5秒
setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &lg, sizeof(lg));

close(sockfd);
// ✅ 阻塞最多5秒，直到：
//    1. 所有数据发送完成且收到ACK
//    2. 完成四次挥手
//    3. 超时
// close()才返回

// 场景3：强制关闭（l_onoff=1, l_linger=0）⚠️ 危险
struct linger lg;
lg.l_onoff = 1;
lg.l_linger = 0;  // ❌ 不等待
setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &lg, sizeof(lg));

close(sockfd);
// ❌ 发送RST（不是FIN）
// ❌ 丢弃发送缓冲区数据
// ❌ 不经过TIME_WAIT，直接CLOSED
// ⚠️ 危险：可能导致数据丢失

// 🔑 使用场景：
场景1（默认）：✅ 适合大部分情况
场景2（优雅）：✅ 需要确保数据发送完成
场景3（强制）：❌ 仅用于异常情况（如紧急退出）

// 强制关闭的危害：
1. 数据丢失：发送缓冲区的数据被丢弃
2. 对端收到RST，异常中断
3. 跳过TIME_WAIT，可能导致旧包干扰新连接

// 示例：优雅关闭
void graceful_close(int sockfd) {
    // 1. 先shutdown写端
    shutdown(sockfd, SHUT_WR);  // 发送FIN，不再发送数据

    // 2. 读取对方剩余数据
    char buf[1024];
    while (recv(sockfd, buf, sizeof(buf), 0) > 0) {
        // 读取并丢弃
    }

    // 3. 关闭连接
    close(sockfd);
}
```

### 📊 状态机图

```
主动关闭方状态机：
┌─────────────┐
│ ESTABLISHED │
└──────┬──────┘
       │ 应用层调用close()
       │ 发送FIN
       ▼
┌─────────────┐
│ FIN_WAIT_1  │ ← 等待对方ACK
└──────┬──────┘
       │ 收到ACK
       ▼
┌─────────────┐
│ FIN_WAIT_2  │ ← 等待对方FIN
└──────┬──────┘
       │ 收到FIN，发送ACK
       ▼
┌─────────────┐
│ TIME_WAIT   │ ← 等待2MSL（60秒）
└──────┬──────┘
       │ 2MSL超时
       ▼
┌─────────────┐
│   CLOSED    │
└─────────────┘

被动关闭方状态机：
┌─────────────┐
│ ESTABLISHED │
└──────┬──────┘
       │ 收到对方FIN
       │ 内核自动回复ACK
       ▼
┌─────────────┐
│ CLOSE_WAIT  │ ← 等待应用层close()
└──────┬──────┘    ⚠️ 如果不调用close()
       │            永远停留在此状态
       │ 应用层调用close()
       │ 发送FIN
       ▼
┌─────────────┐
│  LAST_ACK   │ ← 等待最后的ACK
└──────┬──────┘
       │ 收到ACK
       ▼
┌─────────────┐
│   CLOSED    │
└─────────────┘
```

### 🎓 面试回答模板

```
【标准回答】（30秒版本）

TCP四次挥手是断开连接的过程，需要四次是因为TCP是全双工通信：

1. 第一次挥手：客户端发送FIN，表示不再发送数据
   → 客户端进入FIN_WAIT_1

2. 第二次挥手：服务器回复ACK，表示收到关闭请求
   → 服务器进入CLOSE_WAIT，客户端进入FIN_WAIT_2

3. 第三次挥手：服务器发送FIN，表示也不再发送数据
   → 服务器进入LAST_ACK，客户端进入TIME_WAIT

4. 第四次挥手：客户端发送ACK，确认关闭
   → 服务器CLOSED，客户端等待2MSL后CLOSED

【追问-TIME_WAIT作用】
TIME_WAIT等待2MSL（60秒）有两个作用：
1. 确保最后的ACK送达，如果丢失可以重传
2. 等待旧连接的数据包过期，避免干扰新连接

【追问-CLOSE_WAIT堆积】
CLOSE_WAIT堆积说明应用层收到对方FIN后，忘记调用close()。
这是应用层Bug，需要检查代码中是否有连接泄漏。

【追问-TIME_WAIT过多】
TIME_WAIT过多说明服务器主动关闭连接过多。
解决方法：
1. 使用长连接减少连接创建
2. 让客户端主动关闭（服务器被动关闭）
3. 开启tcp_tw_reuse复用TIME_WAIT
```

### ⚠️ 常见误区

❌ **错误1**：认为四次挥手可以合并成三次
✅ **正确**：只有在被动方没有数据要发送且立即close()时才能合并

❌ **错误2**：认为TIME_WAIT是被动关闭方的状态
✅ **正确**：TIME_WAIT是主动关闭方的状态，持续2MSL

❌ **错误3**：认为CLOSE_WAIT是正常状态
✅ **正确**：CLOSE_WAIT应该很快消失，堆积说明应用层Bug

❌ **错误4**：使用SO_LINGER(0)来避免TIME_WAIT
✅ **正确**：这会发送RST强制关闭，可能丢失数据，非常危险

❌ **错误5**：认为2MSL是固定的120秒
✅ **正确**：Linux默认60秒，Windows是240秒，取决于系统实现

### 🌟 加分点

- 说出2MSL的具体计算（去程1MSL + 回程1MSL）
- 知道tcp_fin_timeout参数可以调整TIME_WAIT时间
- 了解SO_LINGER的三种场景及危害
- 能诊断CLOSE_WAIT和TIME_WAIT堆积问题
- 知道shutdown()和close()的区别
- 提到半关闭状态（shutdown SHUT_WR后仍可接收数据）
- 了解tcp_tw_reuse和tcp_tw_recycle的区别

## 📌 TCP流量控制与拥塞控制（⭐⭐⭐⭐⭐ 必考）

### 🎯 得分关键词
> **滑动窗口** | **rwnd** | **cwnd** | **慢启动** | **拥塞避免** | **快速重传** | **快速恢复** | **ssthresh** | **AIMD** | **超时重传**

### ✅ 核心区别（必须掌握）

| 特性 | 流量控制(Flow Control) | 拥塞控制(Congestion Control) |
|------|----------------------|---------------------------|
| **目的** | 防止接收方缓冲区溢出 | 防止网络拥塞 |
| **关注对象** | 接收方处理能力 | 网络传输能力 |
| **控制窗口** | rwnd（接收窗口） | cwnd（拥塞窗口） |
| **窗口来源** | 接收方告知 | 发送方自己维护 |
| **控制范围** | 端到端 | 端到网络 |
| **实际发送窗口** | `min(rwnd, cwnd)` | - |

**🔑 实际发送窗口大小：**
```
发送窗口 = min(接收窗口rwnd, 拥塞窗口cwnd)

示例：
rwnd = 64KB（接收方缓冲区剩余）
cwnd = 32KB（网络允许）
→ 实际发送窗口 = 32KB（取小值）
```

---

## 💡 流量控制详解（⭐⭐⭐⭐⭐ 核心）

### ✅ 滑动窗口机制

**基本原理：**
```
发送方                                接收方
┌────────────────────┐              ┌────────────────────┐
│  发送缓冲区         │              │  接收缓冲区         │
│  ┌──────────────┐  │              │  ┌──────────────┐  │
│  │已发送已确认   │  │              │  │已接收已读取   │  │
│  ├──────────────┤  │              │  ├──────────────┤  │
│  │已发送未确认   │←─┼──────────────┼──│已接收未读取   │  │
│  ├──────────────┤  │   ACK+rwnd   │  ├──────────────┤  │
│  │可发送        │←─┼──────────────┼──│可接收(rwnd)   │  │
│  ├──────────────┤  │              │  └──────────────┘  │
│  │暂不可发送     │  │              │                    │
│  └──────────────┘  │              └────────────────────┘
└────────────────────┘
```

**TCP报文头中的窗口字段：**
```cpp
struct tcp_header {
    uint16_t source_port;
    uint16_t dest_port;
    uint32_t seq;
    uint32_t ack;
    // ...
    uint16_t window;  // 🔑 接收窗口大小（rwnd）
    // ...
};

// 接收方在每个ACK中告知发送方
// window字段 = 接收缓冲区剩余大小
```

**窗口更新过程：**
```
时刻1：接收方缓冲区满64KB
      发送ACK：window=64KB

时刻2：应用层读取32KB
      发送ACK：window=64KB（剩余32KB + 读取32KB）

时刻3：接收到16KB数据
      发送ACK：window=48KB（64KB - 16KB）

🔑 接收方通过ACK包的window字段实时通知发送方
```

### 🔥 面试追问点

#### 1️⃣ 零窗口问题与解决（⭐⭐⭐⭐⭐ 高频）

**问题场景：**
```
1. 接收方缓冲区满：发送window=0
2. 发送方停止发送
3. 接收方读取数据，缓冲区有空间
4. 接收方发送window更新包 → 丢失！
5. 发送方永远等待，接收方永远不再发送窗口更新

🔑 死锁状态
```

**解决方案：零窗口探测（Zero Window Probe）**
```cpp
// 发送方行为
if (rwnd == 0) {
    // 🔑 启动持续定时器
    start_persist_timer();

    // 定期发送零窗口探测包（1字节）
    while (rwnd == 0) {
        send_zero_window_probe();  // 发送1字节数据
        wait(persist_timeout);
        persist_timeout *= 2;  // 指数退避：5s, 10s, 20s...
    }
}

// 接收方行为
on_receive_probe() {
    // 强制回复ACK（即使没有新数据）
    send_ack_with_current_window();
}

// Linux参数
cat /proc/sys/net/ipv4/tcp_retries2  // 最大探测次数：15
```

**🔑 得分点：**
- 零窗口探测避免死锁
- 探测间隔指数退避
- 强制接收方回复窗口更新

#### 2️⃣ 糊涂窗口综合症（Silly Window Syndrome）（⭐⭐⭐⭐）

**问题：**
```
场景：接收方缓冲区几乎满，只剩1字节
1. 接收方发送window=1
2. 发送方发送1字节数据（效率极低）
3. 接收方读取1字节，window=1
4. 循环往复...

问题：
- 1字节数据 + 40字节头部（IP20+TCP20） = 41字节
- 网络利用率：1/41 = 2.4% ❌
```

**解决方案：**

**接收方：延迟发送窗口更新**
```cpp
// 🔑 接收方规则
void update_window() {
    int available = buffer_size - used;

    if (available < min(MSS, buffer_size/2)) {
        // 可用空间太小，不发送窗口更新
        // 等待直到：
        // 1. 空间 >= MSS（1460字节）
        // 2. 空间 >= 缓冲区一半
        return;
    }

    send_window_update(available);
}
```

**发送方：Nagle算法**
```cpp
// 🔑 发送方规则（Nagle算法）
void send_data(char* data, int len) {
    if (len >= MSS) {
        // 数据足够大，立即发送
        send_segment(data, len);
    } else if (no_outstanding_data()) {
        // 没有未确认的数据，立即发送
        send_segment(data, len);
    } else {
        // 🔑 有未确认数据且数据小，缓存等待
        // 直到：
        // 1. 累积到MSS大小
        // 2. 收到之前数据的ACK
        buffer_and_wait(data, len);
    }
}

// 禁用Nagle算法（实时性要求高时）
setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val));
```

**🔑 得分点：**
- 接收方：窗口更新阈值（MSS或缓冲区一半）
- 发送方：Nagle算法（累积数据）
- TCP_NODELAY选项的作用

---

## 💡 拥塞控制详解（⭐⭐⭐⭐⭐ 核心）

### ✅ 四个核心算法

**拥塞控制状态变量：**
```cpp
int cwnd;       // 拥塞窗口（Congestion Window）
int ssthresh;   // 慢启动阈值（Slow Start Threshold）
int MSS;        // 最大报文段大小（Maximum Segment Size）

// 🔑 实际发送窗口
int send_window = min(cwnd, rwnd);
```

### 1️⃣ 慢启动（Slow Start）（⭐⭐⭐⭐⭐ 必考）

**算法原理：**
```
初始状态：
cwnd = 1 MSS（或现代TCP：10 MSS）
ssthresh = 64 KB（默认值）

慢启动过程：
时刻1: cwnd=1, 发送1个MSS
      收到ACK → cwnd=2

时刻2: cwnd=2, 发送2个MSS
      收到2个ACK → cwnd=4

时刻3: cwnd=4, 发送4个MSS
      收到4个ACK → cwnd=8

...

🔑 指数增长：cwnd每个RTT翻倍
```

**图示：**
```
cwnd (MSS)
    ↑
 64 │           ╱────────  到达ssthresh，进入拥塞避免
    │          ╱
 32 │        ╱
    │      ╱
 16 │    ╱
    │  ╱
  8 │ ╱
    │╱
  4 ╱
  2╱
  1────────────────────────────────────> 时间(RTT)
    0   1   2   3   4   5   6

🔑 慢启动阶段：指数增长（每个RTT翻倍）
```

**代码模拟：**
```cpp
// 🔑 慢启动算法
void slow_start() {
    cwnd = 1 * MSS;  // 初始值（现代TCP可能是10 MSS）

    while (cwnd < ssthresh) {
        // 每收到一个ACK，cwnd += 1 MSS
        on_ack_received() {
            cwnd += MSS;
        }

        // 效果：每个RTT后cwnd翻倍
        // RTT1: cwnd=1, 收到1个ACK → cwnd=2
        // RTT2: cwnd=2, 收到2个ACK → cwnd=4
        // RTT3: cwnd=4, 收到4个ACK → cwnd=8
    }

    // 到达阈值，切换到拥塞避免
    congestion_avoidance();
}
```

### 2️⃣ 拥塞避免（Congestion Avoidance）（⭐⭐⭐⭐⭐ 必考）

**算法原理：**
```
条件：cwnd >= ssthresh

拥塞避免过程：
时刻1: cwnd=64, 发送64个MSS
      收到64个ACK → cwnd=65

时刻2: cwnd=65, 发送65个MSS
      收到65个ACK → cwnd=66

...

🔑 线性增长：cwnd每个RTT增加1 MSS
```

**代码模拟：**
```cpp
// 🔑 拥塞避免算法（AIMD：Additive Increase Multiplicative Decrease）
void congestion_avoidance() {
    while (true) {
        on_ack_received() {
            // 🔑 每个ACK增加：MSS * MSS / cwnd
            // 效果：每个RTT增加1 MSS
            cwnd += MSS * MSS / cwnd;
        }

        // 示例：
        // cwnd=64 MSS时，发送64个包
        // 每收到1个ACK：cwnd += 1/64 MSS
        // 收到64个ACK后：cwnd = 64 + 64*(1/64) = 65 MSS
    }
}
```

**🔑 AIMD原理：**
```
Additive Increase（加法增长）：
  cwnd每个RTT增加1 MSS

Multiplicative Decrease（乘法减少）：
  检测到拥塞时，cwnd减半

为什么用AIMD？
✅ 公平性：多个流最终收敛到公平分配
✅ 效率：充分利用带宽
✅ 稳定性：避免剧烈波动
```

### 3️⃣ 快速重传（Fast Retransmit）（⭐⭐⭐⭐⭐ 必考）

**问题场景：**
```
发送方发送：seq=1, seq=2, seq=3, seq=4, seq=5
接收方收到：seq=1, seq=3, seq=4, seq=5（seq=2丢失）

接收方行为：
收到seq=1 → ACK=2（期望收到2）
收到seq=3 → ACK=2（仍然期望2，重复ACK）
收到seq=4 → ACK=2（重复ACK）
收到seq=5 → ACK=2（重复ACK）

❌ 传统做法：等待超时重传（RTO约200ms-1s）
✅ 快速重传：收到3个重复ACK，立即重传
```

**算法原理：**
```cpp
int duplicate_acks = 0;

void on_ack_received(int ack_num) {
    if (ack_num == last_ack) {
        duplicate_acks++;

        if (duplicate_acks == 3) {
            // 🔑 收到3个重复ACK，触发快速重传
            fast_retransmit(ack_num);
            fast_recovery();
        }
    } else {
        // 新的ACK
        duplicate_acks = 0;
        last_ack = ack_num;
    }
}

void fast_retransmit(int ack_num) {
    // 🔑 立即重传丢失的包
    retransmit_segment(ack_num);

    // 🔑 调整拥塞窗口
    ssthresh = cwnd / 2;  // 阈值减半
    cwnd = ssthresh + 3 * MSS;  // 窗口设为阈值+3
}
```

**为什么是3个重复ACK？**
```
收到1个重复ACK：
  可能是乱序到达（不是丢包）

收到2个重复ACK：
  可能还是乱序

收到3个重复ACK：
  ✅ 基本确定是丢包（不是乱序）
  ✅ 说明后续包已经到达（网络没有完全拥塞）
  ✅ 可以快速重传，不必等待超时
```

### 4️⃣ 快速恢复（Fast Recovery）（⭐⭐⭐⭐⭐ 必考）

**算法原理：**
```cpp
void fast_recovery() {
    // 🔑 已经设置：
    // ssthresh = cwnd / 2
    // cwnd = ssthresh + 3 * MSS

    // 每收到一个重复ACK
    while (receiving_duplicate_acks()) {
        cwnd += MSS;  // 临时膨胀窗口

        if (cwnd允许) {
            send_new_segment();  // 继续发送新数据
        }
    }

    // 收到新的ACK（确认重传的包）
    on_new_ack() {
        cwnd = ssthresh;  // 🔑 恢复到阈值
        // 继续拥塞避免阶段
        congestion_avoidance();
    }
}
```

**为什么要快速恢复？**
```
❌ 传统做法（Tahoe版本）：
  检测到丢包 → cwnd=1, 重新慢启动
  问题：过于保守，带宽利用率低

✅ 快速恢复（Reno版本）：
  检测到丢包 → cwnd=ssthresh（减半）
  优点：
  1. 收到重复ACK说明网络没有完全拥塞
  2. 不必从1开始，直接从ssthresh恢复
  3. 更快恢复到正常传输速度
```

### 5️⃣ 超时重传（Timeout Retransmit）（⭐⭐⭐⭐⭐ 必考）

**触发条件：**
```
超时重传定时器(RTO)到期，仍未收到ACK

RTO计算：
RTO = SRTT + 4 × RTTVAR

SRTT：平滑往返时间
RTTVAR：RTT变化量

典型值：RTO ≈ 200ms - 1s
```

**算法行为：**
```cpp
void on_timeout() {
    // 🔑 超时说明网络严重拥塞

    // 1. 调整拥塞参数
    ssthresh = cwnd / 2;  // 阈值减半
    cwnd = 1 * MSS;       // 窗口回到初始值

    // 2. 重传丢失的包
    retransmit_segment();

    // 3. 重新慢启动
    slow_start();

    // 4. RTO指数退避
    RTO *= 2;  // 下次超时时间翻倍
}
```

**超时重传 vs 快速重传：**
```
快速重传（轻度拥塞）：
  收到3个重复ACK
  → cwnd = ssthresh（减半）
  → 快速恢复

超时重传（严重拥塞）：
  RTO超时
  → cwnd = 1 MSS
  → 重新慢启动

🔑 超时重传更严厉（认为网络严重拥塞）
```

---

## 📊 拥塞控制状态转换图（⭐⭐⭐⭐⭐ 必考）

```
初始化
  │ cwnd=1, ssthresh=64KB
  ▼
┌──────────────┐
│  慢启动       │  cwnd < ssthresh
│  指数增长     │  每RTT: cwnd *= 2
└──┬───────┬───┘
   │       │
   │       │ 收到3个重复ACK
   │       ▼
   │   ┌──────────────┐
   │   │  快速重传     │  重传丢失包
   │   │  快速恢复     │  ssthresh=cwnd/2
   │   └──────┬───────┘  cwnd=ssthresh+3
   │          │
   │          │ 收到新ACK
   │          ▼
   │   ┌──────────────┐
   │   │  拥塞避免     │  cwnd >= ssthresh
   │◄──┤  线性增长     │  每RTT: cwnd += 1
   │   └──┬───────────┘
   │      │
   │      │ 收到3个重复ACK
   │      └───────────┐
   │                  ▼
   │              （快速重传）
   │
   │ 超时重传
   ▼
 cwnd=1
ssthresh=cwnd/2
 重新慢启动
```

---

## 🔥 面试追问点

### 1️⃣ TCP拥塞控制和流量控制的区别？（⭐⭐⭐⭐⭐ 必问）

```
【标准回答】

流量控制（Flow Control）：
- 目的：防止接收方缓冲区溢出
- 对象：接收方的处理能力
- 窗口：rwnd（接收方告知）
- 机制：滑动窗口

拥塞控制（Congestion Control）：
- 目的：防止网络拥塞
- 对象：网络的传输能力
- 窗口：cwnd（发送方维护）
- 机制：慢启动、拥塞避免、快速重传、快速恢复

实际发送窗口 = min(rwnd, cwnd)

【举例说明】
场景：下载大文件
- rwnd=128KB（接收方缓冲区够大）
- cwnd=32KB（网络拥塞）
→ 实际发送窗口=32KB（受网络限制）

场景：接收方处理慢
- rwnd=8KB（接收方缓冲区小）
- cwnd=64KB（网络通畅）
→ 实际发送窗口=8KB（受接收方限制）
```

### 2️⃣ 为什么慢启动是指数增长？（⭐⭐⭐⭐⭐ 高频）

```
【原理分析】

每收到一个ACK，cwnd += 1 MSS

第1个RTT:
  cwnd=1, 发送1个MSS
  收到1个ACK → cwnd=2

第2个RTT:
  cwnd=2, 发送2个MSS
  收到2个ACK → cwnd=2+2=4

第3个RTT:
  cwnd=4, 发送4个MSS
  收到4个ACK → cwnd=4+4=8

🔑 关键：
- 单个ACK: cwnd += 1
- 但一个RTT发送cwnd个包，收到cwnd个ACK
- 结果：每个RTT后cwnd翻倍

【为什么叫"慢"启动？】
相对于一次性发送大量数据，指数增长已经是"慢"的
目的是探测网络容量，避免一开始就拥塞
```

### 3️⃣ 快速重传为什么要+3 MSS？（⭐⭐⭐⭐）

```cpp
// 快速重传时
ssthresh = cwnd / 2;
cwnd = ssthresh + 3 * MSS;  // 🔑 为什么+3？

【原因】
收到3个重复ACK说明：
1. 丢失包之后的3个包已经到达接收方
2. 这3个包已经离开了网络（在接收方缓冲区）
3. 网络中空出了3个MSS的空间

因此：
cwnd = ssthresh + 3 * MSS
      ^^^^^^^^   ^^^^^^^
      拥塞控制    已离开网络的数据

允许继续发送3个新包，填补网络中的"空洞"

【快速恢复期间】
每收到1个重复ACK:
  cwnd += 1 MSS  // 又有1个包离开网络

收到新ACK（确认重传包）:
  cwnd = ssthresh  // 恢复正常
```

### 4️⃣ 什么时候用超时重传，什么时候用快速重传？（⭐⭐⭐⭐⭐ 核心）

```
【快速重传】
条件：收到3个重复ACK
说明：
  ✅ 后续包已到达（网络部分通畅）
  ✅ 只是个别包丢失
措施：
  立即重传丢失包
  cwnd减半（ssthresh）
  进入快速恢复

【超时重传】
条件：RTO超时
说明：
  ❌ 没有收到任何ACK（连重复ACK都没有）
  ❌ 网络严重拥塞或中断
措施：
  重传丢失包
  cwnd=1 MSS（回到初始值）
  ssthresh减半
  重新慢启动

🔑 区别：
快速重传：轻度拥塞，温和处理（减半）
超时重传：严重拥塞，严厉处理（归零）

【实际例子】
快速重传：
  发送seq=1,2,3,4,5
  seq=2丢失，但收到3,4,5
  → 3个重复ACK=2
  → 快速重传seq=2

超时重传：
  发送seq=1
  网络中断，完全没有ACK
  → RTO超时
  → 重传seq=1，cwnd=1
```

### 5️⃣ TCP Tahoe、Reno、NewReno的区别？（⭐⭐⭐⭐ 加分项）

```
【TCP Tahoe（1988）】
特点：
  超时重传：cwnd=1，重新慢启动
  快速重传：cwnd=1，重新慢启动

问题：过于保守

【TCP Reno（1990）】
特点：
  超时重传：cwnd=1，重新慢启动
  快速重传：cwnd=ssthresh（减半），快速恢复 ✅

优点：快速重传后恢复更快
问题：一个窗口多个丢包时，仍需超时

【TCP NewReno（1999）】
特点：
  改进快速恢复，处理多个丢包
  收到部分新ACK（Partial ACK）时继续快速恢复

优点：多丢包场景性能更好

【现代Linux（CUBIC、BBR）】
CUBIC：
  - 立方窗口增长函数
  - 对高带宽长延迟网络更友好

BBR（Bottleneck Bandwidth and RTT）：
  - 基于带宽和RTT
  - 不依赖丢包信号
  - Google开发，YouTube等使用

查看当前拥塞控制算法：
sysctl net.ipv4.tcp_congestion_control
# 输出：cubic (Linux默认)
```

---

## 🎓 面试回答模板

```
【基础回答】（30秒版本）

TCP有两种控制机制：

1. 流量控制
   - 目的：防止接收方缓冲区溢出
   - 机制：滑动窗口，接收方通过rwnd告知发送方
   - 关键：接收方主导

2. 拥塞控制
   - 目的：防止网络拥塞
   - 机制：四个算法
     * 慢启动：指数增长探测网络
     * 拥塞避免：线性增长稳定传输
     * 快速重传：3个重复ACK立即重传
     * 快速恢复：轻度拥塞快速恢复
   - 关键：发送方主导

实际发送窗口 = min(rwnd, cwnd)

【追问-慢启动】
初始cwnd=1 MSS，每收到一个ACK就加1。
因为一个RTT发送cwnd个包，收到cwnd个ACK，
所以每个RTT后cwnd翻倍（指数增长）。
到达ssthresh后进入拥塞避免（线性增长）。

【追问-快速重传】
收到3个重复ACK说明后续包已到达，只是个别包丢失。
立即重传丢失包，cwnd减半进入快速恢复，
不必等待超时（节省时间）。

【追问-零窗口】
接收方window=0时，发送方停止发送。
为避免窗口更新丢失导致死锁，
发送方启动持续定时器，定期发送零窗口探测包，
强制接收方回复当前窗口大小。

【追问-拥塞控制算法演进】
Tahoe → Reno → NewReno → CUBIC → BBR
现代Linux默认CUBIC，Google推广BBR。
```

---

## ⚠️ 常见误区

❌ **错误1**：认为流量控制和拥塞控制是一回事
✅ **正确**：流量控制关注接收方，拥塞控制关注网络

❌ **错误2**：认为慢启动是"慢"的
✅ **正确**：慢启动是指数增长，相对于直接发送大量数据才叫"慢"

❌ **错误3**：认为快速重传后cwnd=1
✅ **正确**：快速重传后cwnd=ssthresh（减半），快速恢复；超时重传才是cwnd=1

❌ **错误4**：认为rwnd和cwnd取大值
✅ **正确**：实际发送窗口 = min(rwnd, cwnd)，取小值

❌ **错误5**：认为收到重复ACK就重传
✅ **正确**：收到3个重复ACK才触发快速重传（避免乱序误判）

---

## 🌟 加分点

- 知道零窗口探测机制（Persist Timer）
- 了解糊涂窗口综合症（Silly Window Syndrome）
- 知道Nagle算法和TCP_NODELAY的取舍
- 说出CUBIC、BBR等现代拥塞控制算法
- 了解TCP Tahoe/Reno/NewReno的演进
- 知道AIMD原理（Additive Increase Multiplicative Decrease）
- 能画出拥塞控制状态转换图
- 了解快速恢复中的"窗口膨胀"（Inflation）

---

### TCP段(mss) 是多少，如何得来

```
MTU = 1500字节 是数据链路层对帧的最大长度限制
MSS(tcp段) = 1500字节 - 20字节(IP头) - 20(tcp头)
```

### 发送、接收方关键函数

```
// 发送方
socket() // 创建fd
bind() // 绑定IP 端口
listen() // 监听请求
accept() // 获取连接 （此时拿到的连接已完成三次握手）

// 接收方
socket() // 创建fd
connect() // 连接地址
```

### send /recv 过程

```
用户进程（User Space）
┌──────────────────────┐
│  send(buf) / recv()  │
└─────────┬────────────┘
          │  (系统调用)
          ▼
内核（Kernel Space）
┌───────────────────────────────┐
│   Socket 缓冲区                │
│  ┌───────────────┐             │
│  │发送缓冲区 sndbuf│◄─── send() │
│  └───────────────┘             │
│  ┌───────────────┐             │
│  │接收缓冲区 rcvbuf│───► recv() │
│  └───────────────┘             │
└───────────┬────────────────────┘
            │
            ▼
      TCP 协议栈（内核）
 ┌─────────────────────────┐
 │ - 分段 (MSS)            │
 │ - 拥塞窗口 (cwnd)        │
 │ - 接收窗口 (rwnd)        │◄── 从对端 ACK 包获取
 │ - 超时/快速重传          │
 │ - ACK 处理               │
 └───────────┬─────────────┘
             │
             ▼
         网络传输 (IP 层)
             │
             ▼
       对端内核 TCP 协议栈
 ┌─────────────────────────┐
 │ - 根据 rwnd 控制发送方   │
 │ - 处理 ACK / 窗口更新    │
 │ - 将数据放入 recvbuf     │
 └───────────┬─────────────┘
             │
             ▼
      对端用户进程（User Space）
      ┌───────────────────┐
      │    recv() 调用    │
      └───────────────────┘
```

### Epoll

epoll是linux内核提供的I/O多路复用方案，解决传统select/poll的性能瓶颈（低效轮询）

核心设计：

- 事件驱动，不再依赖主动查询，改为抛出事件驱动
- 红黑树（查、插都为logn） 内部红黑树管理fd，添加、删除复杂度都为O(logn)
- 就绪链表：内核维护就绪事件链表，当 fd 状态就绪时，会被加入该链表，用户态调用 `epoll_wait` 时直接从链表取结果，无需遍历全部 fd

#### ET LT区别？

- LT （Level Trigger）
  - 当fd满足就绪条件，每次epoll_wait都会返回该fd （性能相对低，一次未处理完，每次都会返回该fd）
- ET （Edge Trigger）
  - fd一次就绪仅通知一次，需要应用层去处理一次需要处理完所有就绪的数据 （性能相对较高，但需要应用层维护）

### 在 TCP 建立连接的三次握手连接阶段，如果客户端发送的第三个ACK包丢了，那么客户端和服务端分别进行什么处理呢？

#### Server 端
- 第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。
- 而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.
- 如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。

#### Client 端
- 在linux c 中，client 一般是通过 connect() 函数来连接服务器的，
  - 阻塞fd的connect等到三次握手完成后返回
  - 非阻塞fd的connect会立即返回值，在等到epoll抛出epollout事件，并且***异步connect需要getsockopt(SO_ERROR)==0***，即使连接失败，也会抛epollout

### TCP如何保证可靠传输

- 校验和
- 序列号
- 确认应答
- 超时重传
- 连接管理
- 流量控制
- 拥塞控制

### socket通信可以发1K的UDP数据包吗？TCP可以吗？

- UDP 是64K，TCP没有限制

### tcp_nodelay

tcp默认打开nagle算法，用于流量控制。对于延迟敏感的应用，打开比较好。

### TCP粘包问题、UDP会粘包嘛

- udp不会粘包

### 四次断开如果服务器没有收到客户端的确认包，会一直等待吗？等多久？

- 1RTO

### 包丢了，tcp的发送端措施，除了重传机制，还有别的吗

- 高速重传机制，当接受端收到包会返回下一个应该接受的数据包，如果发送端连续三次收到同一个数据包，就直接重传。

### DNS哪个层的协议，底层用是哪个协议

- 应用层

### tcp是如何实现keep-alive的

- 开启 so_keepalive如果两个小时没有数据传输，就发送一个保持存活探测节点给对方。返回情况有点多，，，

### TCP报文结构

![TCP报文结构](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTcwNmI4MzgxNzE0MGQ4YTY5ZGFkNTE5ZTUxN2RmZWNfOEdzMFN3U3UyaUVlWnRJM0IyeG93SnY0S0Fhd3BOMkpfVG9rZW46Ym94Y25OQXNVOW1xSU1sRVB4VmlxWm8wWlBiXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

#### 头部长度
- 20字节

### UDP结构、IP结构

![IP结构](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQwZDhhYjUyYTViMjUzZmZkYjFjMDE4YjE4OTIyNWNfSkxHZ0JtWTk0QkNVcG50c0UxUkxqSW9wUFNOR2xvUDJfVG9rZW46Ym94Y25BYUd6SXAxMDVNY1MzcTdycHNwUFBoXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

### TCP粘包和拆包

#### 原因
- 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包
- 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
- 进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包。
- 接收方法不及时读取套接字缓冲区数据，这将发生粘包。

#### 解决办法
- 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
- 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
- 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。

### TCP拥塞控制(慢启动、拥塞避免、快速重传)

- 拥塞窗口阈值x，拥塞窗口大小为s,初始值为1
- TCP建立连接时拥塞窗口大小为1，使用慢启动算法，窗口内数据都收到ACK后，拥塞窗口大小翻倍，直到s>=x，使用拥塞避免算法，拥塞窗口大小每次改变不翻倍，而是加一
- TCP对每一个报文有一个重传定时器RTO，当超时时没有收到ACK，会进行重发，并且认为网络进入了拥塞阶段，此时拥塞窗口阈值变为当前拥塞窗口的一半，即x=s/2，s=1，重新进入慢启动阶段。
- 快速重传:当发送方收到三个相同的ack时，设置阈值为拥塞窗口大小的一半，拥塞窗口大小设置为阈值，重传丢失的报文段，进入拥塞避免
- 快速恢复：发送方收到三个相同的ack时，将拥塞避免阈值和拥塞窗口设置为拥塞窗口的一般。

### tcp流量控制

- 所谓流量控制就是让发送发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制。原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。
- TCP的数据传输分为交互数据流和成块数据流，交互数据流一般是一些交互式应用程序的命令，所以这些数据很小，而考虑到TCP报头和IP报头的总和就有40字节，如果数据量很小的话，那么网络的利用效率就较低。数据传输使用Nagle算法，Nagle算法很简单，就是规定一个TCP连接最多只能有一个未被确认的未完成的小分组。在该分组的确认到达之前不能发送其他的小分组。

### TCP和UDP有什么区别？应用场景？三次握手四次断开的过程？UDP有可靠性保证吗？

- TCP是可靠连接，流传输，UDP是以数据包为单位的，不稳定
- 对稳定性要求高，如金融系统用TCP。要求传的多、快用UDP 、如视频网站
- UDP的可靠性只能在应用层实现(自己实现)

### TCP滑动窗口，是否动态可变，用来干嘛(流量控制)

- 所谓滑动窗口，可以理解成接收端所能提供的缓冲区大小。TCP利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓 冲区。由于窗口由16位bit所定义，所以接收端TCP 能最大提供65535个字节的缓冲。由此，可以利用窗口大小和第一个数据的序列号计算出最大可接收的数据序列号。

### 五层模型

### TCP在哪层，arp干什么的，在哪层，路由器在哪层，交换机哪层。

### 给出两个子网IP，是否走交换机，经过哪些。

### Ping原理，在哪一层

- 网络层，用ICMP
- ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

### 套接字有哪三种

- tcp，udp，raw

### http可以复用同一个TCP连接吗

- 可以
- TCP连接复用技术通过将前端多个客户的HTTP请求复用到后端与服务器建立的一个TCP连接上。这种技术能够大大减小服务器的性能负载，减少与服务器之间新建TCP连接所带来的延时，并最大限度的降低客户端对后端服务器的并发连接数请求，减少服务器的资源占用。

### 可以UDP实现吗

### SEQ是怎么取的；

### 描述一下TCP是怎么发送文件的

- mmap
- sendfile
- （这个问题没太听懂他想我回答什么问题，因为他说不用说bind listen accept那些，最后只答了将文件Read进内存，然后按照缓冲区当前的index分批发送）

### TCP有了checksum还可能会造成数据错乱吗（我答的有可能，确实不清楚）

### tcp/ip的5层，osi七层

### http在哪一层，tcp在哪一层，arp在哪一层

### arp协议

### UDP的特点

## HTTP/HTTPS

### HTTP的GET和POST的区别

- 作用    GET用于获取资源，POST用于传输实体主体
- 参数位置   GET的参数放在URL中，POST的参数存储在实体主体中，并且GET方法提交的请求的URL中的数据做多是2048字节，POST请求没有大小限制。
- 安全性    GET方法因为参数放在URL中，安全性相对于POST较差一些
- 幂等性    GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求，收到的结果都是一样的.

### HTTPS的SSL握手流程

1. 客户端向服务端发起第一次握手请求，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。
2. 服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。
3. 服务端将证书发给客服端。
4. 客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。
5. 客服端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。
6. 服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。
7. 通信双方可用对称密钥来加密解密信息。

### 简单描述SSL的会话过程

1. SSL会话主要分为三步：
2. 1.客户端向服务器端索要并验证证书；
3. 2.双方协商生成"会话密钥"；对成密钥
4. 3.双方采用"会话密钥"进行加密通信；

### HTTPs 和 HTTP 的区别

### HTTPS 的原理，客户端为什么信任第三方证书

### HTTP 方法了解哪些

### HTTP 异常状态码知道哪些

### HTTP 长连接短连接使用场景是什么

### 在浏览器输入www.qq.com，会打开腾讯的首页，在这个操作中用了什么协议呢？经过了哪些步骤呢？

- 向DNS服务器请求ip
- 跟对应ip进行TCP连接
- 发送http请求，服务器返回静态网页文件
- 浏览器渲染
- 应用层:HTTP\DNS\HTTPS
- 传输层:TCP
- 网络层:IP、ARP

## 网络诊断

### 如何诊断网络问题？

从 客户端 → 网络链路 → 服务器 → 进程内部  四个步骤排查

- 客户端： 检查4G网络/WIFI或者有无代理
- 网络链：通过wireshark、tcpdump抓包，检查三次握手状态，netstat -ano检查端口状态
- 服务器：检查ehth0网卡的收发包情况，再观察grafana+prometheus分工具观察rtt和网络情况
- 进程内部：检查协议解码有无问题（粘包解包）再检查有无逻辑层卡帧问题导致误判为网络问题

### TIME_WAIT是什么？

- close发起一端收到SYN后进入的状态，等待2MSL后关闭连接

### 讲下TCP断开链接的过程？然后我讲了四次握手，后续追问TCP四次握手在哪一步骤真正断开了链接呢？

- time_wait状态结束

### TIME_CLOSE 和 TIME_WAIT 的状态和意义

### CLOSE_WAIT等待时间的意义

### TIME_WAIT的时间可以修改吗

- 可以的，setsocket

### TIME_WAIT太多怎么办，为什么

- 在**高并发短连接**的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。
- 原因：对于一个处理大量短连接的服务器，如果是由服务器主动关闭客户端的连接，将导致服务器存在大量的处于TIME_WAIT状态的socket，严重影响服务器的处理能力，甚至耗尽可用的socket
- 解决办法：修改参数TcpTimedWaitDelay，缩短 TIME_WAIT 的等待时间。

### TIME_WAIT存在的意义是什么

- 保证对端收到最后一个ACK（否则对端可能会重发FIN）
- 保证延迟数据段过期（否则新连接可能会收到旧连接的包）

https://draveness.me/whys-the-design-tcp-time-wait/

### 设置SO_REUSEADDR之后如果收到上一个连接的数据包怎么办？

### tpc最多超级重传多少次

- Linux有两个参数限制超时重传次数tcp_retries1 ，tcp_retries2
- 如果超时发生在三次握手期间，此时有专门的tcp_syn_retries来负责限定重传次数
- 一旦重传超过阈值tcp_retries1，主要的动作就是更新路由缓存
- 重传超过tcp_retries2会直接放弃重传，关闭TCP流

### 三次握手。超时会怎么样

- 一次握手A发送SYN传输失败，A,B都不会申请资源，连接失败。如果一段时间内发出多个SYN连接请求，那么A只会接受它最后发送的那个SYN的SYN+ACK回应，忽略其他回应全部回应，B中多申请的资源也会释放
- 第二次握手B发送SYN+ACK传输失败，A不会申请资源，B申请了资源，但收不到A的ACK，过一段时间释放资源。如果是收到了多个A的SYN请求，B都会回复SYN+ACK，但A只会承认其中它最早发送的那个SYN的回应，并回复最后一次握手的ACK
- 第三次握手ACK传输失败，B没有收到ACK，释放资源，对于后序的A的传输数据返回RST。实际上B会因为没有收到A的ACK会多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到A的ACK，则释放资源，对A的数据传输返回RST复最后一次握手的ACK

### 网络问题汇总

- https://blog.csdn.net/paranior/article/details/115209752

## 网络安全

### Arp 攻击

### NAT 原理

### DNS 服务器与提供内容的服务器的区别

### 怎么实现 DNS 劫持

### 对称加密和非对称的区别，非对称加密有哪些

### AES 的过程

### 安全攻击有哪些

### DDOS 有哪些，如何防范

### SYN FLOOD 是什么

- Syn-Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问

### SSL和TLS

- 对称加密算法
  - DES(56bit)
  - triple-DES（最长168bit的密钥）
  - AES（最高256bit的密钥）
- 非对称加密
  - RSA
- 非对称加密的安全隐患
  - public key（网络传递）被拦截篡改
- CA
  - 加密pubilc key，传递的是CA加密之后的数字证书
  - CA把自己的CA证书集成在了浏览器和操作系统里面。A拿到浏览器或者操作系统的时候，已经有了CA证书，没有必要通过网络获取，那自然也不存在劫持的问题（不在CA体系里面，没有CA的private key）
  - CA证书被篡改了（可以继续攻击）

### TCP场景下，如果传送多个小包，如何实现更优的传递

https://www.cnblogs.com/williamjie/p/9390308.html

### https原理

- tcp建立连接后SSL或者TLS验证身份再发送http请求
