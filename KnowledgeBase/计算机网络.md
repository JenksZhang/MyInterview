# 计算机网络

## TCP/UDP

### TCP三次握手，两次行不行

- 不可以，Client第一次发的SYN在网络中滞留，超时重发了第二次SYN，第二次的可能先到达并完成握手，后第一次又到达，服务器继续分配内存，回SYN+ACK，但是再Client无效，浪费了Server资源

![三次握手图示](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=ODEyMGI4N2Q2MjQzODk3Mzg4NmEwNGIxY2RhNmRhMjlfSHpvUUN1aTVvOHNIZ0Q0TlFyV3A5dGhZUHZ6cnUyQmlfVG9rZW46QmhIZGJnQm1Sb3llZkV4dXB0UGNJdXFGbkNxXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

### TCP四次握手，time_wait状态出现原因

1. 确保被动关闭方收到最后一个 ACK（若 ACK 丢失，被动方会重发 FIN，主动方可在此时重传）；
2. 等待 2MSL（报文最大生存时间），让连接中残留的旧报文过期，避免干扰新连接。

![四次挥手图示](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=YmU4NTg5ZGZhYjgyMmI2OGI1ZDJjYWMyNmNiZTAzMWJfTlZvTHoyem4zNkpmTGt6TG4wRFRwaEs1eHptaGhxQzZfVG9rZW46U1lHYWIzVlRxb09BZkR4WVFZemNWUXhubnFmXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

### TCP中拥塞控制vs流量控制

#### 流量控制

面向端到端，主要用来形容对方的接受能力，在报文中通过rwnd（接收窗口），在接收方收到请求方的写请求后，响应ACK的时候带上当前写缓冲区的剩余大小

#### 拥塞控制

面向发送方与网络链路，在报文中cwnd（拥塞窗口体现），单位一般为mss，另有阈值X

- **慢启动**：启动时，会设置初始窗口为1mss，每次收到ACK后翻倍，即2mss 4mss 直到阈值

- **拥塞避免**：到达阈值X后，变为线性增长，5mss 6mss。。。。。

- **快重传**：如连续三次收到同样的ACK，则快速重传一次，并设置阈值为当前窗口的一半，并将当前窗口设置为当前阈值

- **超时重传**：如果在超时时间内未收到ACK，则认为网络当前较为拥挤，调整阈值为当前cwnd的一半，并且将cwnd从1开始慢启动

### TCP段(mss) 是多少，如何得来

```
MTU = 1500字节 是数据链路层对帧的最大长度限制
MSS(tcp段) = 1500字节 - 20字节(IP头) - 20(tcp头)
```

### 发送、接收方关键函数

```
// 发送方
socket() // 创建fd
bind() // 绑定IP 端口
listen() // 监听请求
accept() // 获取连接 （此时拿到的连接已完成三次握手）

// 接收方
socket() // 创建fd
connect() // 连接地址
```

### send /recv 过程

```
用户进程（User Space）
┌──────────────────────┐
│  send(buf) / recv()  │
└─────────┬────────────┘
          │  (系统调用)
          ▼
内核（Kernel Space）
┌───────────────────────────────┐
│   Socket 缓冲区                │
│  ┌───────────────┐             │
│  │发送缓冲区 sndbuf│◄─── send() │
│  └───────────────┘             │
│  ┌───────────────┐             │
│  │接收缓冲区 rcvbuf│───► recv() │
│  └───────────────┘             │
└───────────┬────────────────────┘
            │
            ▼
      TCP 协议栈（内核）
 ┌─────────────────────────┐
 │ - 分段 (MSS)            │
 │ - 拥塞窗口 (cwnd)        │
 │ - 接收窗口 (rwnd)        │◄── 从对端 ACK 包获取
 │ - 超时/快速重传          │
 │ - ACK 处理               │
 └───────────┬─────────────┘
             │
             ▼
         网络传输 (IP 层)
             │
             ▼
       对端内核 TCP 协议栈
 ┌─────────────────────────┐
 │ - 根据 rwnd 控制发送方   │
 │ - 处理 ACK / 窗口更新    │
 │ - 将数据放入 recvbuf     │
 └───────────┬─────────────┘
             │
             ▼
      对端用户进程（User Space）
      ┌───────────────────┐
      │    recv() 调用    │
      └───────────────────┘
```

### Epoll

epoll是linux内核提供的I/O多路复用方案，解决传统select/poll的性能瓶颈（低效轮询）

核心设计：

- 事件驱动，不再依赖主动查询，改为抛出事件驱动
- 红黑树（查、插都为logn） 内部红黑树管理fd，添加、删除复杂度都为O(logn)
- 就绪链表：内核维护就绪事件链表，当 fd 状态就绪时，会被加入该链表，用户态调用 `epoll_wait` 时直接从链表取结果，无需遍历全部 fd

#### ET LT区别？

- LT （Level Trigger）
  - 当fd满足就绪条件，每次epoll_wait都会返回该fd （性能相对低，一次未处理完，每次都会返回该fd）
- ET （Edge Trigger）
  - fd一次就绪仅通知一次，需要应用层去处理一次需要处理完所有就绪的数据 （性能相对较高，但需要应用层维护）

### 在 TCP 建立连接的三次握手连接阶段，如果客户端发送的第三个ACK包丢了，那么客户端和服务端分别进行什么处理呢？

#### Server 端
- 第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。
- 而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.
- 如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。

#### Client 端
- 在linux c 中，client 一般是通过 connect() 函数来连接服务器的，
  - 阻塞fd的connect等到三次握手完成后返回
  - 非阻塞fd的connect会立即返回值，在等到epoll抛出epollout事件，并且***异步connect需要getsockopt(SO_ERROR)==0***，即使连接失败，也会抛epollout

### TCP如何保证可靠传输

- 校验和
- 序列号
- 确认应答
- 超时重传
- 连接管理
- 流量控制
- 拥塞控制

### socket通信可以发1K的UDP数据包吗？TCP可以吗？

- UDP 是64K，TCP没有限制

### tcp_nodelay

tcp默认打开nagle算法，用于流量控制。对于延迟敏感的应用，打开比较好。

### TCP粘包问题、UDP会粘包嘛

- udp不会粘包

### 四次断开如果服务器没有收到客户端的确认包，会一直等待吗？等多久？

- 1RTO

### 包丢了，tcp的发送端措施，除了重传机制，还有别的吗

- 高速重传机制，当接受端收到包会返回下一个应该接受的数据包，如果发送端连续三次收到同一个数据包，就直接重传。

### DNS哪个层的协议，底层用是哪个协议

- 应用层

### tcp是如何实现keep-alive的

- 开启 so_keepalive如果两个小时没有数据传输，就发送一个保持存活探测节点给对方。返回情况有点多，，，

### TCP报文结构

![TCP报文结构](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTcwNmI4MzgxNzE0MGQ4YTY5ZGFkNTE5ZTUxN2RmZWNfOEdzMFN3U3UyaUVlWnRJM0IyeG93SnY0S0Fhd3BOMkpfVG9rZW46Ym94Y25OQXNVOW1xSU1sRVB4VmlxWm8wWlBiXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

#### 头部长度
- 20字节

### UDP结构、IP结构

![IP结构](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQwZDhhYjUyYTViMjUzZmZkYjFjMDE4YjE4OTIyNWNfSkxHZ0JtWTk0QkNVcG50c0UxUkxqSW9wUFNOR2xvUDJfVG9rZW46Ym94Y25BYUd6SXAxMDVNY1MzcTdycHNwUFBoXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

### TCP粘包和拆包

#### 原因
- 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包
- 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
- 进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包。
- 接收方法不及时读取套接字缓冲区数据，这将发生粘包。

#### 解决办法
- 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
- 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
- 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。

### TCP拥塞控制(慢启动、拥塞避免、快速重传)

- 拥塞窗口阈值x，拥塞窗口大小为s,初始值为1
- TCP建立连接时拥塞窗口大小为1，使用慢启动算法，窗口内数据都收到ACK后，拥塞窗口大小翻倍，直到s>=x，使用拥塞避免算法，拥塞窗口大小每次改变不翻倍，而是加一
- TCP对每一个报文有一个重传定时器RTO，当超时时没有收到ACK，会进行重发，并且认为网络进入了拥塞阶段，此时拥塞窗口阈值变为当前拥塞窗口的一半，即x=s/2，s=1，重新进入慢启动阶段。
- 快速重传:当发送方收到三个相同的ack时，设置阈值为拥塞窗口大小的一半，拥塞窗口大小设置为阈值，重传丢失的报文段，进入拥塞避免
- 快速恢复：发送方收到三个相同的ack时，将拥塞避免阈值和拥塞窗口设置为拥塞窗口的一般。

### tcp流量控制

- 所谓流量控制就是让发送发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制。原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。
- TCP的数据传输分为交互数据流和成块数据流，交互数据流一般是一些交互式应用程序的命令，所以这些数据很小，而考虑到TCP报头和IP报头的总和就有40字节，如果数据量很小的话，那么网络的利用效率就较低。数据传输使用Nagle算法，Nagle算法很简单，就是规定一个TCP连接最多只能有一个未被确认的未完成的小分组。在该分组的确认到达之前不能发送其他的小分组。

### TCP和UDP有什么区别？应用场景？三次握手四次断开的过程？UDP有可靠性保证吗？

- TCP是可靠连接，流传输，UDP是以数据包为单位的，不稳定
- 对稳定性要求高，如金融系统用TCP。要求传的多、快用UDP 、如视频网站
- UDP的可靠性只能在应用层实现(自己实现)

### TCP滑动窗口，是否动态可变，用来干嘛(流量控制)

- 所谓滑动窗口，可以理解成接收端所能提供的缓冲区大小。TCP利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓 冲区。由于窗口由16位bit所定义，所以接收端TCP 能最大提供65535个字节的缓冲。由此，可以利用窗口大小和第一个数据的序列号计算出最大可接收的数据序列号。

### 五层模型

### TCP在哪层，arp干什么的，在哪层，路由器在哪层，交换机哪层。

### 给出两个子网IP，是否走交换机，经过哪些。

### Ping原理，在哪一层

- 网络层，用ICMP
- ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

### 套接字有哪三种

- tcp，udp，raw

### http可以复用同一个TCP连接吗

- 可以
- TCP连接复用技术通过将前端多个客户的HTTP请求复用到后端与服务器建立的一个TCP连接上。这种技术能够大大减小服务器的性能负载，减少与服务器之间新建TCP连接所带来的延时，并最大限度的降低客户端对后端服务器的并发连接数请求，减少服务器的资源占用。

### 可以UDP实现吗

### SEQ是怎么取的；

### 描述一下TCP是怎么发送文件的

- mmap
- sendfile
- （这个问题没太听懂他想我回答什么问题，因为他说不用说bind listen accept那些，最后只答了将文件Read进内存，然后按照缓冲区当前的index分批发送）

### TCP有了checksum还可能会造成数据错乱吗（我答的有可能，确实不清楚）

### tcp/ip的5层，osi七层

### http在哪一层，tcp在哪一层，arp在哪一层

### arp协议

### UDP的特点

## HTTP/HTTPS

### HTTP的GET和POST的区别

- 作用    GET用于获取资源，POST用于传输实体主体
- 参数位置   GET的参数放在URL中，POST的参数存储在实体主体中，并且GET方法提交的请求的URL中的数据做多是2048字节，POST请求没有大小限制。
- 安全性    GET方法因为参数放在URL中，安全性相对于POST较差一些
- 幂等性    GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求，收到的结果都是一样的.

### HTTPS的SSL握手流程

1. 客户端向服务端发起第一次握手请求，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。
2. 服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。
3. 服务端将证书发给客服端。
4. 客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。
5. 客服端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。
6. 服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。
7. 通信双方可用对称密钥来加密解密信息。

### 简单描述SSL的会话过程

1. SSL会话主要分为三步：
2. 1.客户端向服务器端索要并验证证书；
3. 2.双方协商生成"会话密钥"；对成密钥
4. 3.双方采用"会话密钥"进行加密通信；

### HTTPs 和 HTTP 的区别

### HTTPS 的原理，客户端为什么信任第三方证书

### HTTP 方法了解哪些

### HTTP 异常状态码知道哪些

### HTTP 长连接短连接使用场景是什么

### 在浏览器输入www.qq.com，会打开腾讯的首页，在这个操作中用了什么协议呢？经过了哪些步骤呢？

- 向DNS服务器请求ip
- 跟对应ip进行TCP连接
- 发送http请求，服务器返回静态网页文件
- 浏览器渲染
- 应用层:HTTP\DNS\HTTPS
- 传输层:TCP
- 网络层:IP、ARP

## 网络诊断

### 如何诊断网络问题？

从 客户端 → 网络链路 → 服务器 → 进程内部  四个步骤排查

- 客户端： 检查4G网络/WIFI或者有无代理
- 网络链：通过wireshark、tcpdump抓包，检查三次握手状态，netstat -ano检查端口状态
- 服务器：检查ehth0网卡的收发包情况，再观察grafana+prometheus分工具观察rtt和网络情况
- 进程内部：检查协议解码有无问题（粘包解包）再检查有无逻辑层卡帧问题导致误判为网络问题

### TIME_WAIT是什么？

- close发起一端收到SYN后进入的状态，等待2MSL后关闭连接

### 讲下TCP断开链接的过程？然后我讲了四次握手，后续追问TCP四次握手在哪一步骤真正断开了链接呢？

- time_wait状态结束

### TIME_CLOSE 和 TIME_WAIT 的状态和意义

### CLOSE_WAIT等待时间的意义

### TIME_WAIT的时间可以修改吗

- 可以的，setsocket

### TIME_WAIT太多怎么办，为什么

- 在**高并发短连接**的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。
- 原因：对于一个处理大量短连接的服务器，如果是由服务器主动关闭客户端的连接，将导致服务器存在大量的处于TIME_WAIT状态的socket，严重影响服务器的处理能力，甚至耗尽可用的socket
- 解决办法：修改参数TcpTimedWaitDelay，缩短 TIME_WAIT 的等待时间。

### TIME_WAIT存在的意义是什么

- 保证对端收到最后一个ACK（否则对端可能会重发FIN）
- 保证延迟数据段过期（否则新连接可能会收到旧连接的包）

https://draveness.me/whys-the-design-tcp-time-wait/

### 设置SO_REUSEADDR之后如果收到上一个连接的数据包怎么办？

### tpc最多超级重传多少次

- Linux有两个参数限制超时重传次数tcp_retries1 ，tcp_retries2
- 如果超时发生在三次握手期间，此时有专门的tcp_syn_retries来负责限定重传次数
- 一旦重传超过阈值tcp_retries1，主要的动作就是更新路由缓存
- 重传超过tcp_retries2会直接放弃重传，关闭TCP流

### 三次握手。超时会怎么样

- 一次握手A发送SYN传输失败，A,B都不会申请资源，连接失败。如果一段时间内发出多个SYN连接请求，那么A只会接受它最后发送的那个SYN的SYN+ACK回应，忽略其他回应全部回应，B中多申请的资源也会释放
- 第二次握手B发送SYN+ACK传输失败，A不会申请资源，B申请了资源，但收不到A的ACK，过一段时间释放资源。如果是收到了多个A的SYN请求，B都会回复SYN+ACK，但A只会承认其中它最早发送的那个SYN的回应，并回复最后一次握手的ACK
- 第三次握手ACK传输失败，B没有收到ACK，释放资源，对于后序的A的传输数据返回RST。实际上B会因为没有收到A的ACK会多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到A的ACK，则释放资源，对A的数据传输返回RST复最后一次握手的ACK

### 网络问题汇总

- https://blog.csdn.net/paranior/article/details/115209752

## 网络安全

### Arp 攻击

### NAT 原理

### DNS 服务器与提供内容的服务器的区别

### 怎么实现 DNS 劫持

### 对称加密和非对称的区别，非对称加密有哪些

### AES 的过程

### 安全攻击有哪些

### DDOS 有哪些，如何防范

### SYN FLOOD 是什么

- Syn-Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问

### SSL和TLS

- 对称加密算法
  - DES(56bit)
  - triple-DES（最长168bit的密钥）
  - AES（最高256bit的密钥）
- 非对称加密
  - RSA
- 非对称加密的安全隐患
  - public key（网络传递）被拦截篡改
- CA
  - 加密pubilc key，传递的是CA加密之后的数字证书
  - CA把自己的CA证书集成在了浏览器和操作系统里面。A拿到浏览器或者操作系统的时候，已经有了CA证书，没有必要通过网络获取，那自然也不存在劫持的问题（不在CA体系里面，没有CA的private key）
  - CA证书被篡改了（可以继续攻击）

### TCP场景下，如果传送多个小包，如何实现更优的传递

https://www.cnblogs.com/williamjie/p/9390308.html

### https原理

- tcp建立连接后SSL或者TLS验证身份再发送http请求
