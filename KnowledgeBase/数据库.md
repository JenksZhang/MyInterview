# 数据库

## MySQL

### 数据库为什么使用B树作为存储数据的数据结构？

- 分叉多，树比较低
- https://zhuanlan.zhihu.com/p/27700617

### mysql常见的存储引擎，innoDB和Myisam区别

- innoDB支持事务、外键、行锁

### mysql中事务的原理，在哪一层实现，存储引擎怎么实现这一步

- ACID
- binlog，redolog
- 隔离级别

### 事务 及 ACID

- commit / rollback
- 提交: 当一个事务完成之后,发出commit命令,来让所有参与表的更改生效.
- 回滚: 当事务 发生故障,应该发出 rollback命令 来让事务引用的每一个表都回到事务开始以前的状态.
- 原子性 、一致性、隔离性、永久性

### binlog 日志和 redolog 日志清楚吗？ 说了两个日志的作用以及两阶段提交

- redolog是innodb引擎级别的，mysql服务重启时恢复数据用
- binlog是mysql server级别的，做数据恢复

### redo log、binlog、undo log 区别与作用

#### redo log(重做日志)：
- redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。

#### binlog（二进制日志）
- binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠binlog是没有`crash-safe`能力的

#### redo log和binlog区别
- redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。
- redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑
- redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。
- binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。

#### 回滚日志（undo log）
- 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读

### MVCC

- InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id，这是事务在启动的时候向系统申请的，是按照申请顺序递增的；
- 而每行存储的数据也是有多个版本的，每次更新数据的时候都会生成一个新的数据版本，并且把当前事务的transaction id赋值给数据版本，计做row_trx_id，在同一行数据中会保存多个版本的数据（如下图），每个版本都有自己的row_trx_id，然后在新的数据版本中可以通过指针拿到旧的数据版本；

1. DB_ROW_ID：行id，如果有主键就没有这一列；
2. DB_TRX_ID：记录插入或者更新该行数据的事务ID
3. DB_ROLL_PTR：回滚指针，指向undo log记录；通过回滚指针连接同一条数据的多个版本，形成一个版本链；

### SQL语句在MySQL中的解析过程

客户端----连接器----分析器----优化器----执行器----存储引擎----数据

### MySQL中的行锁什么时候转变为表锁？行锁有哪些？

- 使用索引采用行锁，否则采用表锁；
- 排他锁for update和共享锁lock in share mode

### 乐观锁与悲观锁的区别？

- 悲观：事务开始时锁
- 乐观：事务提交时锁

### binlog 日志是 master 推的还是 slave 来拉的？

- slave拉的

### mysql 主从同步怎么搞的？分哪几个过程？如果有一台新机器要加到从机里，怎么个过程。

### mysql 主从同步是怎样的过程？

- 总的来说主从复制功能的详细步骤可以分为7个步骤：
- 设置主节点的地址和端口
- 建立套接字连接
- 发送PING命令
- 权限验证
- 同步 （从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步）
- 命令传播（主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。）

### MyISAM和InnoDB的区别

## 索引

### mysql 索引在什么情况下会失效

- like前置匹配
- or两边不全是索引
- 数据类型不对

### mysql 的索引模型

### 设计过联合索引吗

![联合索引](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=MzUxODgxZTE5ZDM3OWEzOTNiNmY4ZmY1YWYzZTAwMDhfT3BHOGt6TXVGdTRkYVU2aGxzdE1sYnFhM3ByY3ZKNDBfVG9rZW46Ym94Y25uNk5NSnFrTFMyQ1RkUWRpT3VrMURjXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

我们对(a,b)字段建立一个索引，也就是说，你where后条件为

```SQL
a = 1
a = 1 and b = 2
```

是可以匹配索引的。但是要注意的是~你执行

```SQL
b= 2 and a =1
```

也是能匹配到索引的，因为Mysql有优化器会自动调整a,b的顺序与索引顺序一致。 相反的，你执行

```SQL
b = 2
```

就匹配不到索引了。 而你对(a,b,c,d)建立索引,where后条件为

```SQL
a = 1 and b = 2 and c > 3 and d = 4
```

那么，a,b,c三个字段能用到索引，而d就匹配不到。因为遇到了范围查询！

https://zhuanlan.zhihu.com/p/115778804

### 联合索引的匹配规则

- **最左匹配**

### 聚簇索引和非聚簇索引的区别，具体体现在哪

- https://www.cnblogs.com/jiawen010/p/11805241.html
- **主键的索引 B+树叶子节点存放的是用户数据**
- **其他索引 B+树叶子节点存放的是主键的值，然后再去主键的索引里面去找到用户数据（回表），好处：节约空间**

### B+树的时间复杂度（不太清楚）

### B树和B+树总结

- B+树相对于B树有一些自己的优势，可以归结为下面几点。
- 1.单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。
- 2.**所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。**
- 3.所有的叶子节点形成了一个**有序链表**，更加便于查找。

### B+树为什么一般是三层吗（支支吾吾）

- https://zhuanlan.zhihu.com/p/86137284

### 什么情况适合建立索引？

- 经常查询的列，主键列，排序列(order by)

### 如何通过索引避免出现重复ID？

- 建立唯一索引

### 数据库中已经有重复ID数据，如何去重？

```SQL
Delete from table
    where x1 not in(
        select temp.x2 from (
            select MIN(id) x2 from table
                group by col1,col2
        )as temp
    )
```

### 对于SQL了解吗？索引有什么用？为什么要加入索引？

- 提高检索速度，减少检索的行数

### B 和 B+ 区别

- B树的每个节点存储了key和data，key是一条数据记录的键值，是唯一的，data存储的是数据记录除key以外的数据。而B+树只在叶子节点存储data数据，这样非叶子节点就能存储更多的key。所以B+树相较于B树来说更加的矮胖，因为索引树很大不能一次IO读取进内存，树的深度越浅，查找数据时IO的次数就越少，效率就更快。

1. B+树的每个叶子节点的指针指向相邻的叶子节点，构成一个有序链表，可以按照关键码排序的次序遍历全部记录。由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树叶子节点指针为null，则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

### 为什么用B+树做索引，不用hash呢

- 哈希表是把索引字段映射成对应的哈希码然后再存放在对应的位置，这样的话，如果我们要进行模糊查找的话，显然哈希表这种结构是不支持的，只能遍历这个表。而B+树则可以通过最左前缀原则快速找到对应的数据。
- 如果我们要进行范围查找，例如查找ID为100 ~ 400的人，哈希表同样不支持，只能遍历全表。
- 索引字段通过哈希映射成哈希码，如果很多字段都刚好映射到相同值的哈希码的话，那么形成的索引结构将会是一条很长的链表，这样的话，查找的时间就会大大增加。

### 主键索引和非主键索引的区别

- https://www.cnblogs.com/jiawen010/p/11805241.html

- 非主键索引的叶子节点存放的是

  主键的值

  ，而主键索引的叶子节点存放的是

  整行数据

  ，其中非主键索引也被称为

  二级索引

  ，而主键索引也被称为

  聚簇索引

  。

  - 如果查询语句是 select * from table where ID = 100,即**主键查询的方式**，则只需要搜索 ID 这棵 B+树。
  - 如果查询语句是 select * from table where k = 1，即**非主键的查询方式**，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，这个过程也被称为**回表**。

### 覆盖索引

- 解释一： 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。
- 解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。
- 解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。

- 覆盖索引必须要存储索引的列，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引

### mysql 索引

- 普通索引index :加速查找
- 唯一索引
  - 主键索引：primary key ：加速查找+约束（不为空且唯一）
  - 唯一索引：unique：加速查找+约束 （唯一）
- 联合索引
  - primary key(id,name):联合主键索引
  - unique(id,name):联合唯一索引
  - index(id,name):联合普通索引
- 全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。
- 空间索引spatial :了解就好，几乎不用

### 数据库索引为什么用自增id，有什么好处

- 当我们使用主键递增ID的时候，所有新增的主键都为当前主键的最大值，所以只需要在索引树的最右边加上一个记录即可

## Redis

### redis怎么保证高可用

- 哨兵机制保证高可用，检测master是否挂了，挂了就选举一个slave作为master
- 主从切换保证读高并发，master写，slave读

### Redis用过吗**，**讲讲用过哪些类型

### zset 延时队列怎么实现的

1.    1） 将**消息**序列化成**字符串**作为 zset 的 **value**，**到期**处理**时间**为 **score**
2. ​    2）多个线程轮询zset 获取到期任务进行处理 。多线程**保障可用性,并发争抢,不会被多次执行**

### redis 数据结构有哪些？分别怎么实现的？

- hash hashmap
- list 链表
- set hashtable
- sort set skiptable

### redis过期策略

- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个keyo
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

### redis 持久化有哪几种方式，怎么选？

- AOF,RDB

### Redis的数据结构

#### String类型
#### Mapmap
#### List（双端的）
#### Set
#### Zset
- ziplist
  - ziplist 是一个紧挨着的存储空间，并且是没有预留空间的，随意对于ziplist优势在于节省空间，但是在容量大到一定程度扩容就是影响他的性能的主要原因之一（会在下面两种情况下转为skipList）
    - ziplist所保存的元素超过服务器属性server.zset_max_ziplist_entries 的值（默认值为 128 ）
    - 新添加元素的 member 的长度大于服务器属性 server.zset_max_ziplist_value 的值（默认值为 64）
- skipList
  - Redis 的跳跃表共有 64 层，意味着最多可以容纳 2^64 次方个元素。每一个 kv 块对应的结构如下面的代码中的 zslnode 结构，kvheader 也是这个结构
  - 链表和二分查找
  - 插入
    - 随机计算层数的zslRandomLevel() :注意p值由`ZSKIPLIST_P`常量定义，值为0.25，即被插入到高层的概率为1/4。

```C++
int zslRandomLevel(void) { int level = 1; while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF)) level += 1; return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL; }
```

### Redis持久化

- RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。
  - save、bgsave、自动化
- 全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。

### AOF 重写

(1) 随着AOF文件越来越大，里面会有大部分是重复命令或者可以合并的命令（100次incr = set key 100）

(2) 重写的好处：减少AOF日志尺寸，减少内存占用，加快数据库恢复时间。

- AOF重写功能：Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个文件所保存的数据库状态是相同的，但是新的AOF文件不会包含任何浪费空间的冗余命令，通常体积会较旧AOF文件小很多。

### 渐进式Rehash

- 因为在进行渐进式 rehash 的过程中， 字典会同时使用 `ht[0]` 和 `ht[1]` 两个哈希表， 所以在渐进式 rehash 进行期间，     字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 `ht[0]` 里面进行查找， 如果没找到的话， 就会继续到 `ht[1]` 里面进行查找， 诸如此类。
- 另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 `ht[1]` 里面， 而 `ht[0]` 则不再进行任何添加操作： 这一措施保证了 `ht[0]` 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表

### 一致性 Hash

- 一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，有很好的容错性和可扩展性。
- 一致性Hash算法引入了`虚拟节点机制`，即对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。数据定位算法不变，只需要增加一步：虚拟节点到实际点的映射。

![一致性哈希](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=MmQ3MDdiN2RiMWQ0NzA5YWNjMjNkZTk0YzhlYTFhYmJfSkVFaTJGUGRWNWpDbm5BdUVGa1NUM25hQUx2SVJuMGFfVG9rZW46Ym94Y25lSHhqa21yNldZRXZtelZUNzlJbUNoXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

- 根据一致性哈希算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。
- 下面分析一致性哈希算法的容错性和可扩展性。现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。
- **综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。**

### Redis 集群哈希槽

### Redis 集群高可用

- 主从同步
  - 主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。

### Redis KEY 过期策略

- **惰性删除**：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key（无法保证冷数据被及时删掉）
- **定期删除**：Redis会定期主动淘汰一批已过期的key（随机抽取一批key检查）
- **内存淘汰机制**：当前已用内存超过maxmemory限定时，触发主动清理策略

### redis扩容和收缩

### 如何用redis实现分布式锁

- SETNX，命令
- 互斥性：任意时刻只能有一个客户端拥有锁，不能同时多个客户端获取
- 安全性：锁只能被持有该锁的用户删除，而不能被其他用户删除
- 死锁：获取锁的客户端因为某些原因而宕机，而未能释放锁，其他客户端无法获取此锁，需要有机制来避免该类问题的发生
- 容错：当部分节点宕机，客户端仍能获取锁或者释放锁

### redis底层结构

## 数据库设计

### 为什么数据库要有外键

- 约束
- 解除冗余

### 数据库注入的过程，如何防范
