# æ•°æ®ç»“æ„é¢è¯•çŸ¥è¯†ç‚¹

## ç›®å½•
- [æ•°ç»„ä¸å­—ç¬¦ä¸²](#æ•°ç»„ä¸å­—ç¬¦ä¸²)
- [é“¾è¡¨](#é“¾è¡¨)
- [æ ˆä¸é˜Ÿåˆ—](#æ ˆä¸é˜Ÿåˆ—)
- [å“ˆå¸Œè¡¨](#å“ˆå¸Œè¡¨)
- [æ ‘ç»“æ„](#æ ‘ç»“æ„)
- [å †](#å †)
- [å›¾](#å›¾)
- [STLå®¹å™¨åº•å±‚å®ç°](#stlå®¹å™¨åº•å±‚å®ç°)
- [Redisæ•°æ®ç»“æ„](#redisæ•°æ®ç»“æ„)

---

## ğŸ“Œ æ•°ç»„ä¸å­—ç¬¦ä¸²ï¼ˆâ­â­â­â­â­ åŸºç¡€ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **è¿ç»­å†…å­˜** | **éšæœºè®¿é—®O(1)** | **æ’å…¥åˆ é™¤O(n)** | **ç¼“å­˜å‹å¥½** | **åŠ¨æ€æ•°ç»„æ‰©å®¹** | **åŒæŒ‡é’ˆ** | **æ»‘åŠ¨çª—å£**

### âœ… æ•°ç»„ç‰¹æ€§

**ä¼˜ç‚¹ï¼š**
- **éšæœºè®¿é—®**ï¼šé€šè¿‡ä¸‹æ ‡O(1)æ—¶é—´è®¿é—®å…ƒç´ 
- **ç¼“å­˜å‹å¥½**ï¼šè¿ç»­å†…å­˜ï¼Œå±€éƒ¨æ€§å¥½
- **ç©ºé—´æ•ˆç‡é«˜**ï¼šæ— é¢å¤–æŒ‡é’ˆå¼€é”€

**ç¼ºç‚¹ï¼š**
- **æ’å…¥/åˆ é™¤æ…¢**ï¼šéœ€è¦ç§»åŠ¨å…ƒç´ ï¼ŒO(n)
- **å›ºå®šå¤§å°**ï¼šé™æ€æ•°ç»„ä¸èƒ½åŠ¨æ€æ‰©å®¹
- **å†…å­˜æµªè´¹**ï¼šåŠ¨æ€æ•°ç»„å¯èƒ½é¢„ç•™è¿‡å¤šç©ºé—´

### ğŸ’» åŠ¨æ€æ•°ç»„å®ç°ï¼ˆvectoråŸç†ï¼‰

```cpp
template<typename T>
class MyVector {
private:
    T* data;           // æ•°æ®æŒ‡é’ˆ
    size_t capacity;   // å®¹é‡
    size_t size;       // å®é™…å…ƒç´ æ•°é‡

public:
    MyVector() : data(nullptr), capacity(0), size(0) {}

    // ğŸ”‘ å…³é”®ï¼šæ‰©å®¹ç­–ç•¥ï¼ˆ1.5å€æˆ–2å€ï¼‰
    void reserve(size_t newCapacity) {
        if (newCapacity <= capacity) return;

        T* newData = new T[newCapacity];
        for (size_t i = 0; i < size; i++) {
            newData[i] = data[i];
        }
        delete[] data;
        data = newData;
        capacity = newCapacity;
    }

    void push_back(const T& value) {
        if (size == capacity) {
            // ğŸ”‘ 2å€æ‰©å®¹
            reserve(capacity == 0 ? 1 : capacity * 2);
        }
        data[size++] = value;
    }

    T& operator[](size_t index) {
        return data[index];  // O(1)éšæœºè®¿é—®
    }
};
```

### ğŸ”¥ é¢è¯•å¸¸è§é—®é¢˜

#### 1ï¸âƒ£ ä¸ºä»€ä¹ˆvectoræ‰©å®¹æ˜¯1.5å€æˆ–2å€ï¼Ÿ

**åŸå› ï¼š**
- **2å€æ‰©å®¹**ï¼šæ’å…¥æ€§èƒ½å¥½ï¼Œä½†ç©ºé—´æµªè´¹å¤š
- **1.5å€æ‰©å®¹**ï¼šç©ºé—´åˆ©ç”¨ç‡é«˜ï¼Œå¯ä»¥å¤ç”¨ä¹‹å‰é‡Šæ”¾çš„å†…å­˜å—
- **æ‘Šè¿˜åˆ†æ**ï¼šå¹³å‡æ¯æ¬¡æ’å…¥O(1)

```cpp
// æ‰©å®¹æ¬¡æ•°åˆ†æï¼ˆnæ¬¡æ’å…¥ï¼‰
// 2å€ï¼š1->2->4->8->16...ï¼Œæ€»å¤åˆ¶æ¬¡æ•°ï¼š1+2+4+8+...+n/2 = n-1
// å¹³å‡ï¼š(n-1)/n â‰ˆ O(1)
```

---

## ğŸ“Œ é“¾è¡¨ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **åŠ¨æ€åˆ†é…** | **æ’å…¥åˆ é™¤O(1)** | **éšæœºè®¿é—®O(n)** | **å•é“¾è¡¨** | **åŒå‘é“¾è¡¨** | **å¾ªç¯é“¾è¡¨** | **å¿«æ…¢æŒ‡é’ˆ** | **è™šæ‹Ÿå¤´èŠ‚ç‚¹**

### âœ… é“¾è¡¨ç±»å‹

#### 1. å•é“¾è¡¨
```cpp
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};
```

#### 2. åŒå‘é“¾è¡¨
```cpp
struct DoublyListNode {
    int val;
    DoublyListNode* prev;
    DoublyListNode* next;
    DoublyListNode(int x) : val(x), prev(nullptr), next(nullptr) {}
};
```

### ğŸ’» ç»å…¸æ“ä½œï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

#### åè½¬é“¾è¡¨
```cpp
// ğŸ”‘ è¿­ä»£æ³•
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;

    while (curr) {
        ListNode* next = curr->next;  // ä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        curr->next = prev;            // åè½¬æŒ‡é’ˆ
        prev = curr;                  // prevåç§»
        curr = next;                  // curråç§»
    }

    return prev;
}

// ğŸ”‘ é€’å½’æ³•
ListNode* reverseList(ListNode* head) {
    if (!head || !head->next) return head;

    ListNode* newHead = reverseList(head->next);
    head->next->next = head;  // å…³é”®ï¼šåè½¬
    head->next = nullptr;

    return newHead;
}
```

#### æ£€æµ‹ç¯ï¼ˆFloydåˆ¤åœˆç®—æ³•ï¼‰
```cpp
bool hasCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
        slow = slow->next;        // æ…¢æŒ‡é’ˆèµ°1æ­¥
        fast = fast->next->next;  // å¿«æŒ‡é’ˆèµ°2æ­¥

        if (slow == fast) return true;  // ç›¸é‡åˆ™æœ‰ç¯
    }

    return false;
}

// ğŸ”¥ è¿½é—®ï¼šæ‰¾åˆ°ç¯çš„å…¥å£
ListNode* detectCycle(ListNode* head) {
    ListNode* slow = head, *fast = head;

    // 1. å…ˆåˆ¤æ–­æ˜¯å¦æœ‰ç¯
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) break;
    }

    if (!fast || !fast->next) return nullptr;

    // 2. ä¸€ä¸ªæŒ‡é’ˆä»å¤´å¼€å§‹ï¼Œä¸€ä¸ªä»ç›¸é‡ç‚¹å¼€å§‹ï¼Œå†æ¬¡ç›¸é‡å³ä¸ºå…¥å£
    slow = head;
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }

    return slow;
}
```

#### åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
```cpp
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);  // ğŸ”‘ è™šæ‹Ÿå¤´èŠ‚ç‚¹
    ListNode* curr = &dummy;

    while (l1 && l2) {
        if (l1->val < l2->val) {
            curr->next = l1;
            l1 = l1->next;
        } else {
            curr->next = l2;
            l2 = l2->next;
        }
        curr = curr->next;
    }

    curr->next = l1 ? l1 : l2;
    return dummy.next;
}
```

### ğŸ“Š é“¾è¡¨ vs æ•°ç»„

| ç‰¹æ€§ | æ•°ç»„ | é“¾è¡¨ |
|-----|------|------|
| **éšæœºè®¿é—®** | O(1) | O(n) |
| **æ’å…¥/åˆ é™¤ï¼ˆå·²çŸ¥ä½ç½®ï¼‰** | O(n) | O(1) |
| **å†…å­˜å¸ƒå±€** | è¿ç»­ | åˆ†æ•£ |
| **ç¼“å­˜æ€§èƒ½** | å¥½ | å·® |
| **ç©ºé—´å¼€é”€** | å° | å¤§ï¼ˆé¢å¤–æŒ‡é’ˆï¼‰ |

---

## ğŸ“Œ æ ˆä¸é˜Ÿåˆ—ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **LIFO/FIFO** | **å•è°ƒæ ˆ** | **å•è°ƒé˜Ÿåˆ—** | **å¾ªç¯é˜Ÿåˆ—** | **åŒç«¯é˜Ÿåˆ—** | **ä¼˜å…ˆé˜Ÿåˆ—**

### âœ… æ ˆï¼ˆStackï¼‰- LIFO

#### åŸºæœ¬æ“ä½œ
```cpp
// ä½¿ç”¨æ•°ç»„å®ç°
class MyStack {
private:
    vector<int> data;

public:
    void push(int x) { data.push_back(x); }
    void pop() { data.pop_back(); }
    int top() { return data.back(); }
    bool empty() { return data.empty(); }
};
```

#### ç»å…¸åº”ç”¨ï¼šæ‹¬å·åŒ¹é…
```cpp
bool isValid(string s) {
    stack<char> stk;
    unordered_map<char, char> pairs = {
        {')', '('}, {']', '['}, {'}', '{'}
    };

    for (char c : s) {
        if (pairs.count(c)) {  // å³æ‹¬å·
            if (stk.empty() || stk.top() != pairs[c])
                return false;
            stk.pop();
        } else {  // å·¦æ‹¬å·
            stk.push(c);
        }
    }

    return stk.empty();
}
```

#### å•è°ƒæ ˆï¼ˆâ­â­â­â­â­ é«˜é¢‘ï¼‰
```cpp
// ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
vector<int> nextGreaterElement(vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1);
    stack<int> stk;  // å­˜å‚¨ç´¢å¼•

    for (int i = 0; i < n; i++) {
        // ğŸ”‘ ç»´æŠ¤é€’å‡æ ˆ
        while (!stk.empty() && nums[stk.top()] < nums[i]) {
            result[stk.top()] = nums[i];
            stk.pop();
        }
        stk.push(i);
    }

    return result;
}

// åº”ç”¨ï¼šæ¯æ—¥æ¸©åº¦ã€æ¥é›¨æ°´ç­‰
```

### âœ… é˜Ÿåˆ—ï¼ˆQueueï¼‰- FIFO

#### å¾ªç¯é˜Ÿåˆ—å®ç°ï¼ˆâ­â­â­â­ï¼‰
```cpp
class MyCircularQueue {
private:
    vector<int> data;
    int head, tail, size, capacity;

public:
    MyCircularQueue(int k) : data(k), head(0), tail(0), size(0), capacity(k) {}

    bool enQueue(int value) {
        if (isFull()) return false;
        data[tail] = value;
        tail = (tail + 1) % capacity;  // ğŸ”‘ å¾ªç¯
        size++;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) return false;
        head = (head + 1) % capacity;  // ğŸ”‘ å¾ªç¯
        size--;
        return true;
    }

    bool isEmpty() { return size == 0; }
    bool isFull() { return size == capacity; }
};
```

#### å•è°ƒé˜Ÿåˆ—ï¼ˆâ­â­â­â­ï¼‰
```cpp
// æ»‘åŠ¨çª—å£æœ€å¤§å€¼
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq;  // å­˜å‚¨ç´¢å¼•ï¼Œç»´æŠ¤é€’å‡é˜Ÿåˆ—
    vector<int> result;

    for (int i = 0; i < nums.size(); i++) {
        // ç§»é™¤çª—å£å¤–çš„å…ƒç´ 
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }

        // ğŸ”‘ ç»´æŠ¤é€’å‡é˜Ÿåˆ—
        while (!dq.empty() && nums[dq.back()] < nums[i]) {
            dq.pop_back();
        }

        dq.push_back(i);

        // çª—å£å½¢æˆåè®°å½•ç»“æœ
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }

    return result;
}
```

---

## ğŸ“Œ å“ˆå¸Œè¡¨ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **O(1)æŸ¥æ‰¾** | **å“ˆå¸Œå‡½æ•°** | **å†²çªè§£å†³** | **é“¾åœ°å€æ³•** | **å¼€æ”¾å¯»å€** | **è´Ÿè½½å› å­** | **rehash**

### âœ… å“ˆå¸Œè¡¨åŸç†

#### æ ¸å¿ƒç»„æˆ
1. **å“ˆå¸Œå‡½æ•°**ï¼š`hash(key) â†’ index`
2. **å†²çªè§£å†³**ï¼šå¤šä¸ªkeyæ˜ å°„åˆ°åŒä¸€ä½ç½®
3. **åŠ¨æ€æ‰©å®¹**ï¼šè´Ÿè½½å› å­è¿‡é«˜æ—¶æ‰©å®¹

### ğŸ’» æ‰‹å†™å“ˆå¸Œè¡¨ï¼ˆé“¾åœ°å€æ³•ï¼‰

```cpp
class MyHashMap {
private:
    static const int SIZE = 1000;

    struct Node {
        int key, val;
        Node* next;
        Node(int k, int v) : key(k), val(v), next(nullptr) {}
    };

    vector<Node*> buckets;

    int hash(int key) {
        return key % SIZE;
    }

public:
    MyHashMap() : buckets(SIZE, nullptr) {}

    void put(int key, int value) {
        int idx = hash(key);

        // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨
        Node* curr = buckets[idx];
        while (curr) {
            if (curr->key == key) {
                curr->val = value;
                return;
            }
            curr = curr->next;
        }

        // ä¸å­˜åœ¨åˆ™æ’å…¥åˆ°é“¾è¡¨å¤´éƒ¨
        Node* newNode = new Node(key, value);
        newNode->next = buckets[idx];
        buckets[idx] = newNode;
    }

    int get(int key) {
        int idx = hash(key);
        Node* curr = buckets[idx];

        while (curr) {
            if (curr->key == key) return curr->val;
            curr = curr->next;
        }

        return -1;
    }

    void remove(int key) {
        int idx = hash(key);
        Node* curr = buckets[idx];
        Node* prev = nullptr;

        while (curr) {
            if (curr->key == key) {
                if (prev) {
                    prev->next = curr->next;
                } else {
                    buckets[idx] = curr->next;
                }
                delete curr;
                return;
            }
            prev = curr;
            curr = curr->next;
        }
    }
};
```

### ğŸ”¥ å†²çªè§£å†³æ–¹æ³•

#### 1. é“¾åœ°å€æ³•ï¼ˆSeparate Chainingï¼‰
- æ¯ä¸ªæ¡¶å­˜å‚¨ä¸€ä¸ªé“¾è¡¨
- ä¼˜ç‚¹ï¼šå®ç°ç®€å•ï¼Œè´Ÿè½½å› å­å¯>1
- ç¼ºç‚¹ï¼šéœ€è¦é¢å¤–æŒ‡é’ˆï¼Œç¼“å­˜ä¸å‹å¥½

#### 2. å¼€æ”¾å¯»å€æ³•ï¼ˆOpen Addressingï¼‰

**çº¿æ€§æ¢æµ‹ï¼š**
```cpp
// å†²çªæ—¶ï¼Œä¾æ¬¡æ£€æŸ¥ (hash(key) + i) % SIZE
int findSlot(int key) {
    int idx = hash(key);
    int i = 0;

    while (table[idx].occupied && table[idx].key != key) {
        idx = (idx + 1) % SIZE;  // çº¿æ€§æ¢æµ‹
        i++;
        if (i >= SIZE) return -1;  // è¡¨æ»¡
    }

    return idx;
}
```

**äºŒæ¬¡æ¢æµ‹ï¼š**
```cpp
// (hash(key) + i^2) % SIZE
idx = (idx + i * i) % SIZE;
```

**åŒé‡å“ˆå¸Œï¼š**
```cpp
// (hash1(key) + i * hash2(key)) % SIZE
idx = (hash1(key) + i * hash2(key)) % SIZE;
```

### ğŸ“Š è´Ÿè½½å› å­ä¸æ‰©å®¹

```cpp
// è´Ÿè½½å› å­ = å…ƒç´ æ•°é‡ / æ¡¶æ•°é‡
float loadFactor = (float)size / capacity;

// ğŸ”‘ å½“è´Ÿè½½å› å­ > 0.75æ—¶ï¼Œæ‰©å®¹ä¸º2å€
if (loadFactor > 0.75) {
    rehash(capacity * 2);
}

void rehash(int newCapacity) {
    vector<Node*> oldBuckets = buckets;
    buckets = vector<Node*>(newCapacity, nullptr);
    capacity = newCapacity;

    // é‡æ–°æ’å…¥æ‰€æœ‰å…ƒç´ 
    for (Node* head : oldBuckets) {
        Node* curr = head;
        while (curr) {
            put(curr->key, curr->val);
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
}
```

### ğŸ”¥ å¸¸è§å“ˆå¸Œå‡½æ•°

```cpp
// 1. æ•´æ•°å“ˆå¸Œ
int hash(int key) {
    return key % SIZE;
}

// 2. å­—ç¬¦ä¸²å“ˆå¸Œï¼ˆå¤šé¡¹å¼æ»šåŠ¨å“ˆå¸Œï¼‰
int hash(string s) {
    const int BASE = 31;
    long long h = 0;
    for (char c : s) {
        h = h * BASE + c;
    }
    return h % SIZE;
}

// 3. é€šç”¨å“ˆå¸Œï¼ˆC++ std::hashï¼‰
size_t hash(int key) {
    return std::hash<int>{}(key);
}
```

---

## ğŸ“Œ æ ‘ç»“æ„ï¼ˆâ­â­â­â­â­ æ ¸å¿ƒé‡ç‚¹ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **äºŒå‰æ ‘** | **BST** | **AVL** | **çº¢é»‘æ ‘** | **Bæ ‘** | **B+æ ‘** | **å‰ä¸­ååºéå†** | **å±‚åºéå†** | **Morriséå†**

### âœ… äºŒå‰æ ‘åŸºç¡€

#### å®šä¹‰
```cpp
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

### ğŸ’» ä¸‰ç§éå†ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

#### å‰åºéå†ï¼ˆæ ¹-å·¦-å³ï¼‰
```cpp
// é€’å½’
void preorder(TreeNode* root) {
    if (!root) return;
    cout << root->val << " ";
    preorder(root->left);
    preorder(root->right);
}

// è¿­ä»£
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> stk;
    if (root) stk.push(root);

    while (!stk.empty()) {
        TreeNode* node = stk.top();
        stk.pop();
        result.push_back(node->val);

        // ğŸ”‘ å…ˆå³åå·¦ï¼ˆæ ˆæ˜¯LIFOï¼‰
        if (node->right) stk.push(node->right);
        if (node->left) stk.push(node->left);
    }

    return result;
}
```

#### ä¸­åºéå†ï¼ˆå·¦-æ ¹-å³ï¼‰
```cpp
// é€’å½’
void inorder(TreeNode* root) {
    if (!root) return;
    inorder(root->left);
    cout << root->val << " ";
    inorder(root->right);
}

// è¿­ä»£
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> stk;
    TreeNode* curr = root;

    while (curr || !stk.empty()) {
        // ğŸ”‘ ä¸€ç›´å¾€å·¦èµ°
        while (curr) {
            stk.push(curr);
            curr = curr->left;
        }

        curr = stk.top();
        stk.pop();
        result.push_back(curr->val);

        // è½¬å‘å³å­æ ‘
        curr = curr->right;
    }

    return result;
}
```

#### ååºéå†ï¼ˆå·¦-å³-æ ¹ï¼‰
```cpp
// é€’å½’
void postorder(TreeNode* root) {
    if (!root) return;
    postorder(root->left);
    postorder(root->right);
    cout << root->val << " ";
}

// è¿­ä»£ï¼ˆæŠ€å·§ï¼šå‰åºçš„é•œåƒåè½¬ï¼‰
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> stk;
    if (root) stk.push(root);

    while (!stk.empty()) {
        TreeNode* node = stk.top();
        stk.pop();
        result.push_back(node->val);

        // ğŸ”‘ å…ˆå·¦åå³
        if (node->left) stk.push(node->left);
        if (node->right) stk.push(node->right);
    }

    // ğŸ”‘ åè½¬ç»“æœ
    reverse(result.begin(), result.end());
    return result;
}
```

#### å±‚åºéå†ï¼ˆBFSï¼‰
```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> level;

        // ğŸ”‘ å¤„ç†å½“å‰å±‚
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            level.push_back(node->val);

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }

        result.push_back(level);
    }

    return result;
}
```

#### Morriséå†ï¼ˆâ­â­â­â­ ç©ºé—´O(1)ï¼‰
```cpp
// Morrisä¸­åºéå† - ä¸ç”¨æ ˆï¼Œç©ºé—´O(1)
vector<int> morrisInorder(TreeNode* root) {
    vector<int> result;
    TreeNode* curr = root;

    while (curr) {
        if (!curr->left) {
            // æ²¡æœ‰å·¦å­æ ‘ï¼Œè®¿é—®å½“å‰èŠ‚ç‚¹
            result.push_back(curr->val);
            curr = curr->right;
        } else {
            // æ‰¾åˆ°å·¦å­æ ‘çš„æœ€å³èŠ‚ç‚¹
            TreeNode* prev = curr->left;
            while (prev->right && prev->right != curr) {
                prev = prev->right;
            }

            if (!prev->right) {
                // ğŸ”‘ å»ºç«‹çº¿ç´¢
                prev->right = curr;
                curr = curr->left;
            } else {
                // ğŸ”‘ æ¢å¤æ ‘ç»“æ„
                prev->right = nullptr;
                result.push_back(curr->val);
                curr = curr->right;
            }
        }
    }

    return result;
}
```

---

## ğŸ“Œ äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **å·¦<æ ¹<å³** | **ä¸­åºæœ‰åº** | **æŸ¥æ‰¾O(logn)** | **æœ€åO(n)** | **æ’å…¥åˆ é™¤** | **å‰é©±åç»§**

### âœ… BSTæ€§è´¨

**å®šä¹‰ï¼š**
- å·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹ < æ ¹èŠ‚ç‚¹
- å³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹ > æ ¹èŠ‚ç‚¹
- å·¦å³å­æ ‘ä¹Ÿæ˜¯BST

**ç‰¹æ€§ï¼š**
- ä¸­åºéå†ç»“æœæ˜¯æœ‰åºçš„
- æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤å¹³å‡O(logn)ï¼Œæœ€åO(n)

### ğŸ’» åŸºæœ¬æ“ä½œ

#### æŸ¥æ‰¾
```cpp
TreeNode* search(TreeNode* root, int val) {
    if (!root || root->val == val) return root;

    if (val < root->val) {
        return search(root->left, val);
    } else {
        return search(root->right, val);
    }
}
```

#### æ’å…¥
```cpp
TreeNode* insert(TreeNode* root, int val) {
    if (!root) return new TreeNode(val);

    if (val < root->val) {
        root->left = insert(root->left, val);
    } else {
        root->right = insert(root->right, val);
    }

    return root;
}
```

#### åˆ é™¤ï¼ˆâ­â­â­â­â­ é‡ç‚¹ï¼‰
```cpp
TreeNode* deleteNode(TreeNode* root, int key) {
    if (!root) return nullptr;

    if (key < root->val) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->val) {
        root->right = deleteNode(root->right, key);
    } else {
        // æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹

        // æƒ…å†µ1ï¼šå¶å­èŠ‚ç‚¹æˆ–åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹
        if (!root->left) return root->right;
        if (!root->right) return root->left;

        // æƒ…å†µ2ï¼šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹
        // ğŸ”‘ æ‰¾åˆ°å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹ï¼ˆåç»§ï¼‰
        TreeNode* minNode = root->right;
        while (minNode->left) {
            minNode = minNode->left;
        }

        // ç”¨åç»§çš„å€¼æ›¿æ¢å½“å‰èŠ‚ç‚¹
        root->val = minNode->val;

        // åˆ é™¤åç»§èŠ‚ç‚¹
        root->right = deleteNode(root->right, minNode->val);
    }

    return root;
}
```

#### éªŒè¯BST
```cpp
bool isValidBST(TreeNode* root, long long minVal = LLONG_MIN, long long maxVal = LLONG_MAX) {
    if (!root) return true;

    // ğŸ”‘ å½“å‰èŠ‚ç‚¹å¿…é¡»åœ¨(minVal, maxVal)èŒƒå›´å†…
    if (root->val <= minVal || root->val >= maxVal) {
        return false;
    }

    // å·¦å­æ ‘ï¼šä¸Šç•Œæ˜¯root->val
    // å³å­æ ‘ï¼šä¸‹ç•Œæ˜¯root->val
    return isValidBST(root->left, minVal, root->val) &&
           isValidBST(root->right, root->val, maxVal);
}
```

---

## ğŸ“Œ å¹³è¡¡äºŒå‰æ ‘ï¼ˆAVLæ ‘ï¼‰ï¼ˆâ­â­â­â­ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **å¹³è¡¡å› å­** | **å·¦æ—‹** | **å³æ—‹** | **LL/RR/LR/RL** | **é«˜åº¦å¹³è¡¡** | **O(logn)ä¿è¯**

### âœ… AVLæ ‘æ€§è´¨

**å®šä¹‰ï¼š**
- ä»»ä½•èŠ‚ç‚¹çš„å·¦å³å­æ ‘é«˜åº¦å·® â‰¤ 1
- å¹³è¡¡å› å­ = å·¦å­æ ‘é«˜åº¦ - å³å­æ ‘é«˜åº¦ âˆˆ {-1, 0, 1}

**ä¼˜ç‚¹ï¼š**
- ä¸¥æ ¼å¹³è¡¡ï¼Œä¿è¯O(logn)æ—¶é—´å¤æ‚åº¦

**ç¼ºç‚¹ï¼š**
- æ’å…¥åˆ é™¤éœ€è¦é¢‘ç¹æ—‹è½¬ï¼Œç»´æŠ¤æˆæœ¬é«˜

### ğŸ’» AVLæ ‘å®ç°

```cpp
struct AVLNode {
    int val, height;
    AVLNode *left, *right;
    AVLNode(int x) : val(x), height(1), left(nullptr), right(nullptr) {}
};

class AVLTree {
private:
    int getHeight(AVLNode* node) {
        return node ? node->height : 0;
    }

    int getBalance(AVLNode* node) {
        return node ? getHeight(node->left) - getHeight(node->right) : 0;
    }

    void updateHeight(AVLNode* node) {
        if (node) {
            node->height = 1 + max(getHeight(node->left), getHeight(node->right));
        }
    }

    // ğŸ”‘ å³æ—‹ï¼ˆLLæƒ…å†µï¼‰
    //       y                x
    //      / \              / \
    //     x   C    =>      A   y
    //    / \                  / \
    //   A   B                B   C
    AVLNode* rotateRight(AVLNode* y) {
        AVLNode* x = y->left;
        AVLNode* B = x->right;

        x->right = y;
        y->left = B;

        updateHeight(y);
        updateHeight(x);

        return x;
    }

    // ğŸ”‘ å·¦æ—‹ï¼ˆRRæƒ…å†µï¼‰
    //     x                  y
    //    / \                / \
    //   A   y      =>      x   C
    //      / \            / \
    //     B   C          A   B
    AVLNode* rotateLeft(AVLNode* x) {
        AVLNode* y = x->right;
        AVLNode* B = y->left;

        y->left = x;
        x->right = B;

        updateHeight(x);
        updateHeight(y);

        return y;
    }

public:
    AVLNode* insert(AVLNode* node, int val) {
        // 1. æ­£å¸¸BSTæ’å…¥
        if (!node) return new AVLNode(val);

        if (val < node->val) {
            node->left = insert(node->left, val);
        } else if (val > node->val) {
            node->right = insert(node->right, val);
        } else {
            return node;  // ä¸å…è®¸é‡å¤å€¼
        }

        // 2. æ›´æ–°é«˜åº¦
        updateHeight(node);

        // 3. è·å–å¹³è¡¡å› å­
        int balance = getBalance(node);

        // 4. å››ç§æ—‹è½¬æƒ…å†µ

        // LLï¼šå·¦å­æ ‘çš„å·¦å­æ ‘
        if (balance > 1 && val < node->left->val) {
            return rotateRight(node);
        }

        // RRï¼šå³å­æ ‘çš„å³å­æ ‘
        if (balance < -1 && val > node->right->val) {
            return rotateLeft(node);
        }

        // LRï¼šå·¦å­æ ‘çš„å³å­æ ‘
        if (balance > 1 && val > node->left->val) {
            node->left = rotateLeft(node->left);
            return rotateRight(node);
        }

        // RLï¼šå³å­æ ‘çš„å·¦å­æ ‘
        if (balance < -1 && val < node->right->val) {
            node->right = rotateRight(node->right);
            return rotateLeft(node);
        }

        return node;
    }
};
```

### ğŸ”¥ å››ç§æ—‹è½¬æ€»ç»“

| æƒ…å†µ | å¤±è¡¡åŸå›  | æ“ä½œ |
|-----|---------|-----|
| **LL** | å·¦å­æ ‘çš„å·¦å­æ ‘æ’å…¥ | å³æ—‹ |
| **RR** | å³å­æ ‘çš„å³å­æ ‘æ’å…¥ | å·¦æ—‹ |
| **LR** | å·¦å­æ ‘çš„å³å­æ ‘æ’å…¥ | å…ˆå·¦æ—‹å·¦å­æ ‘ï¼Œå†å³æ—‹æ ¹ |
| **RL** | å³å­æ ‘çš„å·¦å­æ ‘æ’å…¥ | å…ˆå³æ—‹å³å­æ ‘ï¼Œå†å·¦æ—‹æ ¹ |

---

## ğŸ“Œ çº¢é»‘æ ‘ï¼ˆâ­â­â­â­â­ æ ¸å¿ƒé‡ç‚¹ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **5å¤§æ€§è´¨** | **é»‘é«˜** | **å˜è‰²** | **æ—‹è½¬** | **map/setåº•å±‚** | **2-3-4æ ‘ç­‰ä»·** | **è‡ªå¹³è¡¡**

### âœ… çº¢é»‘æ ‘5å¤§æ€§è´¨

1. **èŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–é»‘è‰²**
2. **æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²**
3. **å¶å­èŠ‚ç‚¹ï¼ˆNILï¼‰æ˜¯é»‘è‰²**
4. **çº¢è‰²èŠ‚ç‚¹çš„å­èŠ‚ç‚¹å¿…é¡»æ˜¯é»‘è‰²**ï¼ˆä¸èƒ½æœ‰è¿ç»­çš„çº¢è‰²èŠ‚ç‚¹ï¼‰
5. **ä»ä»»æ„èŠ‚ç‚¹åˆ°å…¶å¶å­èŠ‚ç‚¹çš„æ‰€æœ‰è·¯å¾„åŒ…å«ç›¸åŒæ•°é‡çš„é»‘è‰²èŠ‚ç‚¹**ï¼ˆé»‘é«˜ç›¸åŒï¼‰

### âœ… çº¢é»‘æ ‘ vs AVLæ ‘

| ç‰¹æ€§ | çº¢é»‘æ ‘ | AVLæ ‘ |
|-----|-------|-------|
| **å¹³è¡¡æ€§** | å¼±å¹³è¡¡ï¼ˆé»‘é«˜å¹³è¡¡ï¼‰ | ä¸¥æ ¼å¹³è¡¡ï¼ˆé«˜åº¦å·®â‰¤1ï¼‰ |
| **æœ€å¤§é«˜åº¦** | 2log(n+1) | 1.44log(n+2) |
| **æŸ¥æ‰¾** | O(logn) | O(logn)ï¼Œç¨å¿« |
| **æ’å…¥/åˆ é™¤** | O(logn)ï¼Œæ—‹è½¬å°‘ | O(logn)ï¼Œæ—‹è½¬å¤š |
| **åº”ç”¨** | C++ map/setï¼ŒJava TreeMap | éœ€è¦é¢‘ç¹æŸ¥æ‰¾çš„åœºæ™¯ |

### ğŸ’» çº¢é»‘æ ‘èŠ‚ç‚¹å®šä¹‰

```cpp
enum Color { RED, BLACK };

struct RBNode {
    int val;
    Color color;
    RBNode *left, *right, *parent;

    RBNode(int x) : val(x), color(RED), left(nullptr), right(nullptr), parent(nullptr) {}
};
```

### ğŸ”¥ æ’å…¥æ“ä½œï¼ˆâ­â­â­â­â­ é‡ç‚¹ï¼‰

**æ’å…¥æ­¥éª¤ï¼š**
1. æŒ‰BSTè§„åˆ™æ’å…¥æ–°èŠ‚ç‚¹
2. æ–°èŠ‚ç‚¹ç€ä¸º**çº¢è‰²**
3. ä¿®å¤çº¢é»‘æ ‘æ€§è´¨ï¼ˆå˜è‰² + æ—‹è½¬ï¼‰

**ä¿®å¤æƒ…å†µåˆ†æï¼š**

```cpp
void insertFixup(RBNode* node) {
    while (node->parent && node->parent->color == RED) {
        RBNode* parent = node->parent;
        RBNode* grandparent = parent->parent;

        if (parent == grandparent->left) {
            RBNode* uncle = grandparent->right;

            // æƒ…å†µ1ï¼šå”å”æ˜¯çº¢è‰²
            if (uncle && uncle->color == RED) {
                parent->color = BLACK;
                uncle->color = BLACK;
                grandparent->color = RED;
                node = grandparent;  // ğŸ”‘ å‘ä¸Šé€’å½’
            } else {
                // æƒ…å†µ2ï¼šå”å”æ˜¯é»‘è‰²ï¼Œå½“å‰èŠ‚ç‚¹æ˜¯å³å­©å­ï¼ˆLRï¼‰
                if (node == parent->right) {
                    node = parent;
                    rotateLeft(node);
                }

                // æƒ…å†µ3ï¼šå”å”æ˜¯é»‘è‰²ï¼Œå½“å‰èŠ‚ç‚¹æ˜¯å·¦å­©å­ï¼ˆLLï¼‰
                parent->color = BLACK;
                grandparent->color = RED;
                rotateRight(grandparent);
            }
        } else {
            // é•œåƒæƒ…å†µï¼ˆçˆ¶èŠ‚ç‚¹æ˜¯ç¥–çˆ¶çš„å³å­©å­ï¼‰
            // ...
        }
    }

    root->color = BLACK;  // ğŸ”‘ æ ¹èŠ‚ç‚¹å¿…é¡»æ˜¯é»‘è‰²
}
```

### ğŸ“Š çº¢é»‘æ ‘æ€§è´¨è¯æ˜

**ä¸ºä»€ä¹ˆæœ€å¤§é«˜åº¦æ˜¯2log(n+1)ï¼Ÿ**

1. æ ¹æ®æ€§è´¨5ï¼šä»»æ„è·¯å¾„é»‘é«˜ç›¸åŒï¼Œè®¾ä¸ºh
2. æœ€çŸ­è·¯å¾„ï¼šå…¨æ˜¯é»‘èŠ‚ç‚¹ï¼Œé•¿åº¦ = h
3. æœ€é•¿è·¯å¾„ï¼šçº¢é»‘äº¤æ›¿ï¼Œé•¿åº¦ = 2hï¼ˆçº¢è‰²èŠ‚ç‚¹ä¸èƒ½è¿ç»­ï¼‰
4. å› æ­¤ï¼šæœ€é•¿è·¯å¾„ â‰¤ 2 Ã— æœ€çŸ­è·¯å¾„
5. å«nä¸ªèŠ‚ç‚¹çš„çº¢é»‘æ ‘ï¼Œé»‘é«˜h â‰¥ logâ‚‚(n+1)
6. æœ€å¤§é«˜åº¦ â‰¤ 2logâ‚‚(n+1)

---

## ğŸ“Œ Bæ ‘ä¸B+æ ‘ï¼ˆâ­â­â­â­â­ æ•°æ®åº“æ ¸å¿ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **å¤šè·¯æœç´¢æ ‘** | **ç£ç›˜IO** | **mé˜¶** | **ç´¢å¼•** | **èŒƒå›´æŸ¥è¯¢** | **é¡ºåºè®¿é—®** | **å¶å­é“¾è¡¨**

### âœ… Bæ ‘ï¼ˆB-Treeï¼‰

#### å®šä¹‰ï¼ˆmé˜¶Bæ ‘ï¼‰
1. æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šmä¸ªå­èŠ‚ç‚¹
2. æ ¹èŠ‚ç‚¹è‡³å°‘2ä¸ªå­èŠ‚ç‚¹ï¼ˆé™¤éæ˜¯å¶å­ï¼‰
3. éå¶å­èŠ‚ç‚¹ï¼ˆé™¤æ ¹ï¼‰è‡³å°‘âŒˆm/2âŒ‰ä¸ªå­èŠ‚ç‚¹
4. æ‰€æœ‰å¶å­èŠ‚ç‚¹åœ¨åŒä¸€å±‚
5. èŠ‚ç‚¹å†…çš„keyæœ‰åº

#### ç»“æ„
```
         [10, 20, 30]
        /    |    |   \
    [1,5] [11,15] [21,25] [31,35]
```

### âœ… B+æ ‘ï¼ˆB+ Treeï¼‰ï¼ˆâ­â­â­â­â­ æ•°æ®åº“ç´¢å¼•ï¼‰

#### B+æ ‘ vs Bæ ‘

| ç‰¹æ€§ | Bæ ‘ | B+æ ‘ |
|-----|-----|------|
| **æ•°æ®å­˜å‚¨** | æ‰€æœ‰èŠ‚ç‚¹éƒ½å­˜æ•°æ® | åªæœ‰å¶å­èŠ‚ç‚¹å­˜æ•°æ® |
| **å†…éƒ¨èŠ‚ç‚¹** | å­˜key+data | åªå­˜keyï¼ˆç´¢å¼•ï¼‰ |
| **å¶å­èŠ‚ç‚¹** | ä¸è¿æ¥ | ç”¨é“¾è¡¨è¿æ¥ |
| **èŒƒå›´æŸ¥è¯¢** | éœ€è¦ä¸­åºéå† | åªéœ€éå†å¶å­é“¾è¡¨ |
| **ç£ç›˜IO** | è¾ƒå¤š | è¾ƒå°‘ï¼ˆå†…éƒ¨èŠ‚ç‚¹æ›´å°ï¼‰ |

#### B+æ ‘ç»“æ„
```
         [10, 20, 30]          <- å†…éƒ¨èŠ‚ç‚¹ï¼ˆåªå­˜keyï¼‰
        /    |    |   \
    [10] â†’ [20] â†’ [30] â†’ [40]  <- å¶å­èŠ‚ç‚¹ï¼ˆå­˜key+dataï¼‰ï¼Œé“¾è¡¨è¿æ¥
```

### ğŸ’» ä¸ºä»€ä¹ˆæ•°æ®åº“ç”¨B+æ ‘ï¼Ÿ

**1. æ›´å°‘çš„ç£ç›˜IO**
```
// å‡è®¾ç£ç›˜å—4KBï¼Œintæ˜¯4Bï¼ŒæŒ‡é’ˆ8B
// Bæ ‘èŠ‚ç‚¹ï¼š(key + data + æŒ‡é’ˆ) = (4 + 100 + 8) = 112B
//   â†’ ä¸€ä¸ªç£ç›˜å—å­˜ 4096/112 â‰ˆ 36ä¸ª
// B+æ ‘å†…éƒ¨èŠ‚ç‚¹ï¼š(key + æŒ‡é’ˆ) = (4 + 8) = 12B
//   â†’ ä¸€ä¸ªç£ç›˜å—å­˜ 4096/12 â‰ˆ 341ä¸ª

// æŸ¥æ‰¾100ä¸‡æ¡æ•°æ®ï¼š
// Bæ ‘ï¼šlogâ‚ƒâ‚†(1000000) â‰ˆ 4æ¬¡IO
// B+æ ‘ï¼šlogâ‚ƒâ‚„â‚(1000000) â‰ˆ 3æ¬¡IO
```

**2. èŒƒå›´æŸ¥è¯¢é«˜æ•ˆ**
```sql
-- æŸ¥æ‰¾ageåœ¨20-30ä¹‹é—´çš„è®°å½•
-- Bæ ‘ï¼šéœ€è¦ä¸­åºéå†ï¼Œå¤šæ¬¡éšæœºIO
-- B+æ ‘ï¼šæ‰¾åˆ°20ï¼Œæ²¿ç€å¶å­é“¾è¡¨é¡ºåºæ‰«æåˆ°30ï¼Œé¡ºåºIO
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
```

**3. ç¨³å®šçš„æŸ¥è¯¢æ—¶é—´**
- Bæ ‘ï¼šæ•°æ®åœ¨ä¸åŒå±‚ï¼ŒæŸ¥è¯¢æ—¶é—´ä¸ç¨³å®š
- B+æ ‘ï¼šæ•°æ®éƒ½åœ¨å¶å­å±‚ï¼ŒæŸ¥è¯¢æ—¶é—´ç¨³å®šä¸ºO(logn)

### ğŸ”¥ é¢è¯•é«˜é¢‘é—®é¢˜

#### 1ï¸âƒ£ ä¸ºä»€ä¹ˆMySQLçš„InnoDBä½¿ç”¨B+æ ‘è€Œä¸æ˜¯Bæ ‘ï¼Ÿ

**ç­”æ¡ˆï¼š**
1. **ç£ç›˜IOæ›´å°‘**ï¼šå†…éƒ¨èŠ‚ç‚¹ä¸å­˜æ•°æ®ï¼Œèƒ½å­˜æ›´å¤škeyï¼Œæ ‘æ›´çŸ®
2. **èŒƒå›´æŸ¥è¯¢å¿«**ï¼šå¶å­èŠ‚ç‚¹é“¾è¡¨ï¼Œé¡ºåºIO
3. **å…¨è¡¨æ‰«æå¿«**ï¼šåªéœ€éå†å¶å­é“¾è¡¨
4. **æŸ¥è¯¢ç¨³å®š**ï¼šæ‰€æœ‰æŸ¥è¯¢éƒ½åˆ°å¶å­å±‚

#### 2ï¸âƒ£ ä¸ºä»€ä¹ˆä¸ç”¨çº¢é»‘æ ‘åšæ•°æ®åº“ç´¢å¼•ï¼Ÿ

**ç­”æ¡ˆï¼š**
1. **ç£ç›˜IOå¤ªå¤š**ï¼šçº¢é»‘æ ‘æ˜¯äºŒå‰æ ‘ï¼Œé«˜åº¦lognï¼Œ100ä¸‡æ•°æ®çº¦20å±‚ï¼Œ20æ¬¡IO
2. **ä¸é€‚åˆèŒƒå›´æŸ¥è¯¢**ï¼šéœ€è¦ä¸­åºéå†
3. **ä¸é€‚åˆç£ç›˜å­˜å‚¨**ï¼šæ¯ä¸ªèŠ‚ç‚¹åªæœ‰2ä¸ªå­èŠ‚ç‚¹ï¼Œç£ç›˜å—åˆ©ç”¨ç‡ä½

#### 3ï¸âƒ£ B+æ ‘çš„é˜¶æ•°ï¼ˆmï¼‰å¦‚ä½•ç¡®å®šï¼Ÿ

**ç­”æ¡ˆï¼š**
```
ç£ç›˜å—å¤§å° = å†…éƒ¨èŠ‚ç‚¹å¤§å°
4KB = m Ã— (key_size + pointer_size)
4096 = m Ã— (4 + 8)
m = 341

// MySQL InnoDBé»˜è®¤é¡µå¤§å°16KBï¼Œé˜¶æ•°çº¦1200
```

---

## ğŸ“Œ å †ï¼ˆHeapï¼‰ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **å®Œå…¨äºŒå‰æ ‘** | **å¤§é¡¶å †/å°é¡¶å †** | **å †åŒ–** | **ä¼˜å…ˆé˜Ÿåˆ—** | **topK** | **å †æ’åº**

### âœ… å †çš„æ€§è´¨

**å®šä¹‰ï¼š**
- å®Œå…¨äºŒå‰æ ‘
- **å¤§é¡¶å †**ï¼šçˆ¶èŠ‚ç‚¹ â‰¥ å­èŠ‚ç‚¹
- **å°é¡¶å †**ï¼šçˆ¶èŠ‚ç‚¹ â‰¤ å­èŠ‚ç‚¹

**æ•°ç»„è¡¨ç¤ºï¼š**
```cpp
// èŠ‚ç‚¹içš„å…³ç³»
parent(i) = (i - 1) / 2
left(i) = 2 * i + 1
right(i) = 2 * i + 2
```

### ğŸ’» æ‰‹å†™å †ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šï¼‰

```cpp
class MinHeap {
private:
    vector<int> heap;

    // ğŸ”‘ å‘ä¸Šè°ƒæ•´ï¼ˆæ’å…¥æ—¶ä½¿ç”¨ï¼‰
    void heapifyUp(int index) {
        while (index > 0) {
            int parent = (index - 1) / 2;
            if (heap[index] >= heap[parent]) break;

            swap(heap[index], heap[parent]);
            index = parent;
        }
    }

    // ğŸ”‘ å‘ä¸‹è°ƒæ•´ï¼ˆåˆ é™¤æ—¶ä½¿ç”¨ï¼‰
    void heapifyDown(int index) {
        int n = heap.size();

        while (true) {
            int smallest = index;
            int left = 2 * index + 1;
            int right = 2 * index + 2;

            if (left < n && heap[left] < heap[smallest]) {
                smallest = left;
            }
            if (right < n && heap[right] < heap[smallest]) {
                smallest = right;
            }

            if (smallest == index) break;

            swap(heap[index], heap[smallest]);
            index = smallest;
        }
    }

public:
    void push(int val) {
        heap.push_back(val);
        heapifyUp(heap.size() - 1);
    }

    void pop() {
        if (heap.empty()) return;

        // ğŸ”‘ ç”¨æœ€åä¸€ä¸ªå…ƒç´ æ›¿æ¢å †é¡¶
        heap[0] = heap.back();
        heap.pop_back();

        if (!heap.empty()) {
            heapifyDown(0);
        }
    }

    int top() {
        return heap[0];
    }

    bool empty() {
        return heap.empty();
    }
};
```

### ğŸ”¥ å †çš„åº”ç”¨

#### 1ï¸âƒ£ TopKé—®é¢˜ï¼ˆâ­â­â­â­â­ é«˜é¢‘ï¼‰
```cpp
// æ‰¾æœ€å¤§çš„Kä¸ªæ•° â†’ ç”¨å°é¡¶å †ï¼ˆå †å¤§å°ä¸ºKï¼‰
vector<int> topKLargest(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<int>> minHeap;  // å°é¡¶å †

    for (int num : nums) {
        if (minHeap.size() < k) {
            minHeap.push(num);
        } else if (num > minHeap.top()) {
            minHeap.pop();
            minHeap.push(num);
        }
    }

    vector<int> result;
    while (!minHeap.empty()) {
        result.push_back(minHeap.top());
        minHeap.pop();
    }

    return result;
}

// æ—¶é—´å¤æ‚åº¦ï¼šO(nlogk)
// ç©ºé—´å¤æ‚åº¦ï¼šO(k)
```

#### 2ï¸âƒ£ å †æ’åº
```cpp
void heapSort(vector<int>& arr) {
    int n = arr.size();

    // 1. å»ºå † O(n)
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapifyDown(arr, n, i);
    }

    // 2. æ’åº O(nlogn)
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);     // å †é¡¶æ”¾åˆ°æœ«å°¾
        heapifyDown(arr, i, 0);   // é‡æ–°è°ƒæ•´å †
    }
}

void heapifyDown(vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapifyDown(arr, n, largest);
    }
}
```

#### 3ï¸âƒ£ åˆå¹¶Kä¸ªæœ‰åºé“¾è¡¨
```cpp
struct Compare {
    bool operator()(ListNode* a, ListNode* b) {
        return a->val > b->val;  // å°é¡¶å †
    }
};

ListNode* mergeKLists(vector<ListNode*>& lists) {
    priority_queue<ListNode*, vector<ListNode*>, Compare> minHeap;

    // ğŸ”‘ å°†æ‰€æœ‰é“¾è¡¨çš„å¤´èŠ‚ç‚¹åŠ å…¥å †
    for (ListNode* head : lists) {
        if (head) minHeap.push(head);
    }

    ListNode dummy(0);
    ListNode* curr = &dummy;

    while (!minHeap.empty()) {
        ListNode* node = minHeap.top();
        minHeap.pop();

        curr->next = node;
        curr = curr->next;

        if (node->next) {
            minHeap.push(node->next);
        }
    }

    return dummy.next;
}
```

---

## ğŸ“Œ å›¾ï¼ˆGraphï¼‰ï¼ˆâ­â­â­â­ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **é‚»æ¥çŸ©é˜µ** | **é‚»æ¥è¡¨** | **DFS** | **BFS** | **æ‹“æ‰‘æ’åº** | **æœ€çŸ­è·¯å¾„** | **å¹¶æŸ¥é›†**

### âœ… å›¾çš„è¡¨ç¤º

#### 1. é‚»æ¥çŸ©é˜µ
```cpp
// é€‚åˆç¨ å¯†å›¾
vector<vector<int>> graph(n, vector<int>(n, 0));
graph[i][j] = 1;  // è¾¹ i->j

// ä¼˜ç‚¹ï¼šæŸ¥è¾¹O(1)
// ç¼ºç‚¹ï¼šç©ºé—´O(nÂ²)ï¼Œéå†æ‰€æœ‰è¾¹O(nÂ²)
```

#### 2. é‚»æ¥è¡¨
```cpp
// é€‚åˆç¨€ç–å›¾
vector<vector<int>> graph(n);
graph[i].push_back(j);  // è¾¹ i->j

// ä¼˜ç‚¹ï¼šç©ºé—´O(V+E)ï¼Œéå†æ‰€æœ‰è¾¹O(E)
// ç¼ºç‚¹ï¼šæŸ¥è¾¹O(degree)
```

### ğŸ’» å›¾çš„éå†

#### DFSï¼ˆæ·±åº¦ä¼˜å…ˆï¼‰
```cpp
void dfs(vector<vector<int>>& graph, int node, vector<bool>& visited) {
    visited[node] = true;
    cout << node << " ";

    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(graph, neighbor, visited);
        }
    }
}

// æ—¶é—´å¤æ‚åº¦ï¼šO(V + E)
```

#### BFSï¼ˆå¹¿åº¦ä¼˜å…ˆï¼‰
```cpp
void bfs(vector<vector<int>>& graph, int start) {
    int n = graph.size();
    vector<bool> visited(n, false);
    queue<int> q;

    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";

        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}

// æ—¶é—´å¤æ‚åº¦ï¼šO(V + E)
```

### ğŸ”¥ æ‹“æ‰‘æ’åºï¼ˆâ­â­â­â­â­ é«˜é¢‘ï¼‰

**åº”ç”¨**ï¼šè¯¾ç¨‹è¡¨ã€ä»»åŠ¡è°ƒåº¦

```cpp
// Kahnç®—æ³•ï¼ˆBFSï¼‰
vector<int> topologicalSort(int n, vector<vector<int>>& edges) {
    vector<vector<int>> graph(n);
    vector<int> indegree(n, 0);

    // å»ºå›¾
    for (auto& edge : edges) {
        int from = edge[0], to = edge[1];
        graph[from].push_back(to);
        indegree[to]++;
    }

    // ğŸ”‘ å°†å…¥åº¦ä¸º0çš„èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
    queue<int> q;
    for (int i = 0; i < n; i++) {
        if (indegree[i] == 0) {
            q.push(i);
        }
    }

    vector<int> result;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        // åˆ é™¤è¯¥èŠ‚ç‚¹çš„æ‰€æœ‰å‡ºè¾¹
        for (int neighbor : graph[node]) {
            indegree[neighbor]--;
            if (indegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    // ğŸ”‘ å¦‚æœç»“æœæ•°é‡ < nï¼Œè¯´æ˜æœ‰ç¯
    return result.size() == n ? result : vector<int>{};
}
```

### ğŸ”¥ å¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰ï¼ˆâ­â­â­â­â­ é«˜é¢‘ï¼‰

**åº”ç”¨**ï¼šè¿é€šæ€§é—®é¢˜ã€æœ€å°ç”Ÿæˆæ ‘

```cpp
class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;  // ç§©ï¼ˆæ ‘çš„é«˜åº¦ï¼‰

public:
    UnionFind(int n) : parent(n), rank(n, 0) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;  // åˆå§‹æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æ˜¯è‡ªå·±
        }
    }

    // ğŸ”‘ æŸ¥æ‰¾ï¼ˆè·¯å¾„å‹ç¼©ï¼‰
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // è·¯å¾„å‹ç¼©
        }
        return parent[x];
    }

    // ğŸ”‘ åˆå¹¶ï¼ˆæŒ‰ç§©åˆå¹¶ï¼‰
    bool unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX == rootY) return false;  // å·²ç»åœ¨åŒä¸€é›†åˆ

        // æŒ‰ç§©åˆå¹¶ï¼šå°†çŸ®æ ‘æ¥åˆ°é«˜æ ‘ä¸‹é¢
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }

        return true;
    }

    bool connected(int x, int y) {
        return find(x) == find(y);
    }
};

// æ—¶é—´å¤æ‚åº¦ï¼šæ¥è¿‘O(1)ï¼ˆÎ±(n)ï¼Œåé˜¿å…‹æ›¼å‡½æ•°ï¼‰
```

---

## ğŸ“Œ STLå®¹å™¨åº•å±‚å®ç°ï¼ˆâ­â­â­â­â­ æ ¸å¿ƒé‡ç‚¹ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **vectoråŠ¨æ€æ•°ç»„** | **dequeåŒç«¯é˜Ÿåˆ—** | **liståŒå‘é“¾è¡¨** | **mapçº¢é»‘æ ‘** | **unordered_mapå“ˆå¸Œè¡¨** | **set** | **priority_queueå †**

### âœ… vectorï¼ˆåŠ¨æ€æ•°ç»„ï¼‰

#### åº•å±‚å®ç°
```cpp
template<typename T>
class vector {
private:
    T* data;           // æ•°æ®æŒ‡é’ˆ
    size_t capacity;   // å®¹é‡
    size_t size;       // å…ƒç´ æ•°é‡

public:
    // ğŸ”‘ æ‰©å®¹ï¼š2å€å¢é•¿
    void reserve(size_t newCapacity) {
        if (newCapacity <= capacity) return;

        T* newData = new T[newCapacity];
        for (size_t i = 0; i < size; i++) {
            newData[i] = std::move(data[i]);  // ç§»åŠ¨è¯­ä¹‰
        }
        delete[] data;
        data = newData;
        capacity = newCapacity;
    }

    void push_back(const T& value) {
        if (size == capacity) {
            reserve(capacity == 0 ? 1 : capacity * 2);
        }
        data[size++] = value;
    }
};
```

#### å¤æ‚åº¦
| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ |
|-----|-----------|
| éšæœºè®¿é—® | O(1) |
| æœ«å°¾æ’å…¥/åˆ é™¤ | O(1)æ‘Šè¿˜ |
| ä¸­é—´æ’å…¥/åˆ é™¤ | O(n) |

### âœ… dequeï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰

#### åº•å±‚å®ç°
- **åˆ†æ®µè¿ç»­**ï¼šå¤šä¸ªå›ºå®šå¤§å°çš„æ•°ç»„
- **ä¸­æ§æ•°ç»„**ï¼šå­˜å‚¨å„æ®µçš„æŒ‡é’ˆ

```cpp
// ç»“æ„ç¤ºæ„
map:  [ptr0][ptr1][ptr2]...
         â†“     â†“     â†“
æ®µ:   [æ•°ç»„] [æ•°ç»„] [æ•°ç»„]

// ğŸ”‘ ä¼˜ç‚¹ï¼š
// 1. ä¸¤ç«¯æ’å…¥/åˆ é™¤O(1)
// 2. éšæœºè®¿é—®O(1)ï¼ˆä½†æ¯”vectoræ…¢ï¼Œéœ€è¦è®¡ç®—åœ¨å“ªä¸€æ®µï¼‰
// 3. ä¸éœ€è¦æ•´ä½“æ¬ç§»
```

#### å¤æ‚åº¦
| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ |
|-----|-----------|
| éšæœºè®¿é—® | O(1) |
| ä¸¤ç«¯æ’å…¥/åˆ é™¤ | O(1) |
| ä¸­é—´æ’å…¥/åˆ é™¤ | O(n) |

### âœ… listï¼ˆåŒå‘é“¾è¡¨ï¼‰

#### åº•å±‚å®ç°
```cpp
template<typename T>
struct ListNode {
    T data;
    ListNode* prev;
    ListNode* next;
};

// ğŸ”‘ ç‰¹æ€§ï¼š
// 1. ä»»æ„ä½ç½®æ’å…¥/åˆ é™¤O(1)ï¼ˆå·²çŸ¥è¿­ä»£å™¨ï¼‰
// 2. ä¸æ”¯æŒéšæœºè®¿é—®
// 3. ç©ºé—´å¼€é”€å¤§ï¼ˆæ¯ä¸ªèŠ‚ç‚¹2ä¸ªæŒ‡é’ˆï¼‰
```

### âœ… map / setï¼ˆçº¢é»‘æ ‘ï¼‰ï¼ˆâ­â­â­â­â­ é‡ç‚¹ï¼‰

#### åº•å±‚å®ç°
```cpp
// mapï¼šçº¢é»‘æ ‘ï¼Œkeyæœ‰åº
template<typename Key, typename Value>
class map {
private:
    RBTree<pair<Key, Value>> tree;  // çº¢é»‘æ ‘

public:
    // ğŸ”‘ æ‰€æœ‰æ“ä½œéƒ½æ˜¯O(logn)
    iterator find(const Key& key);
    void insert(const pair<Key, Value>& kv);
    void erase(const Key& key);
};

// setï¼šåªå­˜keyçš„map
template<typename Key>
class set {
private:
    RBTree<Key> tree;
};
```

#### ç‰¹æ€§
- **æœ‰åº**ï¼šä¸­åºéå†å³ä¸ºæœ‰åºåºåˆ—
- **æŸ¥æ‰¾/æ’å…¥/åˆ é™¤**ï¼šO(logn)
- **è¿­ä»£å™¨**ï¼šåŒå‘è¿­ä»£å™¨

### âœ… unordered_map / unordered_setï¼ˆå“ˆå¸Œè¡¨ï¼‰ï¼ˆâ­â­â­â­â­ é‡ç‚¹ï¼‰

#### åº•å±‚å®ç°
```cpp
// é“¾åœ°å€æ³•ï¼ˆæ¡¶ + é“¾è¡¨ï¼‰
template<typename Key, typename Value>
class unordered_map {
private:
    vector<list<pair<Key, Value>>> buckets;  // æ¡¶æ•°ç»„
    size_t size;

    size_t hash(const Key& key) {
        return std::hash<Key>{}(key) % buckets.size();
    }

public:
    void insert(const pair<Key, Value>& kv) {
        size_t idx = hash(kv.first);
        buckets[idx].push_back(kv);
        size++;

        // ğŸ”‘ è´Ÿè½½å› å­ > 1æ—¶ï¼Œrehash
        if ((float)size / buckets.size() > 1.0) {
            rehash(buckets.size() * 2);
        }
    }

    iterator find(const Key& key) {
        size_t idx = hash(key);
        for (auto& kv : buckets[idx]) {
            if (kv.first == key) return iterator(&kv);
        }
        return end();
    }
};
```

#### ç‰¹æ€§
- **æ— åº**ï¼šä¸ä¿è¯å…ƒç´ é¡ºåº
- **æŸ¥æ‰¾/æ’å…¥/åˆ é™¤**ï¼šå¹³å‡O(1)ï¼Œæœ€åO(n)
- **ç©ºé—´æ¢æ—¶é—´**ï¼šéœ€è¦é¢„ç•™ç©ºé—´

### âœ… priority_queueï¼ˆå †ï¼‰

#### åº•å±‚å®ç°
```cpp
// åŸºäºvectorçš„å¤§é¡¶å †
template<typename T, typename Compare = less<T>>
class priority_queue {
private:
    vector<T> heap;
    Compare comp;

public:
    void push(const T& value) {
        heap.push_back(value);
        heapifyUp(heap.size() - 1);
    }

    void pop() {
        heap[0] = heap.back();
        heap.pop_back();
        heapifyDown(0);
    }

    const T& top() const {
        return heap[0];
    }
};

// ğŸ”‘ ä½¿ç”¨ç¤ºä¾‹
priority_queue<int> maxHeap;  // å¤§é¡¶å †
priority_queue<int, vector<int>, greater<int>> minHeap;  // å°é¡¶å †
```

### ğŸ“Š STLå®¹å™¨é€‰æ‹©æŒ‡å—

| éœ€æ±‚ | æ¨èå®¹å™¨ | åŸå›  |
|-----|---------|------|
| é¢‘ç¹éšæœºè®¿é—® | `vector` | O(1)éšæœºè®¿é—® |
| ä¸¤ç«¯æ’å…¥åˆ é™¤ | `deque` | ä¸¤ç«¯O(1) |
| ä¸­é—´é¢‘ç¹æ’å…¥åˆ é™¤ | `list` | ä»»æ„ä½ç½®O(1) |
| éœ€è¦æœ‰åº + æŸ¥æ‰¾ | `map/set` | O(logn)æœ‰åº |
| å¿«é€ŸæŸ¥æ‰¾ï¼ˆæ— åºï¼‰ | `unordered_map/set` | O(1)æŸ¥æ‰¾ |
| ä¼˜å…ˆçº§é˜Ÿåˆ— | `priority_queue` | O(logn)æ’å…¥/åˆ é™¤ |

---

## ğŸ“Œ Redisæ•°æ®ç»“æ„ï¼ˆâ­â­â­â­â­ æ ¸å¿ƒé‡ç‚¹ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **SDS** | **ziplist** | **quicklist** | **è·³è¡¨** | **intset** | **hashtable** | **å¯¹è±¡ç¼–ç **

### âœ… Redis 5ç§åŸºæœ¬ç±»å‹

| ç±»å‹ | åº•å±‚ç¼–ç  | åº”ç”¨åœºæ™¯ |
|-----|---------|---------|
| **String** | SDSï¼ˆç®€å•åŠ¨æ€å­—ç¬¦ä¸²ï¼‰ | ç¼“å­˜ã€è®¡æ•°å™¨ã€åˆ†å¸ƒå¼é” |
| **List** | quicklistï¼ˆziplist + linkedlistï¼‰ | æ¶ˆæ¯é˜Ÿåˆ—ã€æ—¶é—´çº¿ |
| **Hash** | ziplist / hashtable | å¯¹è±¡å­˜å‚¨ã€è´­ç‰©è½¦ |
| **Set** | intset / hashtable | æ ‡ç­¾ã€å…±åŒå¥½å‹ |
| **ZSet** | ziplist / skiplist + hashtable | æ’è¡Œæ¦œã€å»¶æ—¶é˜Ÿåˆ— |

---

### ğŸ“Œ 1. SDSï¼ˆSimple Dynamic Stringï¼‰ï¼ˆâ­â­â­â­â­ï¼‰

#### ç»“æ„
```cpp
struct sdshdr {
    int len;        // ğŸ”‘ å·²ä½¿ç”¨é•¿åº¦
    int free;       // ğŸ”‘ å‰©ä½™å¯ç”¨é•¿åº¦
    char buf[];     // å­—èŠ‚æ•°ç»„
};

// ä¾‹å¦‚ï¼š"Redis"
// len = 5
// free = 0
// buf = "Redis\0"  ï¼ˆäºŒè¿›åˆ¶å®‰å…¨ï¼Œå¯åŒ…å«\0ï¼‰
```

#### SDS vs Cå­—ç¬¦ä¸²

| ç‰¹æ€§ | Cå­—ç¬¦ä¸² | SDS |
|-----|--------|-----|
| **è·å–é•¿åº¦** | O(n) | O(1) |
| **ç¼“å†²åŒºæº¢å‡º** | å¯èƒ½æº¢å‡º | è‡ªåŠ¨æ‰©å®¹ |
| **ä¿®æ”¹å­—ç¬¦ä¸²** | æ€»æ˜¯åˆ†é…æ–°å†…å­˜ | é¢„åˆ†é…+æƒ°æ€§é‡Šæ”¾ |
| **äºŒè¿›åˆ¶å®‰å…¨** | å¦ï¼ˆ\0ç»“å°¾ï¼‰ | æ˜¯ï¼ˆlenå­—æ®µï¼‰ |

#### æ‰©å®¹ç­–ç•¥
```cpp
// ğŸ”‘ é¢„åˆ†é…ç­–ç•¥
if (newLen < 1MB) {
    // å°äº1MBï¼š2å€æ‰©å®¹
    capacity = newLen * 2;
} else {
    // å¤§äº1MBï¼šæ¯æ¬¡+1MB
    capacity = newLen + 1MB;
}
```

---

### ğŸ“Œ 2. ziplistï¼ˆå‹ç¼©åˆ—è¡¨ï¼‰ï¼ˆâ­â­â­â­ï¼‰

#### ç»“æ„
```
<zlbytes> <zltail> <zllen> <entry>...<entry> <zlend>

zlbytes: æ€»å­—èŠ‚æ•°ï¼ˆ4å­—èŠ‚ï¼‰
zltail:  å°¾èŠ‚ç‚¹åç§»é‡ï¼ˆ4å­—èŠ‚ï¼‰
zllen:   èŠ‚ç‚¹æ•°é‡ï¼ˆ2å­—èŠ‚ï¼‰
entry:   èŠ‚ç‚¹
zlend:   ç»“æŸæ ‡è®°ï¼ˆ1å­—èŠ‚ï¼Œ0xFFï¼‰
```

#### entryç»“æ„
```
<prevlen> <encoding> <data>

prevlen:  å‰ä¸€èŠ‚ç‚¹é•¿åº¦ï¼ˆ1æˆ–5å­—èŠ‚ï¼‰
encoding: ç¼–ç ç±»å‹ + é•¿åº¦
data:     å®é™…æ•°æ®
```

#### ä¼˜ç‚¹
- **å†…å­˜ç´§å‡‘**ï¼šè¿ç»­å†…å­˜ï¼Œæ— æŒ‡é’ˆå¼€é”€
- **ç¼“å­˜å‹å¥½**ï¼šé¡ºåºè®¿é—®å¿«

#### ç¼ºç‚¹
- **è¿é”æ›´æ–°**ï¼šæ’å…¥å¯¼è‡´åç»­èŠ‚ç‚¹prevlenå˜åŒ–ï¼Œæœ€åO(nÂ²)

```cpp
// ğŸ”¥ é¢è¯•é«˜é¢‘ï¼šè¿é”æ›´æ–°
// å‡è®¾ziplist: [250B][250B][250B]
// æ’å…¥254Bçš„èŠ‚ç‚¹ â†’ åç»­èŠ‚ç‚¹çš„prevlenä»1å­—èŠ‚â†’5å­—èŠ‚
// å¯èƒ½è§¦å‘è¿é”æ›´æ–°
```

---

### ğŸ“Œ 3. quicklistï¼ˆå¿«é€Ÿåˆ—è¡¨ï¼‰ï¼ˆâ­â­â­â­â­ï¼‰

#### ç»“æ„ï¼ˆRedis 3.2+çš„Liståº•å±‚ï¼‰
```
quicklist = linkedlist + ziplist

[ziplist] <-> [ziplist] <-> [ziplist]

// ğŸ”‘ ç»“åˆäº†ï¼š
// - linkedlistçš„çµæ´»æ€§ï¼ˆä¸¤ç«¯æ’å…¥å¿«ï¼‰
// - ziplistçš„å†…å­˜ç´§å‡‘æ€§
```

#### é…ç½®
```
list-max-ziplist-size -2   # æ¯ä¸ªziplistæœ€å¤§8KB
list-compress-depth 1       # é¦–å°¾å„1ä¸ªä¸å‹ç¼©ï¼Œä¸­é—´èŠ‚ç‚¹LZFå‹ç¼©
```

---

### ğŸ“Œ 4. skiplistï¼ˆè·³è¡¨ï¼‰ï¼ˆâ­â­â­â­â­ æ ¸å¿ƒé‡ç‚¹ï¼‰

#### ä¸ºä»€ä¹ˆRedisç”¨è·³è¡¨è€Œä¸æ˜¯çº¢é»‘æ ‘ï¼Ÿ

| ç‰¹æ€§ | è·³è¡¨ | çº¢é»‘æ ‘ |
|-----|-----|-------|
| **å®ç°å¤æ‚åº¦** | ç®€å• | å¤æ‚ï¼ˆæ—‹è½¬ã€å˜è‰²ï¼‰ |
| **èŒƒå›´æŸ¥è¯¢** | é«˜æ•ˆï¼ˆé¡ºåºéå†ï¼‰ | éœ€è¦ä¸­åºéå† |
| **æ’å…¥/åˆ é™¤** | O(logn)ï¼Œä¿®æ”¹å°‘ | O(logn)ï¼Œå¯èƒ½å¤šæ¬¡æ—‹è½¬ |
| **å†…å­˜** | ç¨å¤šï¼ˆç´¢å¼•å±‚ï¼‰ | æ¯èŠ‚ç‚¹+é¢œè‰²ä½ |
| **å¹¶å‘** | æ˜“äºå®ç°æ— é” | å›°éš¾ |

#### ç»“æ„
```cpp
struct zskiplistNode {
    sds ele;                   // æˆå‘˜å¯¹è±¡
    double score;              // åˆ†æ•°
    zskiplistNode* backward;   // åé€€æŒ‡é’ˆ
    struct zskiplistLevel {
        zskiplistNode* forward; // å‰è¿›æŒ‡é’ˆ
        unsigned int span;      // è·¨åº¦
    } level[];                 // å±‚
};

// ç¤ºæ„å›¾ï¼ˆ4å±‚è·³è¡¨ï¼‰
// L4:  1 --------------------------------> 7
// L3:  1 ----------> 4 -----------------> 7
// L2:  1 -----> 3 -> 4 -----> 6 -------> 7
// L1:  1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 9
```

#### æŸ¥æ‰¾è¿‡ç¨‹
```cpp
// æŸ¥æ‰¾score=6çš„å…ƒç´ 
zskiplistNode* find(double score) {
    zskiplistNode* x = header;

    // ğŸ”‘ ä»æœ€é«˜å±‚å¼€å§‹
    for (int i = level - 1; i >= 0; i--) {
        while (x->level[i].forward &&
               x->level[i].forward->score < score) {
            x = x->level[i].forward;  // å‘å³èµ°
        }
        // å‘ä¸‹èµ°
    }

    x = x->level[0].forward;
    if (x && x->score == score) return x;
    return nullptr;
}

// æ—¶é—´å¤æ‚åº¦ï¼šO(logn)
```

#### å±‚æ•°ç”Ÿæˆï¼ˆéšæœºåŒ–ï¼‰
```cpp
// ğŸ”‘ æ¦‚ç‡ï¼šæ¯å±‚æ™‹å‡æ¦‚ç‡0.25
int randomLevel() {
    int level = 1;
    while (random() < 0.25 && level < MAX_LEVEL) {
        level++;
    }
    return level;
}

// æœŸæœ›å±‚æ•°ï¼šlogâ‚„(n) â‰ˆ 0.5 * logâ‚‚(n)
```

---

### ğŸ“Œ 5. intsetï¼ˆæ•´æ•°é›†åˆï¼‰ï¼ˆâ­â­â­ï¼‰

#### ç»“æ„
```cpp
typedef struct intset {
    uint32_t encoding;  // ç¼–ç ï¼šint16_t / int32_t / int64_t
    uint32_t length;    // å…ƒç´ æ•°é‡
    int8_t contents[];  // æ•´æ•°æ•°ç»„ï¼ˆæœ‰åºï¼‰
} intset;
```

#### å‡çº§æœºåˆ¶
```cpp
// åˆå§‹ï¼šintset<int16_t> = [1, 2, 3]
// æ’å…¥65535ï¼ˆè¶…å‡ºint16_tèŒƒå›´ï¼‰
// â†’ å‡çº§ä¸ºintset<int32_t> = [1, 2, 3, 65535]

// ğŸ”‘ ä¼˜ç‚¹ï¼šèŠ‚çœå†…å­˜
// ğŸ”‘ ç¼ºç‚¹ï¼šå‡çº§ä¸å¯é€†ï¼ˆä¸ä¼šé™çº§ï¼‰
```

---

### ğŸ“Œ 6. hashtableï¼ˆå­—å…¸ï¼‰ï¼ˆâ­â­â­â­â­ï¼‰

#### ç»“æ„
```cpp
typedef struct dictht {
    dictEntry** table;      // å“ˆå¸Œè¡¨æ•°ç»„
    unsigned long size;     // å“ˆå¸Œè¡¨å¤§å°
    unsigned long sizemask; // æ©ç ï¼ˆsize - 1ï¼‰
    unsigned long used;     // å·²æœ‰èŠ‚ç‚¹æ•°é‡
} dictht;

typedef struct dict {
    dictht ht[2];    // ğŸ”‘ ä¸¤ä¸ªå“ˆå¸Œè¡¨ï¼ˆç”¨äºrehashï¼‰
    long rehashidx;  // rehashè¿›åº¦ï¼ˆ-1è¡¨ç¤ºæœªè¿›è¡Œï¼‰
} dict;
```

#### æ¸è¿›å¼rehashï¼ˆâ­â­â­â­â­ é‡ç‚¹ï¼‰
```cpp
// ğŸ”¥ é¢è¯•é«˜é¢‘ï¼šä¸ºä»€ä¹ˆè¦æ¸è¿›å¼rehashï¼Ÿ
// ç­”ï¼šä¸€æ¬¡æ€§rehashå¯èƒ½å¯¼è‡´Redisé˜»å¡ï¼ˆç™¾ä¸‡çº§keyï¼‰

// æ­¥éª¤ï¼š
// 1. ä¸ºht[1]åˆ†é…ç©ºé—´ï¼ˆé€šå¸¸æ˜¯ht[0]çš„2å€ï¼‰
// 2. rehashidx = 0ï¼Œå¼€å§‹æ¸è¿›å¼è¿ç§»
// 3. æ¯æ¬¡æ“ä½œæ—¶ï¼Œé¡ºå¸¦è¿ç§»ht[0].table[rehashidx]çš„æ‰€æœ‰keyåˆ°ht[1]
// 4. rehashidx++ï¼Œç»§ç»­ä¸‹ä¸€ä¸ªæ¡¶
// 5. å…¨éƒ¨è¿ç§»å®Œæˆï¼Œht[0]å’Œht[1]äº¤æ¢ï¼Œrehashidx = -1

// ğŸ”‘ æœŸé—´çš„æ“ä½œï¼š
// - æŸ¥æ‰¾ï¼šå…ˆæŸ¥ht[0]ï¼Œæ²¡æ‰¾åˆ°å†æŸ¥ht[1]
// - æ’å…¥ï¼šç›´æ¥æ’å…¥ht[1]
// - åˆ é™¤ï¼šä¸¤ä¸ªè¡¨éƒ½æŸ¥
```

---

### ğŸ“Œ 7. Rediså¯¹è±¡ç¼–ç ï¼ˆâ­â­â­â­â­ é‡ç‚¹ï¼‰

#### Stringç¼–ç 
```cpp
// 1. intï¼šæ•´æ•°å€¼ï¼Œä¸”èƒ½ç”¨longè¡¨ç¤º
SET count 123  â†’ encoding: int

// 2. embstrï¼šå­—ç¬¦ä¸²â‰¤44å­—èŠ‚ï¼ˆRedis 3.2+ï¼‰
SET msg "hello"  â†’ encoding: embstrï¼ˆä¸€æ¬¡åˆ†é…ï¼‰

// 3. rawï¼šå­—ç¬¦ä¸²>44å­—èŠ‚
SET text "very long string..."  â†’ encoding: rawï¼ˆä¸¤æ¬¡åˆ†é…ï¼‰
```

#### Listç¼–ç 
```cpp
// quicklistï¼ˆRedis 3.2+ï¼‰
// é…ç½®ï¼š
// list-max-ziplist-size -2   # æ¯ä¸ªziplistä¸è¶…è¿‡8KB
// list-compress-depth 1       # é¦–å°¾ä¸å‹ç¼©
```

#### Hashç¼–ç 
```cpp
// 1. ziplistï¼ˆåŒæ—¶æ»¡è¶³ï¼‰ï¼š
//    - æ‰€æœ‰key-valueé•¿åº¦ < 64å­—èŠ‚
//    - é”®å€¼å¯¹æ•°é‡ < 512
HSET user name "Alice"  â†’ ziplist

// 2. hashtableï¼ˆä»»ä¸€æ¡ä»¶ï¼‰ï¼š
//    - æœ‰key-value > 64å­—èŠ‚
//    - é”®å€¼å¯¹æ•°é‡ >= 512
```

#### Setç¼–ç 
```cpp
// 1. intsetï¼ˆåŒæ—¶æ»¡è¶³ï¼‰ï¼š
//    - æ‰€æœ‰å…ƒç´ éƒ½æ˜¯æ•´æ•°
//    - å…ƒç´ æ•°é‡ <= 512
SADD nums 1 2 3  â†’ intset

// 2. hashtableï¼š
//    - æœ‰éæ•´æ•°å…ƒç´ 
//    - å…ƒç´ æ•°é‡ > 512
```

#### ZSetç¼–ç 
```cpp
// 1. ziplistï¼ˆåŒæ—¶æ»¡è¶³ï¼‰ï¼š
//    - å…ƒç´ æ•°é‡ < 128
//    - æ‰€æœ‰memberé•¿åº¦ < 64å­—èŠ‚
ZADD rank 90 "Alice"  â†’ ziplist

// 2. skiplist + hashtableï¼š
//    - å…ƒç´ æ•°é‡ >= 128
//    - æœ‰member > 64å­—èŠ‚

// ğŸ”‘ ä¸ºä»€ä¹ˆåŒæ—¶ç”¨skiplistå’Œhashtableï¼Ÿ
// - skiplistï¼šæ”¯æŒèŒƒå›´æŸ¥è¯¢ã€æŒ‰scoreæ’åº
// - hashtableï¼šO(1)æŸ¥æ‰¾memberâ†’score
```

---

### ğŸ”¥ Redisé«˜é¢‘é¢è¯•é¢˜

#### 1ï¸âƒ£ ä¸ºä»€ä¹ˆRediså¿«ï¼Ÿ
1. **çº¯å†…å­˜æ“ä½œ**
2. **å•çº¿ç¨‹**ï¼šé¿å…ä¸Šä¸‹æ–‡åˆ‡æ¢å’Œç«äº‰
3. **IOå¤šè·¯å¤ç”¨**ï¼šepoll
4. **é«˜æ•ˆçš„æ•°æ®ç»“æ„**ï¼šSDSã€skiplistã€ziplist

#### 2ï¸âƒ£ è·³è¡¨vsçº¢é»‘æ ‘ï¼Œä¸ºä»€ä¹ˆé€‰è·³è¡¨ï¼Ÿ
- å®ç°ç®€å•
- èŒƒå›´æŸ¥è¯¢é«˜æ•ˆ
- æ˜“äºå®ç°æ— é”å¹¶å‘

#### 3ï¸âƒ£ ziplistçš„è¿é”æ›´æ–°é—®é¢˜ï¼Ÿ
- æ’å…¥å¯¼è‡´åç»­èŠ‚ç‚¹prevlenä»1å­—èŠ‚â†’5å­—èŠ‚
- æœ€åO(nÂ²)ï¼Œä½†å®é™…å¾ˆå°‘å‘ç”Ÿ
- Redis 5.0å¼•å…¥listpacké¿å…æ­¤é—®é¢˜

#### 4ï¸âƒ£ æ¸è¿›å¼rehashçš„å¥½å¤„ï¼Ÿ
- é¿å…ä¸€æ¬¡æ€§rehashå¯¼è‡´Redisé˜»å¡
- åˆ†æ‘Šåˆ°æ¯æ¬¡æ“ä½œä¸­ï¼Œå¯¹ç”¨æˆ·é€æ˜

---

## ğŸ“Œ æ€»ç»“ï¼šæ•°æ®ç»“æ„é€‰æ‹©æŒ‡å—

### æ—¶é—´å¤æ‚åº¦å¯¹æ¯”

| æ•°æ®ç»“æ„ | æŸ¥æ‰¾ | æ’å…¥ | åˆ é™¤ | ç©ºé—´ |
|---------|------|------|------|------|
| **æ•°ç»„** | O(1) | O(n) | O(n) | O(n) |
| **é“¾è¡¨** | O(n) | O(1)* | O(1)* | O(n) |
| **å“ˆå¸Œè¡¨** | O(1) | O(1) | O(1) | O(n) |
| **BST** | O(logn) | O(logn) | O(logn) | O(n) |
| **AVL** | O(logn) | O(logn) | O(logn) | O(n) |
| **çº¢é»‘æ ‘** | O(logn) | O(logn) | O(logn) | O(n) |
| **B+æ ‘** | O(logn) | O(logn) | O(logn) | O(n) |
| **å †** | O(n) | O(logn) | O(logn) | O(n) |
| **è·³è¡¨** | O(logn) | O(logn) | O(logn) | O(n) |

*å·²çŸ¥ä½ç½®

### åœºæ™¯é€‰æ‹©

**éœ€è¦å¿«é€ŸæŸ¥æ‰¾ï¼Ÿ**
- æœ‰åº â†’ çº¢é»‘æ ‘ï¼ˆmap/setï¼‰
- æ— åº â†’ å“ˆå¸Œè¡¨ï¼ˆunordered_mapï¼‰

**éœ€è¦èŒƒå›´æŸ¥è¯¢ï¼Ÿ**
- å†…å­˜ â†’ è·³è¡¨ã€çº¢é»‘æ ‘
- ç£ç›˜ â†’ B+æ ‘

**éœ€è¦æ‰¾æœ€å€¼ï¼Ÿ**
- å †ï¼ˆpriority_queueï¼‰

**éœ€è¦FIFO/LIFOï¼Ÿ**
- æ ˆ/é˜Ÿåˆ—

**éœ€è¦é¢‘ç¹æ’å…¥åˆ é™¤ï¼Ÿ**
- é“¾è¡¨ã€çº¢é»‘æ ‘

**æ•°æ®åº“ç´¢å¼•ï¼Ÿ**
- B+æ ‘ï¼ˆç£ç›˜å‹å¥½ã€èŒƒå›´æŸ¥è¯¢ï¼‰
