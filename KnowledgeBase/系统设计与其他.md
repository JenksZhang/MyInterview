# 系统设计与其他

## 系统设计

### 让你设计一个限流的系统怎么做？ 令牌桶

- 限流就是防止流量无限大 把下游服务打挂，用各种办法来限制流量
- 分为单机限流，分布式限流。
- 打点限流、漏桶算法、令牌桶算法https://www.cnblogs.com/xuwc/p/9123078.html
- PID控制算法。这个可以参考一下 https://github.com/Fakeroneyk/testPID.git

### 让你设计一个延时任务系统怎么做

- 说了两个方案，一个是使用 redis 的 ZSET 来实现，考虑分片来抗高并发，使用 redis 的持久化来实现落地，使用 redis 的哨兵实现故障转移。 一个是使用时间轮的方法。

### 服务发现是怎么实现的

### 熔断是怎么实现的

- 熔断是指流量过大或者失败率太高，不往下游继续打流量的操作
- 主要就是由监控上述两个指标进行熔断器的关闭
- 熔断器关闭后有自动唤醒功能，以下就是其中一种实现

- Completer 上传失败、超时、成功的task数量到redis中
- Submmiter起一个协程定时获取redis中的失败、超时、成功的task的数量

```Plain Text
失败/超时 数量 failed_num
总的渲染结束的任务数量 total_num
失败率阈值 failed_rate_max
从redis获取数据周期T
间隔时间内  failed_rate = △failed_num/△total_num
failed_rate >= failed_max 时熔断器打开
直到连续3次 failed_rate < failed_max 时 熔断器关闭
```

- 上送任务前获取熔断器状态，如果熔断器打开，则停止上送3T时间后尝试重新获取熔断器状态，直到熔断器关闭则停止熔断

### 负载均衡算法有哪些

- 轮询，加权轮询，随机，加权随机

### id生成器怎么实现的，如何实现全局递增

## 中间件

### MQ

#### 优点
- 解耦
- 冗余
- 扩展性
- 灵活性和峰值处理能力
- 可恢复性
- 顺序保证
- 缓冲
- 异步通信

![MQ示意图](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZkMTBlYjZmNzk3ZDEwMjE3ZWM1ZjExZWE1ZmE0MDNfMGVkd2JoQXU4VWdhYW1YUTB2aFhZcEQxMmlWd0ZpTWJfVG9rZW46Ym94Y250bDRBUWpYc2xJWlRkWEhGQVIxVVdUXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

### MQ的幂等是怎么去保证的？怎么防止消息重复消费？

- version版本号保证幂等，重复消费可以有主键ID，Redis缓存等等..

### zookeeper

- 选举Leader
- 同步数据
- 选举Leader过程中算法有很多，但要达到的选举标准是一致的
- Leader要具有最高的执行ID，类似root权限
- 集群中大多数的机器得到响应并接受选出的Leader

### 项目中用到了什么技术点呢？

- 分布式、平行扩展、可伸缩、动态扩容、Rector模式

## protobuf

### protobuf

#### 压缩原理
- Varint 32 8位表示7位，高位代表后面的长度
- Varint 确实是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint ，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。
- 300 如果用 int32 表示，需要 4 个字节，现在用 Varint 表示，只需要 2 个字节了。缩小了一半！

## 缓存

### 为什么要使用缓存？ 缓存的更新策略有哪些？怎么进行选择？

- 减少数据库压力。https://blog.csdn.net/jsjwk/article/details/81775880

### 如果更新db成功但是更新缓存失败引发数据不一致，怎么解决？

- 删除缓存，如果删除失败，就用消息队列中间件去持续删除，直到成功

### 缓存的穿透/雪崩问题：

- 缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。
- 缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
- 缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。
- 缓存雪崩的原因及解决方案
- ​        1、缓存大面积失效
- ​        解决方案：避免缓存设置相近的有效期；为有效期增加随机值；统一规划有效期，失效时间均匀分布。
- ​        2、对热点数据持续高并发
- ​        解决方案：使用互斥锁：jvm锁机制；分布式锁机制
- ​        3、有效期本身的缺陷
- ​        解决方案：缓存永不过期，异步更新。
- ​        优点：不阻塞线程，用户体验好，不会出现雪崩效应。
- ​        缺点：不保证一致性，代码复杂度增大（每个value值都要维护异步更新代码），容易堆积垃圾数据。
- 空查询导致的缓存穿透可以使用布隆过滤器，或者从db里查询到空数据时在缓存中设置空数据，并设置过期时间
- 缓存击穿:SETNX。用锁来阻挡查询，锁完后load db，返回后写缓存，删锁

### 为什么不将事务直接发给消息队列

## Mysql ORM数据结构是什么

## 交换机路由器区别 工作方式

## 正则表达式

- 正则不会？？？？？？？？？
