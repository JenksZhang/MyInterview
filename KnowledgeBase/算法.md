# ç®—æ³•

## æ’åºç®—æ³•

## ğŸ“Œ å¿«é€Ÿæ’åºï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **åˆ†æ²»** | **åŸåœ°æ’åº** | **ä¸ç¨³å®š** | **å¹³å‡O(nlogn)** | **æœ€åO(nÂ²)** | **ä¸‰è·¯å¿«æ’** | **éšæœºpivot** | **partitionåˆ†åŒº**

### âœ… æ ¸å¿ƒæ€æƒ³

1. **é€‰æ‹©åŸºå‡†å€¼ï¼ˆpivotï¼‰**
2. **åˆ†åŒºï¼ˆpartitionï¼‰**ï¼šå°äºpivotçš„æ”¾å·¦è¾¹,å¤§äºçš„æ”¾å³è¾¹
3. **é€’å½’å¤„ç†**å·¦å³å­æ•°ç»„

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**æ ‡å‡†ç‰ˆæœ¬ï¼š**
```cpp
void quickSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;  // ğŸ”‘ å…³é”®ç‚¹1ï¼šé€’å½’ç»ˆæ­¢æ¡ä»¶

    // ğŸ”‘ å…³é”®ç‚¹2ï¼šé€‰æ‹©pivot
    int pivot = arr[left];
    int i = left, j = right;

    // ğŸ”‘ å…³é”®ç‚¹3ï¼šåˆ†åŒºè¿‡ç¨‹
    while (i < j) {
        // ä»å³å‘å·¦æ‰¾ç¬¬ä¸€ä¸ªå°äºpivotçš„
        while (i < j && arr[j] >= pivot) j--;
        if (i < j) arr[i++] = arr[j];

        // ä»å·¦å‘å³æ‰¾ç¬¬ä¸€ä¸ªå¤§äºpivotçš„
        while (i < j && arr[i] < pivot) i++;
        if (i < j) arr[j--] = arr[i];
    }

    // ğŸ”‘ å…³é”®ç‚¹4ï¼šæ”¾ç½®pivot
    arr[i] = pivot;

    // é€’å½’å¤„ç†å·¦å³å­æ•°ç»„
    quickSort(arr, left, i - 1);
    quickSort(arr, i + 1, right);
}
```

**ä¼˜åŒ–ç‰ˆæœ¬ï¼ˆä¸‰è·¯å¿«æ’ï¼‰ï¼š** â­â­â­â­
```cpp
// å¤„ç†å¤§é‡é‡å¤å…ƒç´ çš„æƒ…å†µ
void quickSort3Way(vector<int>& arr, int L, int R) {
    if (L >= R) return;

    // ğŸ”‘ éšæœºåŒ–pivoté¿å…æœ€åæƒ…å†µ
    int randIdx = L + rand() % (R - L + 1);
    swap(arr[randIdx], arr[R]);

    int pivot = arr[R];
    int lt = L - 1;      // arr[L..lt] < pivot
    int gt = R;          // arr[gt..R] > pivot
    int i = L;           // arr[lt+1..i-1] == pivot

    while (i < gt) {
        if (arr[i] < pivot) {
            swap(arr[++lt], arr[i++]);
        } else if (arr[i] > pivot) {
            swap(arr[i], arr[--gt]);
        } else {
            i++;  // ç­‰äºpivotçš„å…ƒç´ 
        }
    }
    swap(arr[gt], arr[R]);

    quickSort3Way(arr, L, lt);
    quickSort3Way(arr, gt + 1, R);
}
```

### ğŸ“Š å¤æ‚åº¦åˆ†æ

| æƒ…å†µ | æ—¶é—´å¤æ‚åº¦ | åŸå›  |
|------|-----------|------|
| **æœ€å¥½** | O(nlogn) | æ¯æ¬¡pivotéƒ½åœ¨ä¸­é—´ä½ç½® |
| **å¹³å‡** | O(nlogn) | éšæœºpivotæœŸæœ› |
| **æœ€å** | O(nÂ²) | æ•°ç»„å·²æ’åºä¸”é€‰é¦–/å°¾å…ƒç´ ä¸ºpivot |
| **ç©ºé—´** | O(logn) | é€’å½’æ ˆæ·±åº¦ï¼ˆå¹³å‡ï¼‰ |

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ å¦‚ä½•é¿å…æœ€åæƒ…å†µï¼Ÿï¼ˆâ­â­â­â­â­ é«˜é¢‘ï¼‰

**æ–¹æ³•1ï¼šéšæœºé€‰æ‹©pivot**
```cpp
int randIdx = left + rand() % (right - left + 1);
swap(arr[left], arr[randIdx]);
```

**æ–¹æ³•2ï¼šä¸‰æ•°å–ä¸­**
```cpp
int mid = left + (right - left) / 2;
// å–arr[left], arr[mid], arr[right]çš„ä¸­ä½æ•°ä½œä¸ºpivot
```

**æ–¹æ³•3ï¼šå°æ•°ç»„ç”¨æ’å…¥æ’åº**
```cpp
if (right - left < 10) {
    insertionSort(arr, left, right);
    return;
}
```

#### 2ï¸âƒ£ å¿«æ’æ˜¯ç¨³å®šæ’åºå—ï¼Ÿï¼ˆâ­â­â­â­ï¼‰

âŒ **ä¸ç¨³å®š**

```
åä¾‹ï¼š[3a, 2, 3b]  é€‰3aä½œä¸ºpivot
åˆ†åŒºåï¼š[2, 3b, 3a]
â†’ 3aå’Œ3bçš„ç›¸å¯¹é¡ºåºæ”¹å˜äº†
```

#### 3ï¸âƒ£ ä¸ºä»€ä¹ˆå¿«æ’æ¯”å½’å¹¶æ’åºå¸¸ç”¨ï¼Ÿï¼ˆâ­â­â­â­ï¼‰

**å¿«æ’çš„ä¼˜åŠ¿ï¼š**
1. **åŸåœ°æ’åº**ï¼šç©ºé—´O(logn) vs å½’å¹¶O(n)
2. **ç¼“å­˜å‹å¥½**ï¼šé¡ºåºè®¿é—®æ•°ç»„ï¼Œå±€éƒ¨æ€§å¥½
3. **å¸¸æ•°å› å­å°**ï¼šå®é™…è¿è¡Œæ›´å¿«

**å½’å¹¶çš„ä¼˜åŠ¿ï¼š**
- âœ… ç¨³å®šæ’åº
- âœ… æœ€åæƒ…å†µä¹Ÿæ˜¯O(nlogn)
- âœ… é€‚åˆé“¾è¡¨æ’åº

#### 4ï¸âƒ£ ä»€ä¹ˆæ—¶å€™æ—¶é—´å¤æ‚åº¦æœ€é«˜ï¼Ÿï¼ˆâ­â­â­â­ï¼‰

**O(nÂ²) æœ€åæƒ…å†µï¼š**
```
æƒ…å†µ1ï¼šæ•°ç»„å·²æ’åºï¼Œé€‰é¦–/å°¾å…ƒç´ ä¸ºpivot
[1, 2, 3, 4, 5]  æ¯æ¬¡åªèƒ½æ’é™¤ä¸€ä¸ªå…ƒç´ 

æƒ…å†µ2ï¼šæ•°ç»„é€†åº
[5, 4, 3, 2, 1]

æƒ…å†µ3ï¼šæ‰€æœ‰å…ƒç´ ç›¸åŒ
[3, 3, 3, 3, 3]  æ ‡å‡†å¿«æ’é€€åŒ–ï¼Œä¸‰è·¯å¿«æ’O(n)
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€åŸºç¡€å›ç­”ã€‘
å¿«é€Ÿæ’åºæ˜¯åˆ†æ²»ç®—æ³•ï¼š
1. é€‰æ‹©åŸºå‡†å€¼pivot
2. å°†å°äºpivotçš„æ”¾å·¦è¾¹ï¼Œå¤§äºçš„æ”¾å³è¾¹ï¼ˆpartitionï¼‰
3. é€’å½’å¤„ç†å·¦å³å­æ•°ç»„

å¹³å‡æ—¶é—´O(nlogn)ï¼Œæœ€åO(nÂ²)
ç©ºé—´O(logn)ï¼ˆé€’å½’æ ˆï¼‰
ä¸æ˜¯ç¨³å®šæ’åº

ã€ä¼˜åŒ–æ‰‹æ®µã€‘
1. éšæœºé€‰æ‹©pivoté¿å…æœ€åæƒ…å†µ
2. ä¸‰è·¯å¿«æ’å¤„ç†å¤§é‡é‡å¤å…ƒç´ 
3. å°æ•°ç»„åˆ‡æ¢åˆ°æ’å…¥æ’åº

ã€è¿½é—®-ç¨³å®šæ€§ã€‘
ä¸ç¨³å®šï¼Œä¾‹å¦‚[3a,2,3b]é€‰3aä¸ºpivotï¼Œåˆ†åŒºåå¯èƒ½å˜æˆ[2,3b,3a]

ã€è¿½é—®-æœ€åæƒ…å†µã€‘
æ•°ç»„å·²æ’åºæ—¶ï¼Œå¦‚æœé€‰é¦–/å°¾å…ƒç´ ä¸ºpivotï¼Œæ¯æ¬¡åªèƒ½æ’é™¤ä¸€ä¸ªå…ƒç´ 
è§£å†³ï¼šéšæœºé€‰æ‹©pivotæˆ–ä¸‰æ•°å–ä¸­
```

---

## ğŸ“Œ å½’å¹¶æ’åºï¼ˆâ­â­â­â­ é«˜é¢‘ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **åˆ†æ²»** | **ç¨³å®šæ’åº** | **O(nlogn)** | **ç©ºé—´O(n)** | **é€‚åˆé“¾è¡¨** | **å¤–éƒ¨æ’åº**

### âœ… æ ¸å¿ƒæ€æƒ³

1. **åˆ†è§£**ï¼šå°†æ•°ç»„åˆ†æˆä¸¤åŠ
2. **é€’å½’**ï¼šå¯¹ä¸¤åŠåˆ†åˆ«æ’åº
3. **åˆå¹¶**ï¼šå°†ä¸¤ä¸ªæœ‰åºæ•°ç»„åˆå¹¶æˆä¸€ä¸ª

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

```cpp
void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;

    // ğŸ”‘ å…³é”®ç‚¹ï¼šåˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {  // <= ä¿è¯ç¨³å®šæ€§
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }

    // å¤„ç†å‰©ä½™å…ƒç´ 
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];

    // æ‹·è´å›åŸæ•°ç»„
    for (int p = 0; p < k; p++) {
        arr[left + p] = temp[p];
    }
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;

    int mid = left + (right - left) / 2;  // é˜²æ­¢æº¢å‡º
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
```

### ğŸ“Š å¤æ‚åº¦åˆ†æ

| æƒ…å†µ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ |
|------|-----------|-----------|
| **æœ€å¥½** | O(nlogn) | O(n) |
| **å¹³å‡** | O(nlogn) | O(n) |
| **æœ€å** | O(nlogn) | O(n) |

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ ä¸ºä»€ä¹ˆå½’å¹¶æ’åºæ˜¯ç¨³å®šçš„ï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```cpp
// ğŸ”‘ å…³é”®åœ¨äºåˆå¹¶æ—¶çš„æ¯”è¾ƒ
if (arr[i] <= arr[j]) {  // ä½¿ç”¨ <=
    temp[k++] = arr[i++];
}

è¯´æ˜ï¼šç›¸ç­‰å…ƒç´ æ—¶ï¼Œå·¦è¾¹çš„å…ˆæ”¾å…¥ï¼Œä¿æŒç›¸å¯¹é¡ºåº
```

#### 2ï¸âƒ£ å½’å¹¶æ’åºé€‚åˆä»€ä¹ˆåœºæ™¯ï¼Ÿï¼ˆâ­â­â­â­ï¼‰

**é€‚åˆåœºæ™¯ï¼š**
1. **é“¾è¡¨æ’åº**ï¼šä¸éœ€è¦éšæœºè®¿é—®ï¼ŒO(1)ç©ºé—´
2. **å¤–éƒ¨æ’åº**ï¼šå¤§æ–‡ä»¶æ’åºï¼Œé¡ºåºIOå‹å¥½
3. **éœ€è¦ç¨³å®šæ’åº**
4. **æœ€åæƒ…å†µä¹Ÿè¦O(nlogn)**

---

## ğŸ“Œ å †æ’åºï¼ˆâ­â­â­â­ é«˜é¢‘ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **å¤§æ ¹å †** | **å°æ ¹å †** | **heapify** | **O(nlogn)** | **O(1)ç©ºé—´** | **ä¸ç¨³å®š** | **TopKé—®é¢˜**

### âœ… æ ¸å¿ƒæ€æƒ³

1. **å»ºå †**ï¼šå°†æ•°ç»„æ„å»ºæˆå¤§æ ¹å †
2. **æ’åº**ï¼šä¾æ¬¡å–å‡ºå †é¡¶å…ƒç´ ï¼ˆæœ€å¤§å€¼ï¼‰
3. **è°ƒæ•´**ï¼šæ¯æ¬¡å–å‡ºåé‡æ–°heapify

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­ é‡è¦ï¼‰

```cpp
void heapify(vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    // ğŸ”‘ æ‰¾å‡ºiã€leftã€rightä¸­çš„æœ€å¤§å€¼
    if (left < n && arr[left] > arr[largest])
        largest = left;
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // å¦‚æœæœ€å¤§å€¼ä¸æ˜¯iï¼Œäº¤æ¢å¹¶ç»§ç»­heapify
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(vector<int>& arr) {
    int n = arr.size();

    // ğŸ”‘ å»ºå †ï¼šä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // ğŸ”‘ æ’åºï¼šä¾æ¬¡å–å‡ºå †é¡¶
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);  // å †é¡¶ä¸æœ«å°¾äº¤æ¢
        heapify(arr, i, 0);    // é‡æ–°heapify
    }
}
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ TopKé—®é¢˜æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

**æ‰¾æœ€å¤§çš„Kä¸ªï¼šç”¨å°æ ¹å †ï¼ˆsize=Kï¼‰**
```cpp
priority_queue<int, vector<int>, greater<int>> minHeap;

for (int num : arr) {
    if (minHeap.size() < K) {
        minHeap.push(num);
    } else if (num > minHeap.top()) {
        minHeap.pop();
        minHeap.push(num);
    }
}
```

**æ—¶é—´å¤æ‚åº¦ï¼šO(nlogK)**

---

## æŸ¥æ‰¾ç®—æ³•

## ğŸ“Œ äºŒåˆ†æŸ¥æ‰¾ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **æœ‰åºæ•°ç»„** | **O(logn)** | **left+rightæº¢å‡º** | **å·¦å³è¾¹ç•Œ** | **æ—‹è½¬æ•°ç»„**

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**åŸºç¡€ç‰ˆæœ¬ï¼š**
```cpp
int binarySearch(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;  // ğŸ”‘ é˜²æ­¢æº¢å‡º

        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;  // æœªæ‰¾åˆ°
}
```

**æŸ¥æ‰¾å·¦è¾¹ç•Œï¼ˆç¬¬ä¸€ä¸ª>=targetçš„ä½ç½®ï¼‰ï¼š**
```cpp
int lowerBound(vector<int>& arr, int target) {
    int left = 0, right = arr.size();

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;  // ğŸ”‘ æ”¶ç¼©å³è¾¹ç•Œ
        }
    }

    return left;
}
```

**æŸ¥æ‰¾å³è¾¹ç•Œï¼ˆæœ€åä¸€ä¸ª<=targetçš„ä½ç½®ï¼‰ï¼š**
```cpp
int upperBound(vector<int>& arr, int target) {
    int left = 0, right = arr.size();

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] <= target) {
            left = mid + 1;  // ğŸ”‘ æ”¶ç¼©å·¦è¾¹ç•Œ
        } else {
            right = mid;
        }
    }

    return left - 1;
}
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ midä¸ºä»€ä¹ˆè¦ç”¨left+(right-left)/2ï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```
âŒ é”™è¯¯ï¼šmid = (left + right) / 2
é—®é¢˜ï¼šleft + right å¯èƒ½æº¢å‡ºï¼ˆintæœ€å¤§å€¼ï¼‰

âœ… æ­£ç¡®ï¼šmid = left + (right - left) / 2
ç­‰ä»·äºï¼šmid = (left + right) / 2ï¼Œä½†ä¸ä¼šæº¢å‡º
```

#### 2ï¸âƒ£ whileæ¡ä»¶ç”¨<è¿˜æ˜¯<=ï¼Ÿï¼ˆâ­â­â­â­â­ é«˜é¢‘ï¼‰

```
left <= rightï¼šæœç´¢åŒºé—´[left, right]
- ç»ˆæ­¢æ¡ä»¶ï¼šleft > right
- é€‚ç”¨ï¼šåŸºç¡€äºŒåˆ†æŸ¥æ‰¾

left < rightï¼šæœç´¢åŒºé—´[left, right)
- ç»ˆæ­¢æ¡ä»¶ï¼šleft == right
- é€‚ç”¨ï¼šæŸ¥æ‰¾è¾¹ç•Œ
```

#### 3ï¸âƒ£ æ—‹è½¬æ•°ç»„çš„äºŒåˆ†æŸ¥æ‰¾ï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```cpp
// [4,5,6,7,0,1,2] æŸ¥æ‰¾target
int search(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;

        // ğŸ”‘ åˆ¤æ–­å“ªä¸€åŠæ˜¯æœ‰åºçš„
        if (nums[left] <= nums[mid]) {  // å·¦åŠæœ‰åº
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {  // å³åŠæœ‰åº
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1;
}
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€åŸºç¡€å›ç­”ã€‘
äºŒåˆ†æŸ¥æ‰¾ç”¨äºåœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ ï¼š
1. æ¯æ¬¡æ¯”è¾ƒä¸­é—´å…ƒç´ 
2. æ ¹æ®å¤§å°å…³ç³»ç¼©å°æœç´¢èŒƒå›´
3. æ—¶é—´å¤æ‚åº¦O(logn)

ã€å…³é”®ç‚¹ã€‘
- midè®¡ç®—è¦é˜²æ­¢æº¢å‡º
- åŒºé—´å®šä¹‰è¦æ¸…æ™°ï¼š[left,right]è¿˜æ˜¯[left,right)
- è¾¹ç•Œæ¡ä»¶è¦å°å¿ƒ

ã€å˜ç§ã€‘
- æŸ¥æ‰¾å·¦è¾¹ç•Œï¼šç¬¬ä¸€ä¸ª>=targetçš„ä½ç½®
- æŸ¥æ‰¾å³è¾¹ç•Œï¼šæœ€åä¸€ä¸ª<=targetçš„ä½ç½®
- æ—‹è½¬æ•°ç»„ï¼šåˆ¤æ–­å“ªä¸€åŠæœ‰åº
```

---

## ğŸ“Œ LRUç¼“å­˜ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **å“ˆå¸Œè¡¨** | **åŒå‘é“¾è¡¨** | **O(1)æ—¶é—´** | **get/put** | **æ·˜æ±°ç­–ç•¥**

### âœ… æ ¸å¿ƒæ€æƒ³

**æ•°æ®ç»“æ„ç»„åˆï¼š**
- **å“ˆå¸Œè¡¨**ï¼šO(1)æŸ¥æ‰¾
- **åŒå‘é“¾è¡¨**ï¼šO(1)åˆ é™¤å’Œç§»åŠ¨

**æ·˜æ±°ç­–ç•¥ï¼š**
- æœ€è¿‘ä½¿ç”¨çš„åœ¨é“¾è¡¨å¤´
- æœ€ä¹…æœªä½¿ç”¨çš„åœ¨é“¾è¡¨å°¾
- å®¹é‡æ»¡æ—¶åˆ é™¤é“¾è¡¨å°¾

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

```cpp
class LRUCache {
private:
    struct Node {
        int key, value;
        Node *prev, *next;
        Node(int k = 0, int v = 0) : key(k), value(v), prev(nullptr), next(nullptr) {}
    };

    int capacity;
    Node *head, *tail;  // è™šæ‹Ÿå¤´å°¾èŠ‚ç‚¹
    unordered_map<int, Node*> cache;

    void removeNode(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void addToHead(Node* node) {
        node->next = head->next;
        node->prev = head;
        head->next->prev = node;
        head->next = node;
    }

    void moveToHead(Node* node) {
        removeNode(node);
        addToHead(node);
    }

    Node* removeTail() {
        Node* node = tail->prev;
        removeNode(node);
        return node;
    }

public:
    LRUCache(int capacity) : capacity(capacity) {
        head = new Node();
        tail = new Node();
        head->next = tail;
        tail->prev = head;
    }

    int get(int key) {
        if (cache.find(key) == cache.end()) {
            return -1;
        }
        Node* node = cache[key];
        moveToHead(node);  // ğŸ”‘ æ›´æ–°ä¸ºæœ€è¿‘ä½¿ç”¨
        return node->value;
    }

    void put(int key, int value) {
        if (cache.find(key) != cache.end()) {
            // ğŸ”‘ å·²å­˜åœ¨ï¼Œæ›´æ–°å€¼å¹¶ç§»åˆ°å¤´éƒ¨
            Node* node = cache[key];
            node->value = value;
            moveToHead(node);
        } else {
            // ğŸ”‘ ä¸å­˜åœ¨ï¼Œæ–°å»ºèŠ‚ç‚¹
            Node* node = new Node(key, value);
            cache[key] = node;
            addToHead(node);

            if (cache.size() > capacity) {
                // ğŸ”‘ è¶…å‡ºå®¹é‡ï¼Œåˆ é™¤å°¾éƒ¨
                Node* removed = removeTail();
                cache.erase(removed->key);
                delete removed;
            }
        }
    }
};
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ ä¸ºä»€ä¹ˆç”¨åŒå‘é“¾è¡¨è€Œä¸æ˜¯å•å‘é“¾è¡¨ï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```
éœ€æ±‚ï¼šO(1)æ—¶é—´åˆ é™¤èŠ‚ç‚¹

å•å‘é“¾è¡¨ï¼šéœ€è¦æ‰¾åˆ°å‰é©±èŠ‚ç‚¹ï¼ŒO(n)æ—¶é—´
åŒå‘é“¾è¡¨ï¼šç›´æ¥è®¿é—®prevï¼ŒO(1)æ—¶é—´

ç»“è®ºï¼šå¿…é¡»ç”¨åŒå‘é“¾è¡¨
```

#### 2ï¸âƒ£ ä¸ºä»€ä¹ˆéœ€è¦å“ˆå¸Œè¡¨ï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```
éœ€æ±‚ï¼šO(1)æ—¶é—´æŸ¥æ‰¾èŠ‚ç‚¹

åªç”¨é“¾è¡¨ï¼šéœ€è¦éå†ï¼ŒO(n)æ—¶é—´
å“ˆå¸Œè¡¨ï¼šç›´æ¥å®šä½èŠ‚ç‚¹ï¼ŒO(1)æ—¶é—´

ç»“è®ºï¼šå“ˆå¸Œè¡¨+é“¾è¡¨ç»„åˆä½¿ç”¨
```

#### 3ï¸âƒ£ è™šæ‹Ÿå¤´å°¾èŠ‚ç‚¹çš„ä½œç”¨ï¼Ÿï¼ˆâ­â­â­ï¼‰

```
ä½œç”¨ï¼šç®€åŒ–è¾¹ç•Œå¤„ç†

æ— è™šæ‹ŸèŠ‚ç‚¹ï¼šéœ€è¦åˆ¤æ–­head/tailæ˜¯å¦ä¸ºç©º
æœ‰è™šæ‹ŸèŠ‚ç‚¹ï¼šç»Ÿä¸€å¤„ç†ï¼Œæ— éœ€ç‰¹æ®Šåˆ¤æ–­

ğŸ”‘ å·¥ç¨‹å®è·µå¸¸ç”¨æŠ€å·§
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€æ•°æ®ç»“æ„ã€‘
å“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨

ã€åŸç†ã€‘
1. å“ˆå¸Œè¡¨ï¼škey â†’ é“¾è¡¨èŠ‚ç‚¹ï¼ŒO(1)æŸ¥æ‰¾
2. åŒå‘é“¾è¡¨ï¼šç»´æŠ¤ä½¿ç”¨é¡ºåº
   - å¤´éƒ¨ï¼šæœ€è¿‘ä½¿ç”¨
   - å°¾éƒ¨ï¼šæœ€ä¹…æœªä½¿ç”¨

ã€æ“ä½œã€‘
- getï¼šæŸ¥æ‰¾åç§»åˆ°å¤´éƒ¨
- putï¼šå­˜åœ¨åˆ™æ›´æ–°å¹¶ç§»åˆ°å¤´éƒ¨ï¼Œä¸å­˜åœ¨åˆ™æ’å…¥å¤´éƒ¨
- å®¹é‡æ»¡ï¼šåˆ é™¤å°¾éƒ¨èŠ‚ç‚¹

ã€æ—¶é—´å¤æ‚åº¦ã€‘
æ‰€æœ‰æ“ä½œO(1)
```

---

## ğŸ“Œ KMPç®—æ³•ï¼ˆâ­â­â­â­ é«˜é¢‘ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **nextæ•°ç»„** | **å‰ç¼€åç¼€** | **O(n+m)** | **å­—ç¬¦ä¸²åŒ¹é…** | **éƒ¨åˆ†åŒ¹é…è¡¨**

### âœ… æ ¸å¿ƒæ€æƒ³

**é¿å…é‡å¤æ¯”è¾ƒï¼š**
- æš´åŠ›ç®—æ³•ï¼šæ¯æ¬¡å¤±é…ä»å¤´å¼€å§‹ï¼ŒO(nÃ—m)
- KMPï¼šåˆ©ç”¨å·²åŒ¹é…ä¿¡æ¯ï¼Œè·³è¿‡é‡å¤æ¯”è¾ƒï¼ŒO(n+m)

**nextæ•°ç»„ï¼š**
- `next[i]`ï¼šæ¨¡å¼ä¸²`[0...i]`çš„æœ€é•¿ç›¸ç­‰å‰åç¼€é•¿åº¦
- å¤±é…æ—¶ï¼Œæ¨¡å¼ä¸²è·³åˆ°`next[j]`ä½ç½®ç»§ç»­åŒ¹é…

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­ é‡è¦ï¼‰

```cpp
// æ„å»ºnextæ•°ç»„
vector<int> getNext(string pattern) {
    int m = pattern.size();
    vector<int> next(m, 0);

    int j = 0;  // å‰ç¼€æœ«å°¾
    for (int i = 1; i < m; i++) {  // åç¼€æœ«å°¾
        // ğŸ”‘ å›é€€åˆ°èƒ½åŒ¹é…çš„ä½ç½®
        while (j > 0 && pattern[i] != pattern[j]) {
            j = next[j - 1];
        }

        if (pattern[i] == pattern[j]) {
            j++;
        }

        next[i] = j;
    }

    return next;
}

// KMPåŒ¹é…
int KMP(string text, string pattern) {
    int n = text.size(), m = pattern.size();
    vector<int> next = getNext(pattern);

    int j = 0;  // patternçš„åŒ¹é…ä½ç½®
    for (int i = 0; i < n; i++) {  // textçš„å½“å‰ä½ç½®
        // ğŸ”‘ å¤±é…æ—¶å›é€€
        while (j > 0 && text[i] != pattern[j]) {
            j = next[j - 1];
        }

        if (text[i] == pattern[j]) {
            j++;
        }

        // ğŸ”‘ å®Œå…¨åŒ¹é…
        if (j == m) {
            return i - m + 1;  // è¿”å›åŒ¹é…èµ·å§‹ä½ç½®
        }
    }

    return -1;  // æœªæ‰¾åˆ°
}
```

### ğŸ“Š å¤æ‚åº¦åˆ†æ

| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | è¯´æ˜ |
|------|-----------|------|
| **æ„å»ºnext** | O(m) | mä¸ºæ¨¡å¼ä¸²é•¿åº¦ |
| **åŒ¹é…** | O(n) | nä¸ºæ–‡æœ¬ä¸²é•¿åº¦ |
| **æ€»ä½“** | O(n+m) | æ¯”æš´åŠ›O(nÃ—m)å¿« |

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ nextæ•°ç»„æ€ä¹ˆç†è§£ï¼Ÿï¼ˆâ­â­â­â­â­ æ ¸å¿ƒï¼‰

```
ä¾‹å­ï¼špattern = "ABABC"

i    0  1  2  3  4
p    A  B  A  B  C
next 0  0  1  2  0

next[3] = 2ï¼š
- pattern[0..3] = "ABAB"
- æœ€é•¿ç›¸ç­‰å‰åç¼€ï¼šAB (é•¿åº¦2)
- å¤±é…æ—¶è·³åˆ°ä½ç½®2ç»§ç»­åŒ¹é…
```

#### 2ï¸âƒ£ ä¸ºä»€ä¹ˆKMPå¿«ï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```
æš´åŠ›ç®—æ³•ï¼š
text:    ABABCABAA
pattern: ABABD
         â†“å¤±é…
é‡æ–°åŒ¹é…: ABABD  (ä»å¤´å¼€å§‹)

KMPï¼š
å¤±é…æ—¶åˆ©ç”¨å·²åŒ¹é…çš„ä¿¡æ¯
è·³è¿‡ä¸å¯èƒ½åŒ¹é…çš„ä½ç½®
ä¸å›é€€textæŒ‡é’ˆ
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€åŸºæœ¬åŸç†ã€‘
KMPæ˜¯é«˜æ•ˆçš„å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•ï¼š
- æ—¶é—´å¤æ‚åº¦O(n+m)
- å…³é”®æ˜¯nextæ•°ç»„

ã€nextæ•°ç»„ã€‘
next[i]è¡¨ç¤ºpattern[0..i]çš„æœ€é•¿ç›¸ç­‰å‰åç¼€é•¿åº¦
å¤±é…æ—¶ï¼Œåˆ©ç”¨nextæ•°ç»„è·³è¿‡é‡å¤æ¯”è¾ƒ

ã€ä¼˜åŠ¿ã€‘
ç›¸æ¯”æš´åŠ›ç®—æ³•O(nÃ—m)ï¼ŒKMPåªéœ€O(n+m)
ä¸éœ€è¦å›é€€textæŒ‡é’ˆï¼Œä¸€æ¬¡æ‰«æå®Œæˆ
```

---

## åŠ¨æ€è§„åˆ’

## ğŸ“Œ 0-1èƒŒåŒ…ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **åŠ¨æ€è§„åˆ’** | **äºŒç»´dp** | **ä¸€ç»´ä¼˜åŒ–** | **é€†åºéå†** | **çŠ¶æ€è½¬ç§»**

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**äºŒç»´dpç‰ˆæœ¬ï¼š**
```cpp
int knapsack(vector<int>& weights, vector<int>& values, int capacity) {
    int n = weights.size();
    // dp[i][j]ï¼šå‰iä¸ªç‰©å“ï¼Œå®¹é‡jçš„æœ€å¤§ä»·å€¼
    vector<vector<int>> dp(n + 1, vector<int>(capacity + 1, 0));

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= capacity; j++) {
            // ğŸ”‘ ä¸é€‰ç¬¬iä¸ªç‰©å“
            dp[i][j] = dp[i-1][j];

            // ğŸ”‘ é€‰ç¬¬iä¸ªç‰©å“ï¼ˆå¦‚æœæ”¾å¾—ä¸‹ï¼‰
            if (j >= weights[i-1]) {
                dp[i][j] = max(dp[i][j],
                              dp[i-1][j-weights[i-1]] + values[i-1]);
            }
        }
    }

    return dp[n][capacity];
}
```

**ä¸€ç»´ä¼˜åŒ–ç‰ˆæœ¬ï¼š** â­â­â­â­â­
```cpp
int knapsack(vector<int>& weights, vector<int>& values, int capacity) {
    vector<int> dp(capacity + 1, 0);

    for (int i = 0; i < weights.size(); i++) {
        // ğŸ”‘ å…³é”®ï¼šé€†åºéå†ï¼Œé˜²æ­¢é‡å¤ä½¿ç”¨
        for (int j = capacity; j >= weights[i]; j--) {
            dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);
        }
    }

    return dp[capacity];
}
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ ä¸ºä»€ä¹ˆä¸€ç»´ä¼˜åŒ–è¦é€†åºéå†ï¼Ÿï¼ˆâ­â­â­â­â­ é«˜é¢‘ï¼‰

```
æ­£åºéå†ï¼š
dp[3] = max(dp[3], dp[3-w] + v)
â†‘ å·²ç»è¢«æ›´æ–°è¿‡ï¼Œç”¨çš„æ˜¯å½“å‰è½®çš„å€¼
âŒ åŒä¸€ç‰©å“è¢«ä½¿ç”¨å¤šæ¬¡ï¼ˆå®Œå…¨èƒŒåŒ…ï¼‰

é€†åºéå†ï¼š
dp[3] = max(dp[3], dp[3-w] + v)
â†‘ è¿˜æœªæ›´æ–°ï¼Œç”¨çš„æ˜¯ä¸Šä¸€è½®çš„å€¼
âœ… æ¯ä¸ªç‰©å“åªç”¨ä¸€æ¬¡ï¼ˆ0-1èƒŒåŒ…ï¼‰
```

---

## ğŸ“Œ æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆâ­â­â­â­ é«˜é¢‘ï¼‰

### ğŸ’» ä»£ç å®ç°

```cpp
int longestCommonSubsequence(string text1, string text2) {
    int m = text1.size(), n = text2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i-1] == text2[j-1]) {
                // ğŸ”‘ å­—ç¬¦ç›¸åŒï¼Œé•¿åº¦+1
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                // ğŸ”‘ å­—ç¬¦ä¸åŒï¼Œå–è¾ƒå¤§å€¼
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }

    return dp[m][n];
}
```

---

## é“¾è¡¨

## ğŸ“Œ åè½¬é“¾è¡¨ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**è¿­ä»£ç‰ˆæœ¬ï¼š**
```cpp
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;

    while (curr != nullptr) {
        ListNode* next = curr->next;  // ğŸ”‘ ä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        curr->next = prev;            // ğŸ”‘ åè½¬æŒ‡é’ˆ
        prev = curr;                  // ğŸ”‘ ç§»åŠ¨prev
        curr = next;                  // ğŸ”‘ ç§»åŠ¨curr
    }

    return prev;
}
```

**é€’å½’ç‰ˆæœ¬ï¼š**
```cpp
ListNode* reverseList(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    ListNode* newHead = reverseList(head->next);
    // ğŸ”‘ å…³é”®ï¼šè®©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘è‡ªå·±
    head->next->next = head;
    head->next = nullptr;

    return newHead;
}
```

---

## ğŸ“Œ é“¾è¡¨ç¯æ£€æµ‹ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **å¿«æ…¢æŒ‡é’ˆ** | **Floydåˆ¤åœˆ** | **å…¥å£èŠ‚ç‚¹** | **æ•°å­¦æ¨å¯¼**

### ğŸ’» ä»£ç å®ç°

**æ£€æµ‹æ˜¯å¦æœ‰ç¯ï¼š**
```cpp
bool hasCycle(ListNode *head) {
    if (head == nullptr) return false;

    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;        // ğŸ”‘ æ…¢æŒ‡é’ˆèµ°1æ­¥
        fast = fast->next->next;  // ğŸ”‘ å¿«æŒ‡é’ˆèµ°2æ­¥

        if (slow == fast) {
            return true;  // ç›¸é‡è¯´æ˜æœ‰ç¯
        }
    }

    return false;
}
```

**æ‰¾ç¯çš„å…¥å£èŠ‚ç‚¹ï¼š** â­â­â­â­â­
```cpp
ListNode *detectCycle(ListNode *head) {
    ListNode* slow = head;
    ListNode* fast = head;

    // ğŸ”‘ ç¬¬ä¸€æ­¥ï¼šåˆ¤æ–­æ˜¯å¦æœ‰ç¯
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast) {
            // ğŸ”‘ ç¬¬äºŒæ­¥ï¼šæ‰¾å…¥å£èŠ‚ç‚¹
            ListNode* ptr = head;
            while (ptr != slow) {
                ptr = ptr->next;
                slow = slow->next;
            }
            return ptr;
        }
    }

    return nullptr;
}
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ ä¸ºä»€ä¹ˆå¿«æ…¢æŒ‡é’ˆèƒ½æ£€æµ‹ç¯ï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```
ã€è¯æ˜ã€‘
å¦‚æœæœ‰ç¯ï¼Œå¿«æŒ‡é’ˆæœ€ç»ˆä¼šè¿½ä¸Šæ…¢æŒ‡é’ˆ

è®¾æ…¢æŒ‡é’ˆè¿›å…¥ç¯æ—¶ï¼Œå¿«æŒ‡é’ˆåœ¨ç¯ä¸­ä½ç½®ä¸ºk
æ¯æ¬¡ç§»åŠ¨ï¼Œå¿«æŒ‡é’ˆç›¸å¯¹æ…¢æŒ‡é’ˆå‰è¿›1æ­¥
ç¯é•¿ä¸ºLï¼Œæœ€å¤šLæ­¥å†…å¿…å®šç›¸é‡
```

#### 2ï¸âƒ£ ä¸ºä»€ä¹ˆèƒ½æ‰¾åˆ°å…¥å£èŠ‚ç‚¹ï¼Ÿï¼ˆâ­â­â­â­â­ æ•°å­¦æ¨å¯¼ï¼‰

```
è®¾ï¼š
- èµ·ç‚¹åˆ°å…¥å£è·ç¦»ï¼ša
- å…¥å£åˆ°ç›¸é‡ç‚¹è·ç¦»ï¼šb
- ç›¸é‡ç‚¹åˆ°å…¥å£è·ç¦»ï¼šc

æ…¢æŒ‡é’ˆèµ°ï¼ša + b
å¿«æŒ‡é’ˆèµ°ï¼ša + b + c + b = a + 2b + c

å¿«æŒ‡é’ˆæ˜¯æ…¢æŒ‡é’ˆçš„2å€ï¼š
2(a + b) = a + 2b + c
â†’ a = c

ğŸ”‘ ç»“è®ºï¼šèµ·ç‚¹åˆ°å…¥å£ = ç›¸é‡ç‚¹åˆ°å…¥å£
æ‰€ä»¥ä»èµ·ç‚¹å’Œç›¸é‡ç‚¹åŒæ—¶èµ°ï¼Œä¼šåœ¨å…¥å£ç›¸é‡
```

---

## äºŒå‰æ ‘

## ğŸ“Œ äºŒå‰æ ‘éå†ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**å‰åºéå†ï¼ˆæ ¹-å·¦-å³ï¼‰ï¼š**
```cpp
// é€’å½’
void preorder(TreeNode* root, vector<int>& res) {
    if (!root) return;
    res.push_back(root->val);
    preorder(root->left, res);
    preorder(root->right, res);
}

// è¿­ä»£
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> stk;

    while (root || !stk.empty()) {
        while (root) {
            res.push_back(root->val);  // ğŸ”‘ è®¿é—®æ ¹
            stk.push(root);
            root = root->left;         // ğŸ”‘ éå†å·¦å­æ ‘
        }
        root = stk.top(); stk.pop();
        root = root->right;            // ğŸ”‘ éå†å³å­æ ‘
    }

    return res;
}
```

**ä¸­åºéå†ï¼ˆå·¦-æ ¹-å³ï¼‰ï¼š**
```cpp
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> stk;

    while (root || !stk.empty()) {
        while (root) {
            stk.push(root);
            root = root->left;
        }
        root = stk.top(); stk.pop();
        res.push_back(root->val);  // ğŸ”‘ è®¿é—®æ ¹
        root = root->right;
    }

    return res;
}
```

**ååºéå†ï¼ˆå·¦-å³-æ ¹ï¼‰ï¼š**
```cpp
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> stk;
    TreeNode* prev = nullptr;

    while (root || !stk.empty()) {
        while (root) {
            stk.push(root);
            root = root->left;
        }
        root = stk.top();
        // ğŸ”‘ å³å­æ ‘ä¸ºç©ºæˆ–å·²è®¿é—®ï¼Œæ‰è®¿é—®æ ¹
        if (!root->right || root->right == prev) {
            res.push_back(root->val);
            stk.pop();
            prev = root;
            root = nullptr;
        } else {
            root = root->right;
        }
    }

    return res;
}
```

**å±‚åºéå†ï¼š**
```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> res;
    if (!root) return res;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int size = q.size();
        vector<int> level;

        // ğŸ”‘ éå†å½“å‰å±‚
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front(); q.pop();
            level.push_back(node->val);

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }

        res.push_back(level);
    }

    return res;
}
```

---

## ğŸ“Œ äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ï¼ˆâ­â­â­â­ï¼‰

```cpp
int maxDepth(TreeNode* root) {
    if (!root) return 0;
    return max(maxDepth(root->left), maxDepth(root->right)) + 1;
}
```

---

## ğŸ“Œ äºŒå‰æœç´¢æ ‘ç¬¬Kå°å…ƒç´ ï¼ˆâ­â­â­â­ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **ä¸­åºéå†** | **æœ‰åº** | **BSTæ€§è´¨**

```cpp
void inorder(TreeNode* root, int& k, int& res) {
    if (!root) return;

    inorder(root->left, k, res);

    if (--k == 0) {
        res = root->val;
        return;
    }

    inorder(root->right, k, res);
}

int kthSmallest(TreeNode* root, int k) {
    int res = 0;
    inorder(root, k, res);
    return res;
}
```

---

## åŒæŒ‡é’ˆ/æ»‘åŠ¨çª—å£

## ğŸ“Œ æ»‘åŠ¨çª—å£æœ€å¤§å€¼ï¼ˆâ­â­â­â­ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **å•è°ƒé˜Ÿåˆ—** | **åŒç«¯é˜Ÿåˆ—** | **O(n)** | **ç»´æŠ¤æœ€å¤§å€¼**

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> res;
    deque<int> dq;  // ğŸ”‘ å­˜å‚¨ä¸‹æ ‡ï¼Œç»´æŠ¤å•è°ƒé€’å‡

    for (int i = 0; i < nums.size(); i++) {
        // ğŸ”‘ ç§»é™¤çª—å£å¤–çš„å…ƒç´ 
        if (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }

        // ğŸ”‘ ç»´æŠ¤å•è°ƒé€’å‡
        while (!dq.empty() && nums[dq.back()] < nums[i]) {
            dq.pop_back();
        }

        dq.push_back(i);

        // ğŸ”‘ çª—å£å½¢æˆåè®°å½•ç»“æœ
        if (i >= k - 1) {
            res.push_back(nums[dq.front()]);
        }
    }

    return res;
}
```

---

## ğŸ“Œ æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²ï¼ˆâ­â­â­â­â­ï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **æ»‘åŠ¨çª—å£** | **å“ˆå¸Œè¡¨** | **åŒæŒ‡é’ˆ** | **O(n)**

```cpp
int lengthOfLongestSubstring(string s) {
    unordered_map<char, int> window;
    int left = 0, right = 0;
    int maxLen = 0;

    while (right < s.size()) {
        char c = s[right];
        right++;
        window[c]++;

        // ğŸ”‘ å‡ºç°é‡å¤å­—ç¬¦ï¼Œæ”¶ç¼©çª—å£
        while (window[c] > 1) {
            char d = s[left];
            left++;
            window[d]--;
        }

        maxLen = max(maxLen, right - left);
    }

    return maxLen;
}
```

---

## å…¶ä»–é«˜é¢‘é¢˜ç›®

### ğŸ“Œ ä¸¤ä¸ªæ’åºæ•°ç»„æ‰¾ä¸­ä½æ•°ï¼ˆâ­â­â­â­ï¼‰

```cpp
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int m = nums1.size(), n = nums2.size();
    if (m > n) return findMedianSortedArrays(nums2, nums1);

    int left = 0, right = m;
    int half = (m + n + 1) / 2;

    while (left <= right) {
        int i = (left + right) / 2;
        int j = half - i;

        if (i < m && nums2[j-1] > nums1[i]) {
            left = i + 1;
        } else if (i > 0 && nums1[i-1] > nums2[j]) {
            right = i - 1;
        } else {
            int maxLeft = 0;
            if (i == 0) maxLeft = nums2[j-1];
            else if (j == 0) maxLeft = nums1[i-1];
            else maxLeft = max(nums1[i-1], nums2[j-1]);

            if ((m + n) % 2 == 1) return maxLeft;

            int minRight = 0;
            if (i == m) minRight = nums2[j];
            else if (j == n) minRight = nums1[i];
            else minRight = min(nums1[i], nums2[j]);

            return (maxLeft + minRight) / 2.0;
        }
    }

    return 0.0;
}
```

---

### ğŸ“Œ å•è°ƒæ ˆ - ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ ï¼ˆâ­â­â­â­ï¼‰

```cpp
vector<int> nextGreaterElement(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n, -1);
    stack<int> stk;  // ğŸ”‘ å•è°ƒé€’å‡æ ˆï¼Œå­˜å‚¨ä¸‹æ ‡

    for (int i = 0; i < n; i++) {
        // ğŸ”‘ å½“å‰å…ƒç´ å¤§äºæ ˆé¡¶å…ƒç´ ï¼Œæ‰¾åˆ°ç­”æ¡ˆ
        while (!stk.empty() && nums[i] > nums[stk.top()]) {
            res[stk.top()] = nums[i];
            stk.pop();
        }
        stk.push(i);
    }

    return res;
}
```

---

### ğŸ“Œ 10Gæ•°æ®å»é‡ï¼ˆâ­â­â­â­ï¼‰

**é—®é¢˜ï¼š10Gæ•°æ®ï¼Œæ•°æ®éƒ½æ˜¯int32ä½ï¼Œå†…å­˜åªæœ‰1Gï¼Œå¦‚ä½•å»é™¤é‡å¤å…ƒç´ **

```
ã€è§£å†³æ–¹æ¡ˆï¼šBitmapã€‘

åŸç†ï¼š
- int32èŒƒå›´ï¼š-2^31 ~ 2^31-1ï¼ˆçº¦42äº¿ï¼‰
- éœ€è¦ä½å›¾å¤§å°ï¼š42äº¿ bit = 512MB
- è¿œå°äº1Gå†…å­˜ï¼Œå¯è¡Œ

æ­¥éª¤ï¼š
1. åˆ†é…512MBçš„bitmap
2. éå†æ•°æ®ï¼Œå°†å¯¹åº”ä½ç½®ç½®1
3. å†æ¬¡éå†bitmapï¼Œè¾“å‡ºç½®1çš„æ•°å­—

æ—¶é—´ï¼šO(n)
ç©ºé—´ï¼šO(1)ï¼ˆå›ºå®š512MBï¼‰
```

---

### ğŸ“Œ 25åŒ¹é©¬5èµ›é“æ‰¾å‰3åï¼ˆâ­â­â­ï¼‰

```
ã€æœ€ä¼˜è§£ï¼š7æ¬¡ã€‘

ç¬¬1-5æ¬¡ï¼šåˆ†5ç»„ï¼Œæ¯ç»„5åŒ¹èµ›è·‘
         æ¯ç»„è®°å½•ç¬¬1ã€2ã€3å

ç¬¬6æ¬¡ï¼š  5ä¸ªç»„çš„ç¬¬1åæ¯”èµ›
         å¾—å‡ºæ€»ç¬¬1åA1

ç¬¬7æ¬¡ï¼š  å€™é€‰é©¬æ¯”èµ›ï¼š
         - Aç»„ç¬¬2ã€3å
         - Bç»„ï¼ˆç¬¬6æ¬¡ç¬¬2åï¼‰çš„ç¬¬1ã€2å
         - Cç»„ï¼ˆç¬¬6æ¬¡ç¬¬3åï¼‰çš„ç¬¬1å

         å¾—å‡ºæ€»ç¬¬2ã€3å

ã€å…³é”®ã€‘
æ’é™¤æ³•ï¼šç¬¬1åç¡®å®šåï¼Œå¾ˆå¤šé©¬å¯ä»¥æ’é™¤
```

---

## æ•°ç»„ä¸åŒæŒ‡é’ˆ

## ğŸ“Œ ä¸‰æ•°ä¹‹å’Œï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **åŒæŒ‡é’ˆ** | **æ’åº** | **å»é‡** | **O(nÂ²)** | **å·¦å³å¤¹é€¼**

### âœ… æ ¸å¿ƒæ€æƒ³

**é—®é¢˜ï¼š**åœ¨æ•°ç»„ä¸­æ‰¾å‡ºæ‰€æœ‰å’Œä¸º0çš„ä¸‰å…ƒç»„ `[a, b, c]`

**æ€è·¯ï¼š**
1. **æ’åº**æ•°ç»„
2. **å›ºå®š**ä¸€ä¸ªæ•° `nums[i]`
3. **åŒæŒ‡é’ˆ**åœ¨å‰©ä½™æ•°ç»„ä¸­æ‰¾ `target = -nums[i]`
4. **å»é‡**é¿å…é‡å¤è§£

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

```cpp
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> res;
    int n = nums.size();
    if (n < 3) return res;

    // ğŸ”‘ å…³é”®ç‚¹1ï¼šæ’åº
    sort(nums.begin(), nums.end());

    for (int i = 0; i < n - 2; i++) {
        // ğŸ”‘ å…³é”®ç‚¹2ï¼šå»é‡ï¼ˆç¬¬ä¸€ä¸ªæ•°ï¼‰
        if (i > 0 && nums[i] == nums[i-1]) continue;

        // ğŸ”‘ å‰ªæä¼˜åŒ–
        if (nums[i] > 0) break;  // æœ€å°çš„éƒ½>0ï¼Œä¸å¯èƒ½å’Œä¸º0

        int left = i + 1, right = n - 1;
        int target = -nums[i];

        while (left < right) {
            int sum = nums[left] + nums[right];

            if (sum == target) {
                res.push_back({nums[i], nums[left], nums[right]});

                // ğŸ”‘ å…³é”®ç‚¹3ï¼šå»é‡ï¼ˆç¬¬äºŒã€ä¸‰ä¸ªæ•°ï¼‰
                while (left < right && nums[left] == nums[left+1]) left++;
                while (left < right && nums[right] == nums[right-1]) right--;

                left++;
                right--;
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
    }

    return res;
}
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ ä¸ºä»€ä¹ˆè¦æ’åºï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```
ã€åŸå› ã€‘
1. ä½¿ç”¨åŒæŒ‡é’ˆï¼šéœ€è¦æœ‰åºæ‰èƒ½åˆ¤æ–­ç§»åŠ¨æ–¹å‘
2. æ–¹ä¾¿å»é‡ï¼šç›¸åŒå…ƒç´ ç›¸é‚»ï¼Œå®¹æ˜“è·³è¿‡
3. å‰ªæä¼˜åŒ–ï¼šnums[i]>0å¯ä»¥ç›´æ¥é€€å‡º

ã€ä¸æ’åºçš„æ–¹æ³•ã€‘
ç”¨å“ˆå¸Œè¡¨ï¼Œä½†éš¾ä»¥å»é‡ï¼Œå¤æ‚åº¦ä»æ˜¯O(nÂ²)
```

#### 2ï¸âƒ£ å¦‚ä½•å»é‡ï¼Ÿï¼ˆâ­â­â­â­â­ é«˜é¢‘ï¼‰

```cpp
// âŒ é”™è¯¯ï¼šç”¨setå»é‡
set<vector<int>> seen;  // æ•ˆç‡ä½ï¼Œéœ€è¦é¢å¤–ç©ºé—´

// âœ… æ­£ç¡®ï¼šåˆ©ç”¨æ’åºåçš„ç‰¹æ€§
if (i > 0 && nums[i] == nums[i-1]) continue;  // è·³è¿‡é‡å¤çš„ç¬¬ä¸€ä¸ªæ•°
while (left < right && nums[left] == nums[left+1]) left++;  // è·³è¿‡é‡å¤çš„ç¬¬äºŒä¸ªæ•°
while (left < right && nums[right] == nums[right-1]) right--;  // è·³è¿‡é‡å¤çš„ç¬¬ä¸‰ä¸ªæ•°
```

#### 3ï¸âƒ£ å››æ•°ä¹‹å’Œæ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```cpp
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> res;
    int n = nums.size();
    if (n < 4) return res;

    sort(nums.begin(), nums.end());

    // ğŸ”‘ å¤šä¸€å±‚å¾ªç¯
    for (int i = 0; i < n - 3; i++) {
        if (i > 0 && nums[i] == nums[i-1]) continue;

        for (int j = i + 1; j < n - 2; j++) {
            if (j > i + 1 && nums[j] == nums[j-1]) continue;

            int left = j + 1, right = n - 1;
            long long remain = (long long)target - nums[i] - nums[j];

            while (left < right) {
                int sum = nums[left] + nums[right];
                if (sum == remain) {
                    res.push_back({nums[i], nums[j], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left+1]) left++;
                    while (left < right && nums[right] == nums[right-1]) right--;
                    left++;
                    right--;
                } else if (sum < remain) {
                    left++;
                } else {
                    right--;
                }
            }
        }
    }

    return res;
}
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€åŸºç¡€å›ç­”ã€‘
1. æ’åºæ•°ç»„
2. å›ºå®šä¸€ä¸ªæ•°nums[i]ï¼Œé—®é¢˜è½¬åŒ–ä¸ºä¸¤æ•°ä¹‹å’Œ
3. åŒæŒ‡é’ˆæ‰¾å‰©ä½™ä¸¤ä¸ªæ•°ï¼Œå’Œä¸º-nums[i]
4. å»é‡ï¼šè·³è¿‡é‡å¤çš„å…ƒç´ 

æ—¶é—´O(nÂ²)ï¼Œç©ºé—´O(1)

ã€è¿½é—®-å»é‡ã€‘
åˆ©ç”¨æ’åºåç›¸åŒå…ƒç´ ç›¸é‚»çš„ç‰¹æ€§ï¼š
- ç¬¬ä¸€ä¸ªæ•°ï¼šif (i > 0 && nums[i] == nums[i-1]) continue
- æ‰¾åˆ°è§£åï¼Œè·³è¿‡é‡å¤çš„ç¬¬äºŒã€ä¸‰ä¸ªæ•°

ã€è¿½é—®-å››æ•°ä¹‹å’Œã€‘
å¤šä¸€å±‚å¾ªç¯ï¼Œå›ºå®šä¸¤ä¸ªæ•°ï¼ŒåŒæŒ‡é’ˆæ‰¾å‰©ä½™ä¸¤ä¸ª
æ—¶é—´O(nÂ³)
```

---

## ğŸ“Œ æ¥é›¨æ°´ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **åŒæŒ‡é’ˆ** | **å•è°ƒæ ˆ** | **åŠ¨æ€è§„åˆ’** | **å·¦å³æœ€å¤§å€¼** | **ä¸‰ç§è§£æ³•**

### âœ… æ ¸å¿ƒæ€æƒ³

**é—®é¢˜ï¼š**ç»™å®šé«˜åº¦æ•°ç»„ï¼Œè®¡ç®—èƒ½æ¥å¤šå°‘é›¨æ°´

**å…³é”®ï¼š**æ¯ä¸ªä½ç½®èƒ½æ¥çš„æ°´ = `min(å·¦è¾¹æœ€é«˜, å³è¾¹æœ€é«˜) - å½“å‰é«˜åº¦`

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**æ–¹æ³•1ï¼šåŒæŒ‡é’ˆï¼ˆæœ€ä¼˜ï¼‰** â­â­â­â­â­
```cpp
int trap(vector<int>& height) {
    int n = height.size();
    if (n == 0) return 0;

    int left = 0, right = n - 1;
    int leftMax = 0, rightMax = 0;
    int ans = 0;

    while (left < right) {
        // ğŸ”‘ å…³é”®ï¼šå¤„ç†è¾ƒå°çš„ä¸€è¾¹
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
                leftMax = height[left];  // æ›´æ–°å·¦è¾¹æœ€å¤§å€¼
            } else {
                ans += leftMax - height[left];  // èƒ½æ¥æ°´
            }
            left++;
        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right];  // æ›´æ–°å³è¾¹æœ€å¤§å€¼
            } else {
                ans += rightMax - height[right];  // èƒ½æ¥æ°´
            }
            right--;
        }
    }

    return ans;
}
```

**æ–¹æ³•2ï¼šåŠ¨æ€è§„åˆ’** â­â­â­â­
```cpp
int trap(vector<int>& height) {
    int n = height.size();
    if (n == 0) return 0;

    // ğŸ”‘ é¢„å¤„ç†å·¦å³æœ€å¤§å€¼
    vector<int> leftMax(n), rightMax(n);

    leftMax[0] = height[0];
    for (int i = 1; i < n; i++) {
        leftMax[i] = max(leftMax[i-1], height[i]);
    }

    rightMax[n-1] = height[n-1];
    for (int i = n - 2; i >= 0; i--) {
        rightMax[i] = max(rightMax[i+1], height[i]);
    }

    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans += min(leftMax[i], rightMax[i]) - height[i];
    }

    return ans;
}
```

**æ–¹æ³•3ï¼šå•è°ƒæ ˆ** â­â­â­
```cpp
int trap(vector<int>& height) {
    stack<int> stk;  // å•è°ƒé€’å‡æ ˆï¼Œå­˜ä¸‹æ ‡
    int ans = 0;

    for (int i = 0; i < height.size(); i++) {
        // ğŸ”‘ å½“å‰é«˜åº¦å¤§äºæ ˆé¡¶ï¼Œå½¢æˆå‡¹æ§½
        while (!stk.empty() && height[i] > height[stk.top()]) {
            int top = stk.top();
            stk.pop();

            if (stk.empty()) break;

            int left = stk.top();
            int width = i - left - 1;
            int h = min(height[left], height[i]) - height[top];
            ans += width * h;
        }
        stk.push(i);
    }

    return ans;
}
```

### ğŸ“Š å¤æ‚åº¦å¯¹æ¯”

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | éš¾åº¦ |
|------|-----------|-----------|------|
| **åŒæŒ‡é’ˆ** | O(n) | O(1) | â­â­â­â­â­ æœ€ä¼˜ |
| **åŠ¨æ€è§„åˆ’** | O(n) | O(n) | â­â­â­ æœ€å¥½ç†è§£ |
| **å•è°ƒæ ˆ** | O(n) | O(n) | â­â­â­â­ è¾ƒéš¾ |

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ åŒæŒ‡é’ˆä¸ºä»€ä¹ˆæ­£ç¡®ï¼Ÿï¼ˆâ­â­â­â­â­ æ ¸å¿ƒï¼‰

```
ã€è¯æ˜ã€‘
å‡è®¾ height[left] < height[right]ï¼š
- å·¦è¾¹çš„æ°´ä½ç”± min(leftMax, rightMax) å†³å®š
- å› ä¸º height[left] < height[right]
- æ‰€ä»¥ rightMax >= height[right] > height[left]
- å› æ­¤ min(leftMax, rightMax) = leftMax
- åªéœ€å…³å¿ƒleftMaxï¼Œä¸ç”¨ç®¡rightMaxå…·ä½“å€¼

ğŸ”‘ å…³é”®ï¼šå¤„ç†çŸ®çš„ä¸€è¾¹ï¼Œå…¶æ°´ä½å·²ç¡®å®š
```

#### 2ï¸âƒ£ ä¸‰ç§æ–¹æ³•å¦‚ä½•é€‰æ‹©ï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```
ã€æ¨èã€‘åŒæŒ‡é’ˆ
- ç©ºé—´O(1)
- ä¸€æ¬¡éå†
- æ€è·¯æ¸…æ™°

ã€åœºæ™¯ã€‘
- é¢è¯•ï¼šä¼˜å…ˆè¯´åŒæŒ‡é’ˆ
- ç†è§£å›°éš¾ï¼šå…ˆè¯´DPï¼Œå†ä¼˜åŒ–åˆ°åŒæŒ‡é’ˆ
- å˜ç§é¢˜ï¼šå•è°ƒæ ˆæ›´çµæ´»
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€åŸºç¡€æ€è·¯ã€‘
æ¯ä¸ªä½ç½®èƒ½æ¥çš„æ°´ = min(å·¦è¾¹æœ€é«˜, å³è¾¹æœ€é«˜) - å½“å‰é«˜åº¦

ã€æœ€ä¼˜è§£æ³•ï¼šåŒæŒ‡é’ˆã€‘
1. å·¦å³æŒ‡é’ˆï¼Œç»´æŠ¤leftMaxå’ŒrightMax
2. æ¯”è¾ƒheight[left]å’Œheight[right]
3. å¤„ç†è¾ƒå°çš„ä¸€è¾¹ï¼ˆæ°´ä½å·²ç¡®å®šï¼‰
4. ç§»åŠ¨æŒ‡é’ˆ

æ—¶é—´O(n)ï¼Œç©ºé—´O(1)

ã€å…¶ä»–è§£æ³•ã€‘
- DPï¼šé¢„å¤„ç†å·¦å³æœ€å¤§å€¼ï¼ŒO(n)ç©ºé—´
- å•è°ƒæ ˆï¼šæ¨ªå‘è®¡ç®—æ¯ä¸€å±‚ï¼ŒO(n)ç©ºé—´
```

---

## ğŸ“Œ æœ€å¤§å­æ•°ç»„å’Œï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **Kadaneç®—æ³•** | **åŠ¨æ€è§„åˆ’** | **è´ªå¿ƒ** | **O(n)** | **å‰ç¼€å’Œ**

### âœ… æ ¸å¿ƒæ€æƒ³

**Kadaneç®—æ³•ï¼š**
- å¦‚æœå½“å‰å’Œ `<0`ï¼Œä¸¢å¼ƒï¼Œä»å½“å‰ä½ç½®é‡æ–°å¼€å§‹
- å¦åˆ™ï¼Œç»§ç»­ç´¯åŠ 

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**æ–¹æ³•1ï¼šKadaneç®—æ³•ï¼ˆæœ€ä¼˜ï¼‰**
```cpp
int maxSubArray(vector<int>& nums) {
    int maxSum = nums[0];  // å…¨å±€æœ€å¤§å€¼
    int curSum = 0;        // å½“å‰å’Œ

    for (int num : nums) {
        curSum = max(num, curSum + num);  // ğŸ”‘ å…³é”®ï¼šé€‰æ‹©é‡æ–°å¼€å§‹è¿˜æ˜¯ç»§ç»­
        maxSum = max(maxSum, curSum);     // ğŸ”‘ æ›´æ–°æœ€å¤§å€¼
    }

    return maxSum;
}
```

**æ–¹æ³•2ï¼šåŠ¨æ€è§„åˆ’æ€è·¯**
```cpp
int maxSubArray(vector<int>& nums) {
    int n = nums.size();
    // dp[i]: ä»¥nums[i]ç»“å°¾çš„æœ€å¤§å­æ•°ç»„å’Œ
    vector<int> dp(n);
    dp[0] = nums[0];
    int maxSum = dp[0];

    for (int i = 1; i < n; i++) {
        // ğŸ”‘ çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        dp[i] = max(nums[i], dp[i-1] + nums[i]);
        maxSum = max(maxSum, dp[i]);
    }

    return maxSum;
}
```

**æ–¹æ³•3ï¼šåˆ†æ²»æ³•** â­â­â­
```cpp
int maxSubArray(vector<int>& nums, int left, int right) {
    if (left == right) return nums[left];

    int mid = left + (right - left) / 2;

    // ğŸ”‘ ä¸‰ç§æƒ…å†µ
    int leftMax = maxSubArray(nums, left, mid);        // å·¦åŠéƒ¨åˆ†
    int rightMax = maxSubArray(nums, mid + 1, right);  // å³åŠéƒ¨åˆ†

    // è·¨è¶Šä¸­ç‚¹
    int leftSum = INT_MIN, sum = 0;
    for (int i = mid; i >= left; i--) {
        sum += nums[i];
        leftSum = max(leftSum, sum);
    }

    int rightSum = INT_MIN;
    sum = 0;
    for (int i = mid + 1; i <= right; i++) {
        sum += nums[i];
        rightSum = max(rightSum, sum);
    }

    return max({leftMax, rightMax, leftSum + rightSum});
}
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ Kadaneç®—æ³•çš„åŸç†ï¼Ÿï¼ˆâ­â­â­â­â­ æ ¸å¿ƒï¼‰

```
ã€è´ªå¿ƒæ€æƒ³ã€‘
å¦‚æœå‰é¢çš„ç´¯åŠ å’Œ < 0ï¼Œå¯¹åé¢åªæœ‰è´Ÿè´¡çŒ®
ä¸å¦‚ä¸¢å¼ƒï¼Œä»å½“å‰ä½ç½®é‡æ–°å¼€å§‹

ã€ä¾‹å­ã€‘
[-2, 1, -3, 4, -1, 2, 1, -5, 4]

è¿‡ç¨‹ï¼š
-2 â†’ ä¸¢å¼ƒï¼ˆcurSum < 0ï¼‰
1  â†’ é‡æ–°å¼€å§‹
1-3=-2 â†’ ç»§ç»­
-2+4=2 â†’ ç»§ç»­
...
æœ€å¤§å€¼ï¼š6 ([4,-1,2,1])
```

#### 2ï¸âƒ£ å¦‚æœè¦è¿”å›å­æ•°ç»„æ€ä¹ˆåŠï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```cpp
vector<int> maxSubArray(vector<int>& nums) {
    int maxSum = nums[0];
    int curSum = 0;
    int start = 0, end = 0;  // è®°å½•ä½ç½®
    int tempStart = 0;

    for (int i = 0; i < nums.size(); i++) {
        if (curSum < 0) {
            curSum = nums[i];
            tempStart = i;  // ğŸ”‘ è®°å½•å¯èƒ½çš„èµ·ç‚¹
        } else {
            curSum += nums[i];
        }

        if (curSum > maxSum) {
            maxSum = curSum;
            start = tempStart;
            end = i;  // ğŸ”‘ æ›´æ–°ç»ˆç‚¹
        }
    }

    return vector<int>(nums.begin() + start, nums.begin() + end + 1);
}
```

#### 3ï¸âƒ£ æœ€å¤§å­æ•°ç»„ä¹˜ç§¯æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```cpp
int maxProduct(vector<int>& nums) {
    int maxProd = nums[0];
    int curMax = nums[0];  // ğŸ”‘ å½“å‰æœ€å¤§
    int curMin = nums[0];  // ğŸ”‘ å½“å‰æœ€å°ï¼ˆè´Ÿæ•°å¯èƒ½å˜æœ€å¤§ï¼‰

    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] < 0) {
            swap(curMax, curMin);  // ğŸ”‘ è´Ÿæ•°äº¤æ¢æœ€å¤§æœ€å°
        }

        curMax = max(nums[i], curMax * nums[i]);
        curMin = min(nums[i], curMin * nums[i]);

        maxProd = max(maxProd, curMax);
    }

    return maxProd;
}
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€Kadaneç®—æ³•ã€‘
ç»´æŠ¤å½“å‰å’ŒcurSumï¼š
- å¦‚æœcurSum < 0ï¼Œé‡æ–°å¼€å§‹
- å¦åˆ™ç»§ç»­ç´¯åŠ 
åŒæ—¶ç»´æŠ¤å…¨å±€æœ€å¤§å€¼

æ—¶é—´O(n)ï¼Œç©ºé—´O(1)

ã€DPç†è§£ã€‘
dp[i] = ä»¥nums[i]ç»“å°¾çš„æœ€å¤§å­æ•°ç»„å’Œ
çŠ¶æ€è½¬ç§»ï¼šdp[i] = max(nums[i], dp[i-1] + nums[i])

ã€å˜ç§-æœ€å¤§ä¹˜ç§¯ã€‘
éœ€è¦åŒæ—¶ç»´æŠ¤æœ€å¤§å’Œæœ€å°å€¼
å› ä¸ºè´Ÿæ•°Ã—è´Ÿæ•°å¯èƒ½å˜æœ€å¤§
```

---

## æ·±åº¦ä¼˜å…ˆæœç´¢/å¹¿åº¦ä¼˜å…ˆæœç´¢

## ğŸ“Œ å²›å±¿æ•°é‡ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **DFS** | **BFS** | **å¹¶æŸ¥é›†** | **å›¾éå†** | **ä¸‰ç§è§£æ³•**

### âœ… æ ¸å¿ƒæ€æƒ³

**é—®é¢˜ï¼š**åœ¨äºŒç»´ç½‘æ ¼ä¸­ï¼Œ'1' ä»£è¡¨é™†åœ°ï¼Œ'0' ä»£è¡¨æ°´ï¼Œè®¡ç®—å²›å±¿æ•°é‡

**æ€è·¯ï¼š**
- éå†æ¯ä¸ªä½ç½®
- é‡åˆ° '1' å°± DFS/BFS æ ‡è®°æ•´ä¸ªå²›å±¿
- å²›å±¿æ•°é‡ +1

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**æ–¹æ³•1ï¼šDFSï¼ˆæœ€å¸¸ç”¨ï¼‰**
```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        if (grid.empty()) return 0;

        int m = grid.size(), n = grid[0].size();
        int count = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    count++;  // ğŸ”‘ å‘ç°ä¸€ä¸ªå²›å±¿
                }
            }
        }

        return count;
    }

private:
    void dfs(vector<vector<char>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();

        // ğŸ”‘ è¾¹ç•Œæ£€æŸ¥
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == '0') {
            return;
        }

        grid[i][j] = '0';  // ğŸ”‘ æ ‡è®°ä¸ºå·²è®¿é—®

        // ğŸ”‘ å››ä¸ªæ–¹å‘DFS
        dfs(grid, i - 1, j);  // ä¸Š
        dfs(grid, i + 1, j);  // ä¸‹
        dfs(grid, i, j - 1);  // å·¦
        dfs(grid, i, j + 1);  // å³
    }
};
```

**æ–¹æ³•2ï¼šBFS**
```cpp
int numIslands(vector<vector<char>>& grid) {
    if (grid.empty()) return 0;

    int m = grid.size(), n = grid[0].size();
    int count = 0;
    int dirs[4][2] = {{-1,0}, {1,0}, {0,-1}, {0,1}};

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                count++;
                queue<pair<int,int>> q;
                q.push({i, j});
                grid[i][j] = '0';

                // ğŸ”‘ BFSéå†æ•´ä¸ªå²›å±¿
                while (!q.empty()) {
                    auto [x, y] = q.front();
                    q.pop();

                    for (auto& dir : dirs) {
                        int nx = x + dir[0], ny = y + dir[1];
                        if (nx >= 0 && nx < m && ny >= 0 && ny < n
                            && grid[nx][ny] == '1') {
                            grid[nx][ny] = '0';
                            q.push({nx, ny});
                        }
                    }
                }
            }
        }
    }

    return count;
}
```

**æ–¹æ³•3ï¼šå¹¶æŸ¥é›†** â­â­â­â­
```cpp
class UnionFind {
public:
    vector<int> parent;
    int count;

    UnionFind(vector<vector<char>>& grid) {
        int m = grid.size(), n = grid[0].size();
        parent.resize(m * n);
        count = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    parent[i * n + j] = i * n + j;
                    count++;
                } else {
                    parent[i * n + j] = -1;
                }
            }
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // è·¯å¾„å‹ç¼©
        }
        return parent[x];
    }

    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootX] = rootY;
            count--;  // ğŸ”‘ åˆå¹¶åå²›å±¿æ•°-1
        }
    }
};

int numIslands(vector<vector<char>>& grid) {
    if (grid.empty()) return 0;

    int m = grid.size(), n = grid[0].size();
    UnionFind uf(grid);

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                // ğŸ”‘ å‘å³å’Œå‘ä¸‹åˆå¹¶
                if (i + 1 < m && grid[i+1][j] == '1') {
                    uf.unite(i * n + j, (i+1) * n + j);
                }
                if (j + 1 < n && grid[i][j+1] == '1') {
                    uf.unite(i * n + j, i * n + (j+1));
                }
            }
        }
    }

    return uf.count;
}
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ DFS vs BFS å¦‚ä½•é€‰æ‹©ï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```
ã€DFSã€‘
ä¼˜ç‚¹ï¼šä»£ç ç®€æ´ï¼Œé€’å½’å®ç°
ç¼ºç‚¹ï¼šå¯èƒ½æ ˆæº¢å‡ºï¼ˆå²›å±¿å¾ˆå¤§ï¼‰
é€‚åˆï¼šä¸€èˆ¬æƒ…å†µ

ã€BFSã€‘
ä¼˜ç‚¹ï¼šè¿­ä»£å®ç°ï¼Œä¸ä¼šæ ˆæº¢å‡º
ç¼ºç‚¹ï¼šä»£ç ç¨å¤æ‚ï¼Œéœ€è¦é˜Ÿåˆ—
é€‚åˆï¼šå²›å±¿å¯èƒ½å¾ˆå¤§çš„æƒ…å†µ

ã€å¹¶æŸ¥é›†ã€‘
ä¼˜ç‚¹ï¼šæ”¯æŒåŠ¨æ€åˆå¹¶æŸ¥è¯¢
ç¼ºç‚¹ï¼šä»£ç æœ€å¤æ‚
é€‚åˆï¼šéœ€è¦åŠ¨æ€æ›´æ–°çš„åœºæ™¯
```

#### 2ï¸âƒ£ å²›å±¿æœ€å¤§é¢ç§¯æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```cpp
int maxAreaOfIsland(vector<vector<int>>& grid) {
    int maxArea = 0;
    int m = grid.size(), n = grid[0].size();

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                maxArea = max(maxArea, dfs(grid, i, j));
            }
        }
    }

    return maxArea;
}

int dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size()
        || grid[i][j] == 0) {
        return 0;
    }

    grid[i][j] = 0;  // æ ‡è®°å·²è®¿é—®
    int area = 1;    // ğŸ”‘ å½“å‰æ ¼å­ç®—1

    // ğŸ”‘ ç´¯åŠ å››ä¸ªæ–¹å‘çš„é¢ç§¯
    area += dfs(grid, i-1, j);
    area += dfs(grid, i+1, j);
    area += dfs(grid, i, j-1);
    area += dfs(grid, i, j+1);

    return area;
}
```

#### 3ï¸âƒ£ å²›å±¿å‘¨é•¿æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```cpp
int islandPerimeter(vector<vector<int>>& grid) {
    int perimeter = 0;
    int m = grid.size(), n = grid[0].size();

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                perimeter += 4;  // ğŸ”‘ å…ˆåŠ 4æ¡è¾¹

                // ğŸ”‘ å‡å»ç›¸é‚»çš„è¾¹
                if (i > 0 && grid[i-1][j] == 1) perimeter -= 2;
                if (j > 0 && grid[i][j-1] == 1) perimeter -= 2;
            }
        }
    }

    return perimeter;
}
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€DFSè§£æ³•ã€‘
1. éå†ç½‘æ ¼
2. é‡åˆ°'1'å°±DFSæ ‡è®°æ•´ä¸ªå²›å±¿
3. å²›å±¿æ•°é‡+1

æ—¶é—´O(mÃ—n)ï¼Œç©ºé—´O(mÃ—n)ï¼ˆé€’å½’æ ˆï¼‰

ã€BFSè§£æ³•ã€‘
ç”¨é˜Ÿåˆ—ä»£æ›¿é€’å½’ï¼Œé¿å…æ ˆæº¢å‡º
æ—¶é—´ç©ºé—´å¤æ‚åº¦ç›¸åŒ

ã€å¹¶æŸ¥é›†ã€‘
é€‚åˆåŠ¨æ€åœºæ™¯ï¼ˆæ·»åŠ /åˆ é™¤é™†åœ°ï¼‰
æ”¯æŒåœ¨çº¿æŸ¥è¯¢

ã€å˜ç§ã€‘
- æœ€å¤§é¢ç§¯ï¼šDFSè¿”å›é¢ç§¯
- å‘¨é•¿ï¼šæ¯ä¸ªé™†åœ°+4ï¼Œç›¸é‚»-2
```

---

## åŠ¨æ€è§„åˆ’è¿›é˜¶

## ğŸ“Œ æœ€é•¿é€’å¢å­åºåˆ— LISï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **åŠ¨æ€è§„åˆ’** | **äºŒåˆ†ä¼˜åŒ–** | **O(nlogn)** | **è´ªå¿ƒ+äºŒåˆ†** | **patience sorting**

### âœ… æ ¸å¿ƒæ€æƒ³

**é—®é¢˜ï¼š**æ‰¾å‡ºæ•°ç»„ä¸­æœ€é•¿çš„ä¸¥æ ¼é€’å¢å­åºåˆ—çš„é•¿åº¦

**ä¸¤ç§æ–¹æ³•ï¼š**
1. **DP**ï¼šO(nÂ²)ï¼Œå®¹æ˜“ç†è§£
2. **äºŒåˆ†ä¼˜åŒ–**ï¼šO(nlogn)ï¼Œæœ€ä¼˜è§£

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**æ–¹æ³•1ï¼šåŠ¨æ€è§„åˆ’** â­â­â­â­
```cpp
int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;

    // dp[i]: ä»¥nums[i]ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—é•¿åº¦
    vector<int> dp(n, 1);
    int maxLen = 1;

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            // ğŸ”‘ å¦‚æœnums[i]å¯ä»¥æ¥åœ¨nums[j]åé¢
            if (nums[i] > nums[j]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        maxLen = max(maxLen, dp[i]);
    }

    return maxLen;
}
```

**æ–¹æ³•2ï¼šäºŒåˆ†ä¼˜åŒ–ï¼ˆæœ€ä¼˜ï¼‰** â­â­â­â­â­
```cpp
int lengthOfLIS(vector<int>& nums) {
    vector<int> tails;  // ğŸ”‘ tails[i]ï¼šé•¿åº¦ä¸ºi+1çš„é€’å¢å­åºåˆ—çš„æœ€å°å°¾å…ƒç´ 

    for (int num : nums) {
        // ğŸ”‘ äºŒåˆ†æŸ¥æ‰¾ç¬¬ä¸€ä¸ª>=numçš„ä½ç½®
        int left = 0, right = tails.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (tails[mid] < num) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        // ğŸ”‘ æ›¿æ¢æˆ–è¿½åŠ 
        if (left == tails.size()) {
            tails.push_back(num);
        } else {
            tails[left] = num;
        }
    }

    return tails.size();
}
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ äºŒåˆ†ä¼˜åŒ–çš„åŸç†ï¼Ÿï¼ˆâ­â­â­â­â­ æ ¸å¿ƒï¼‰

```
ã€å…³é”®æ€æƒ³ã€‘
ç»´æŠ¤ä¸€ä¸ªæ•°ç»„tailsï¼š
- tails[i] è¡¨ç¤ºé•¿åº¦ä¸ºi+1çš„é€’å¢å­åºåˆ—çš„æœ€å°å°¾å…ƒç´ 
- ä¿æŒtailsæ•°ç»„é€’å¢

ã€ä¸ºä»€ä¹ˆæ­£ç¡®ã€‘
å¯¹äºç›¸åŒé•¿åº¦çš„é€’å¢å­åºåˆ—ï¼Œå°¾å…ƒç´ è¶Šå°ï¼Œè¶Šå®¹æ˜“æ‰©å±•
æ‰€ä»¥è´ªå¿ƒåœ°ç»´æŠ¤æœ€å°å°¾å…ƒç´ 

ã€ä¾‹å­ã€‘
nums = [10, 9, 2, 5, 3, 7, 101, 18]

è¿‡ç¨‹ï¼š
10: tails = [10]
9:  tails = [9]    (æ›¿æ¢10ï¼Œå› ä¸º9æ›´å°)
2:  tails = [2]    (æ›¿æ¢9)
5:  tails = [2,5]  (è¿½åŠ )
3:  tails = [2,3]  (æ›¿æ¢5)
7:  tails = [2,3,7]
101: tails = [2,3,7,101]
18:  tails = [2,3,7,18]

ç­”æ¡ˆï¼š4
```

#### 2ï¸âƒ£ å¦‚æœè¦è¿”å›å…·ä½“åºåˆ—æ€ä¹ˆåŠï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```cpp
vector<int> findLIS(vector<int>& nums) {
    int n = nums.size();
    vector<int> dp(n, 1);
    vector<int> prev(n, -1);  // ğŸ”‘ è®°å½•å‰é©±

    int maxLen = 1, maxIdx = 0;
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j] && dp[j] + 1 > dp[i]) {
                dp[i] = dp[j] + 1;
                prev[i] = j;  // ğŸ”‘ è®°å½•å‰é©±
            }
        }
        if (dp[i] > maxLen) {
            maxLen = dp[i];
            maxIdx = i;
        }
    }

    // ğŸ”‘ å›æº¯æ„é€ åºåˆ—
    vector<int> res;
    for (int i = maxIdx; i != -1; i = prev[i]) {
        res.push_back(nums[i]);
    }
    reverse(res.begin(), res.end());

    return res;
}
```

#### 3ï¸âƒ£ æœ€é•¿éé€’å‡å­åºåˆ—æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­ï¼‰

```cpp
// åªéœ€å°† < æ”¹ä¸º <=
if (tails[mid] <= num) {  // æ³¨æ„è¿™é‡Œ
    left = mid + 1;
}
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€DPè§£æ³•ã€‘O(nÂ²)
dp[i] = ä»¥nums[i]ç»“å°¾çš„LISé•¿åº¦
çŠ¶æ€è½¬ç§»ï¼šdp[i] = max(dp[j] + 1)ï¼Œå…¶ä¸­j < iä¸”nums[j] < nums[i]

ã€äºŒåˆ†ä¼˜åŒ–ã€‘O(nlogn)
ç»´æŠ¤tailsæ•°ç»„ï¼štails[i]æ˜¯é•¿åº¦i+1çš„é€’å¢å­åºåˆ—çš„æœ€å°å°¾å…ƒç´ 
- å¯¹æ¯ä¸ªnumï¼ŒäºŒåˆ†æŸ¥æ‰¾ç¬¬ä¸€ä¸ª>=numçš„ä½ç½®
- æ›¿æ¢æˆ–è¿½åŠ 

ã€å˜ç§ã€‘
- è¿”å›å…·ä½“åºåˆ—ï¼šDP+è®°å½•å‰é©±
- éé€’å‡ï¼šæ”¹ä¸º<=
- æœ€é•¿é€’å‡ï¼šç¿»è½¬æ•°ç»„æˆ–æ”¹æ¯”è¾ƒæ¡ä»¶
```

---

## å›æº¯ç®—æ³•

## ğŸ“Œ å…¨æ’åˆ—ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **å›æº¯** | **DFS** | **visitedæ•°ç»„** | **å‰ªæ** | **äº¤æ¢æ³•**

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**æ–¹æ³•1ï¼šæ ‡è®°æ³•**
```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        vector<bool> used(nums.size(), false);
        backtrack(nums, path, used, res);
        return res;
    }

private:
    void backtrack(vector<int>& nums, vector<int>& path,
                   vector<bool>& used, vector<vector<int>>& res) {
        // ğŸ”‘ é€’å½’ç»ˆæ­¢
        if (path.size() == nums.size()) {
            res.push_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) continue;  // ğŸ”‘ å·²ä½¿ç”¨ï¼Œè·³è¿‡

            // ğŸ”‘ åšé€‰æ‹©
            path.push_back(nums[i]);
            used[i] = true;

            // ğŸ”‘ é€’å½’
            backtrack(nums, path, used, res);

            // ğŸ”‘ æ’¤é”€é€‰æ‹©
            path.pop_back();
            used[i] = false;
        }
    }
};
```

**æ–¹æ³•2ï¼šäº¤æ¢æ³•** â­â­â­â­
```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        backtrack(nums, 0, res);
        return res;
    }

private:
    void backtrack(vector<int>& nums, int start, vector<vector<int>>& res) {
        if (start == nums.size()) {
            res.push_back(nums);
            return;
        }

        for (int i = start; i < nums.size(); i++) {
            // ğŸ”‘ äº¤æ¢
            swap(nums[start], nums[i]);
            backtrack(nums, start + 1, res);
            // ğŸ”‘ æ¢å¤
            swap(nums[start], nums[i]);
        }
    }
};
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ å…¨æ’åˆ—IIï¼ˆæœ‰é‡å¤å…ƒç´ ï¼‰æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```cpp
vector<vector<int>> permuteUnique(vector<int>& nums) {
    vector<vector<int>> res;
    vector<int> path;
    vector<bool> used(nums.size(), false);

    // ğŸ”‘ æ’åºï¼Œä½¿é‡å¤å…ƒç´ ç›¸é‚»
    sort(nums.begin(), nums.end());

    backtrack(nums, path, used, res);
    return res;
}

void backtrack(vector<int>& nums, vector<int>& path,
               vector<bool>& used, vector<vector<int>>& res) {
    if (path.size() == nums.size()) {
        res.push_back(path);
        return;
    }

    for (int i = 0; i < nums.size(); i++) {
        if (used[i]) continue;

        // ğŸ”‘ å‰ªæï¼šè·³è¿‡é‡å¤
        // å¦‚æœå½“å‰å…ƒç´ å’Œå‰ä¸€ä¸ªç›¸åŒï¼Œä¸”å‰ä¸€ä¸ªæœªä½¿ç”¨ï¼Œè·³è¿‡
        if (i > 0 && nums[i] == nums[i-1] && !used[i-1]) {
            continue;
        }

        path.push_back(nums[i]);
        used[i] = true;
        backtrack(nums, path, used, res);
        path.pop_back();
        used[i] = false;
    }
}
```

#### 2ï¸âƒ£ ç»„åˆé—®é¢˜æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```cpp
// ä»nä¸ªæ•°ä¸­é€‰kä¸ªæ•°çš„æ‰€æœ‰ç»„åˆ
vector<vector<int>> combine(int n, int k) {
    vector<vector<int>> res;
    vector<int> path;
    backtrack(n, k, 1, path, res);
    return res;
}

void backtrack(int n, int k, int start,
               vector<int>& path, vector<vector<int>>& res) {
    if (path.size() == k) {
        res.push_back(path);
        return;
    }

    // ğŸ”‘ å‰ªæï¼šå‰©ä½™å…ƒç´ ä¸å¤Ÿäº†
    for (int i = start; i <= n - (k - path.size()) + 1; i++) {
        path.push_back(i);
        backtrack(n, k, i + 1, path, res);  // ğŸ”‘ i+1é¿å…é‡å¤
        path.pop_back();
    }
}
```

#### 3ï¸âƒ£ å­é›†é—®é¢˜æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```cpp
vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> res;
    vector<int> path;
    backtrack(nums, 0, path, res);
    return res;
}

void backtrack(vector<int>& nums, int start,
               vector<int>& path, vector<vector<int>>& res) {
    // ğŸ”‘ æ¯ä¸ªçŠ¶æ€éƒ½æ˜¯ä¸€ä¸ªå­é›†
    res.push_back(path);

    for (int i = start; i < nums.size(); i++) {
        path.push_back(nums[i]);
        backtrack(nums, i + 1, path, res);
        path.pop_back();
    }
}
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€å›æº¯æ¨¡æ¿ã€‘
void backtrack(å‚æ•°) {
    if (ç»ˆæ­¢æ¡ä»¶) {
        æ”¶é›†ç»“æœ;
        return;
    }

    for (é€‰æ‹© in é€‰æ‹©åˆ—è¡¨) {
        åšé€‰æ‹©;
        backtrack(å‚æ•°);
        æ’¤é”€é€‰æ‹©;
    }
}

ã€ä¸‰å¤§é—®é¢˜ã€‘
1. æ’åˆ—ï¼šéœ€è¦usedæ•°ç»„ï¼Œä»0å¼€å§‹
2. ç»„åˆï¼šä¸éœ€è¦usedï¼Œä»startå¼€å§‹ï¼ˆé¿å…é‡å¤ï¼‰
3. å­é›†ï¼šæ¯ä¸ªçŠ¶æ€éƒ½æ”¶é›†

ã€å»é‡ã€‘
æ’åº + å‰ªææ¡ä»¶ï¼šnums[i] == nums[i-1] && !used[i-1]
```

---

## ğŸ“Œ æ‹¬å·ç”Ÿæˆï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **å›æº¯** | **å‰ªæ** | **left/rightè®¡æ•°** | **åˆæ³•æ€§åˆ¤æ–­**

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

```cpp
vector<string> generateParenthesis(int n) {
    vector<string> res;
    string path;
    backtrack(n, 0, 0, path, res);
    return res;
}

void backtrack(int n, int left, int right, string& path, vector<string>& res) {
    // ğŸ”‘ å‰ªæï¼šå³æ‹¬å·ä¸èƒ½å¤šäºå·¦æ‹¬å·
    if (right > left) return;

    // ğŸ”‘ å‰ªæï¼šæ‹¬å·æ•°é‡è¶…è¿‡n
    if (left > n || right > n) return;

    // ğŸ”‘ ç»ˆæ­¢æ¡ä»¶
    if (left == n && right == n) {
        res.push_back(path);
        return;
    }

    // ğŸ”‘ æ·»åŠ å·¦æ‹¬å·
    path.push_back('(');
    backtrack(n, left + 1, right, path, res);
    path.pop_back();

    // ğŸ”‘ æ·»åŠ å³æ‹¬å·
    path.push_back(')');
    backtrack(n, left, right + 1, path, res);
    path.pop_back();
}
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ æ‹¬å·åŒ¹é…åˆ¤æ–­æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```cpp
bool isValid(string s) {
    stack<char> stk;
    unordered_map<char, char> pairs = {
        {')', '('},
        {']', '['},
        {'}', '{'}
    };

    for (char c : s) {
        if (pairs.count(c)) {  // å³æ‹¬å·
            if (stk.empty() || stk.top() != pairs[c]) {
                return false;
            }
            stk.pop();
        } else {  // å·¦æ‹¬å·
            stk.push(c);
        }
    }

    return stk.empty();
}
```

#### 2ï¸âƒ£ æœ€é•¿æœ‰æ•ˆæ‹¬å·æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```cpp
int longestValidParentheses(string s) {
    int maxLen = 0;
    stack<int> stk;
    stk.push(-1);  // ğŸ”‘ å“¨å…µ

    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(') {
            stk.push(i);
        } else {
            stk.pop();
            if (stk.empty()) {
                stk.push(i);  // æ–°çš„èµ·ç‚¹
            } else {
                maxLen = max(maxLen, i - stk.top());
            }
        }
    }

    return maxLen;
}
```

---

## ğŸ“Œ è‚¡ç¥¨ä¹°å–ç³»åˆ—ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **åŠ¨æ€è§„åˆ’** | **çŠ¶æ€æœº** | **æŒæœ‰/ä¸æŒæœ‰** | **äº¤æ˜“æ¬¡æ•°é™åˆ¶** | **å†·å†»æœŸ**

### âœ… æ ¸å¿ƒæ€æƒ³

**çŠ¶æ€å®šä¹‰ï¼š**
- `dp[i][0]`ï¼šç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦
- `dp[i][1]`ï¼šç¬¬iå¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**ä¹°å–è‚¡ç¥¨Iï¼ˆåªèƒ½äº¤æ˜“1æ¬¡ï¼‰**
```cpp
int maxProfit(vector<int>& prices) {
    int minPrice = INT_MAX;
    int maxProfit = 0;

    for (int price : prices) {
        minPrice = min(minPrice, price);  // ğŸ”‘ è®°å½•æœ€ä½ä»·
        maxProfit = max(maxProfit, price - minPrice);  // ğŸ”‘ æ›´æ–°æœ€å¤§åˆ©æ¶¦
    }

    return maxProfit;
}
```

**ä¹°å–è‚¡ç¥¨IIï¼ˆæ— é™æ¬¡äº¤æ˜“ï¼‰**
```cpp
int maxProfit(vector<int>& prices) {
    int profit = 0;

    for (int i = 1; i < prices.size(); i++) {
        // ğŸ”‘ è´ªå¿ƒï¼šåªè¦æœ‰åˆ©æ¶¦å°±äº¤æ˜“
        if (prices[i] > prices[i-1]) {
            profit += prices[i] - prices[i-1];
        }
    }

    return profit;
}
```

**ä¹°å–è‚¡ç¥¨IIIï¼ˆæœ€å¤š2æ¬¡äº¤æ˜“ï¼‰** â­â­â­â­â­
```cpp
int maxProfit(vector<int>& prices) {
    // ğŸ”‘ å››ä¸ªçŠ¶æ€
    int buy1 = -prices[0], sell1 = 0;
    int buy2 = -prices[0], sell2 = 0;

    for (int i = 1; i < prices.size(); i++) {
        buy1 = max(buy1, -prices[i]);           // ç¬¬ä¸€æ¬¡ä¹°å…¥
        sell1 = max(sell1, buy1 + prices[i]);   // ç¬¬ä¸€æ¬¡å–å‡º
        buy2 = max(buy2, sell1 - prices[i]);    // ç¬¬äºŒæ¬¡ä¹°å…¥
        sell2 = max(sell2, buy2 + prices[i]);   // ç¬¬äºŒæ¬¡å–å‡º
    }

    return sell2;
}
```

**ä¹°å–è‚¡ç¥¨IVï¼ˆæœ€å¤škæ¬¡äº¤æ˜“ï¼‰** â­â­â­â­â­
```cpp
int maxProfit(int k, vector<int>& prices) {
    int n = prices.size();
    if (n == 0 || k == 0) return 0;

    // ğŸ”‘ ä¼˜åŒ–ï¼šk >= n/2ç›¸å½“äºæ— é™æ¬¡äº¤æ˜“
    if (k >= n / 2) {
        int profit = 0;
        for (int i = 1; i < n; i++) {
            profit += max(0, prices[i] - prices[i-1]);
        }
        return profit;
    }

    // dp[i][j][0/1]: ç¬¬iå¤©ï¼Œå®Œæˆjæ¬¡äº¤æ˜“ï¼Œä¸æŒæœ‰/æŒæœ‰
    vector<vector<int>> buy(n, vector<int>(k + 1));
    vector<vector<int>> sell(n, vector<int>(k + 1));

    for (int j = 0; j <= k; j++) {
        buy[0][j] = -prices[0];
        sell[0][j] = 0;
    }

    for (int i = 1; i < n; i++) {
        for (int j = 1; j <= k; j++) {
            buy[i][j] = max(buy[i-1][j], sell[i-1][j-1] - prices[i]);
            sell[i][j] = max(sell[i-1][j], buy[i-1][j] + prices[i]);
        }
    }

    return sell[n-1][k];
}
```

**ä¹°å–è‚¡ç¥¨å«å†·å†»æœŸ** â­â­â­â­
```cpp
int maxProfit(vector<int>& prices) {
    int n = prices.size();
    if (n == 0) return 0;

    // ğŸ”‘ ä¸‰ä¸ªçŠ¶æ€
    int hold = -prices[0];     // æŒæœ‰
    int sold = 0;              // åˆšå–å‡ºï¼ˆå†·å†»ï¼‰
    int rest = 0;              // ä¸æŒæœ‰ä¸”éå†·å†»

    for (int i = 1; i < n; i++) {
        int prevHold = hold, prevSold = sold, prevRest = rest;

        hold = max(prevHold, prevRest - prices[i]);  // ç»§ç»­æŒæœ‰ or ä¹°å…¥
        sold = prevHold + prices[i];                 // å–å‡º
        rest = max(prevRest, prevSold);              // ç»§ç»­ä¼‘æ¯ or å†·å†»ç»“æŸ

        // æˆ–è€…è¿™æ ·å†™æ›´æ¸…æ™°
        int newHold = max(hold, rest - prices[i]);
        int newSold = hold + prices[i];
        int newRest = max(rest, sold);

        hold = newHold;
        sold = newSold;
        rest = newRest;
    }

    return max(sold, rest);
}
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€åŸºæœ¬æ€è·¯ã€‘
å®šä¹‰çŠ¶æ€ï¼šæŒæœ‰/ä¸æŒæœ‰
çŠ¶æ€è½¬ç§»ï¼š
- ä¸æŒæœ‰ = max(ç»§ç»­ä¸æŒæœ‰, ä»Šå¤©å–å‡º)
- æŒæœ‰ = max(ç»§ç»­æŒæœ‰, ä»Šå¤©ä¹°å…¥)

ã€ä¸åŒé™åˆ¶ã€‘
- 1æ¬¡äº¤æ˜“ï¼šè®°å½•æœ€ä½ä»·
- æ— é™æ¬¡ï¼šè´ªå¿ƒï¼Œæœ‰åˆ©æ¶¦å°±äº¤æ˜“
- kæ¬¡äº¤æ˜“ï¼šDPï¼Œè®°å½•äº¤æ˜“æ¬¡æ•°
- å†·å†»æœŸï¼šå¤šä¸€ä¸ª"å†·å†»"çŠ¶æ€
```

---

## é“¾è¡¨ç»å…¸é¢˜

## ğŸ“Œ ä¸¤æ•°ç›¸åŠ ï¼ˆé“¾è¡¨ï¼‰ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **é“¾è¡¨** | **è¿›ä½å¤„ç†** | **è™šæ‹Ÿå¤´èŠ‚ç‚¹** | **è¾¹ç•Œæ¡ä»¶**

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

```cpp
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode* dummy = new ListNode(0);  // ğŸ”‘ è™šæ‹Ÿå¤´èŠ‚ç‚¹
    ListNode* curr = dummy;
    int carry = 0;  // ğŸ”‘ è¿›ä½

    while (l1 || l2 || carry) {
        int sum = carry;

        if (l1) {
            sum += l1->val;
            l1 = l1->next;
        }

        if (l2) {
            sum += l2->val;
            l2 = l2->next;
        }

        carry = sum / 10;  // ğŸ”‘ æ–°çš„è¿›ä½
        curr->next = new ListNode(sum % 10);
        curr = curr->next;
    }

    return dummy->next;
}
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ å¦‚æœæ˜¯é€†åºå­˜å‚¨çš„æ€ä¹ˆåŠï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```cpp
// å…ˆåè½¬é“¾è¡¨ï¼Œå†ç›¸åŠ ï¼Œæœ€åå†åè½¬å›æ¥
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    l1 = reverseList(l1);
    l2 = reverseList(l2);

    ListNode* dummy = new ListNode(0);
    ListNode* curr = dummy;
    int carry = 0;

    while (l1 || l2 || carry) {
        // ... åŒä¸Š
    }

    return reverseList(dummy->next);
}
```

---

## å­—ç¬¦ä¸²

## ğŸ“Œ æœ€é•¿å›æ–‡å­ä¸²ï¼ˆâ­â­â­â­â­ å¿…è€ƒï¼‰

### ğŸ¯ å¾—åˆ†å…³é”®è¯
> **ä¸­å¿ƒæ‰©å±•** | **åŠ¨æ€è§„åˆ’** | **Manacherç®—æ³•** | **O(nÂ²)** | **O(n)**

### ğŸ’» ä»£ç å®ç°ï¼ˆâ­â­â­â­â­ å¿…é¡»ä¼šæ‰‹å†™ï¼‰

**æ–¹æ³•1ï¼šä¸­å¿ƒæ‰©å±•ï¼ˆæœ€å¸¸ç”¨ï¼‰** â­â­â­â­â­
```cpp
string longestPalindrome(string s) {
    int start = 0, maxLen = 0;

    for (int i = 0; i < s.size(); i++) {
        // ğŸ”‘ å¥‡æ•°é•¿åº¦ï¼šä»¥iä¸ºä¸­å¿ƒ
        int len1 = expandAroundCenter(s, i, i);
        // ğŸ”‘ å¶æ•°é•¿åº¦ï¼šä»¥iå’Œi+1ä¸ºä¸­å¿ƒ
        int len2 = expandAroundCenter(s, i, i + 1);

        int len = max(len1, len2);
        if (len > maxLen) {
            maxLen = len;
            start = i - (len - 1) / 2;  // ğŸ”‘ è®¡ç®—èµ·ç‚¹
        }
    }

    return s.substr(start, maxLen);
}

int expandAroundCenter(string& s, int left, int right) {
    while (left >= 0 && right < s.size() && s[left] == s[right]) {
        left--;
        right++;
    }
    return right - left - 1;  // ğŸ”‘ é•¿åº¦
}
```

**æ–¹æ³•2ï¼šåŠ¨æ€è§„åˆ’** â­â­â­â­
```cpp
string longestPalindrome(string s) {
    int n = s.size();
    if (n < 2) return s;

    // dp[i][j]: s[i..j]æ˜¯å¦ä¸ºå›æ–‡
    vector<vector<bool>> dp(n, vector<bool>(n, false));

    int start = 0, maxLen = 1;

    // ğŸ”‘ åˆå§‹åŒ–ï¼šå•ä¸ªå­—ç¬¦
    for (int i = 0; i < n; i++) {
        dp[i][i] = true;
    }

    // ğŸ”‘ æŒ‰é•¿åº¦éå†
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i < n - len + 1; i++) {
            int j = i + len - 1;

            if (s[i] == s[j]) {
                if (len == 2) {
                    dp[i][j] = true;
                } else {
                    dp[i][j] = dp[i+1][j-1];  // ğŸ”‘ çŠ¶æ€è½¬ç§»
                }

                if (dp[i][j] && len > maxLen) {
                    start = i;
                    maxLen = len;
                }
            }
        }
    }

    return s.substr(start, maxLen);
}
```

### ğŸ”¥ é¢è¯•è¿½é—®ç‚¹

#### 1ï¸âƒ£ æœ€é•¿å›æ–‡å­åºåˆ—æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­ï¼‰

```cpp
// ä¸æœ€é•¿å›æ–‡å­ä¸²ä¸åŒï¼Œå­åºåˆ—ä¸è¦æ±‚è¿ç»­
int longestPalindromeSubseq(string s) {
    int n = s.size();
    // dp[i][j]: s[i..j]çš„æœ€é•¿å›æ–‡å­åºåˆ—é•¿åº¦
    vector<vector<int>> dp(n, vector<int>(n, 0));

    for (int i = n - 1; i >= 0; i--) {
        dp[i][i] = 1;
        for (int j = i + 1; j < n; j++) {
            if (s[i] == s[j]) {
                dp[i][j] = dp[i+1][j-1] + 2;
            } else {
                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
            }
        }
    }

    return dp[0][n-1];
}
```

#### 2ï¸âƒ£ ç¼–è¾‘è·ç¦»æ€ä¹ˆåšï¼Ÿï¼ˆâ­â­â­â­â­ï¼‰

```cpp
int minDistance(string word1, string word2) {
    int m = word1.size(), n = word2.size();
    // dp[i][j]: word1[0..i-1]è½¬æ¢ä¸ºword2[0..j-1]çš„æœ€å°‘æ“ä½œæ•°
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    // ğŸ”‘ åˆå§‹åŒ–
    for (int i = 0; i <= m; i++) dp[i][0] = i;  // åˆ é™¤
    for (int j = 0; j <= n; j++) dp[0][j] = j;  // æ’å…¥

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i-1] == word2[j-1]) {
                dp[i][j] = dp[i-1][j-1];  // ä¸éœ€è¦æ“ä½œ
            } else {
                dp[i][j] = min({
                    dp[i-1][j] + 1,    // åˆ é™¤
                    dp[i][j-1] + 1,    // æ’å…¥
                    dp[i-1][j-1] + 1   // æ›¿æ¢
                });
            }
        }
    }

    return dp[m][n];
}
```

### ğŸ“ é¢è¯•å›ç­”æ¨¡æ¿

```
ã€ä¸­å¿ƒæ‰©å±•æ³•ã€‘O(nÂ²)
å¯¹æ¯ä¸ªä½ç½®ï¼Œå‘ä¸¤è¾¹æ‰©å±•
æ³¨æ„å¥‡æ•°é•¿åº¦å’Œå¶æ•°é•¿åº¦

ã€DPæ³•ã€‘O(nÂ²)
dp[i][j] = s[i..j]æ˜¯å¦ä¸ºå›æ–‡
çŠ¶æ€è½¬ç§»ï¼šs[i]==s[j] && dp[i+1][j-1]

ã€Manacherç®—æ³•ã€‘O(n)
å·¥ç¨‹ä¸­å¾ˆå°‘ç”¨ï¼Œé¢è¯•å¯ä»¥æä¸€ä¸‹
```

---

## æ•°æ®ç»“æ„åŸºç¡€

### é“¾è¡¨æ’å…¥æ—¶é—´å¤æ‚åº¦

- **å·²çŸ¥ä½ç½®**ï¼šO(1)
- **æŸ¥æ‰¾ä½ç½®**ï¼šO(n)

### å¹³è¡¡äºŒå‰æ ‘çš„ç‰¹ç‚¹

- æ‰€æœ‰å¶å­èŠ‚ç‚¹é«˜åº¦å·®ä¸è¶…è¿‡1
- æŸ¥æ‰¾æ•ˆç‡ï¼šO(logn)

### ä¸ºä»€ä¹ˆä½¿ç”¨çº¢é»‘æ ‘

- AVLæ ‘çš„è‡ªæ—‹æ¯”è¾ƒè€—æ—¶
- çº¢é»‘æ ‘æŠ˜ä¸­ï¼šè‡ªæ—‹è€—æ—¶ vs æŸ¥è¯¢è€—æ—¶
- **çº¢é»‘æ ‘æ€§è´¨**ï¼šæœ€é•¿é“¾ä¸è¶…è¿‡æœ€çŸ­é“¾çš„2å€
- é€‚åˆé¢‘ç¹æ’å…¥åˆ é™¤çš„åœºæ™¯

---

## ç®—æ³•å‚è€ƒèµ„æº

- https://blog.csdn.net/Code_star_one/article/details/109600676
- LeetCode Hot 100
- å‰‘æŒ‡Offer
