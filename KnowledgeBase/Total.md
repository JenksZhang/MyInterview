。。。

- ####  让你设计一个限流的系统怎么做？ 令牌桶 

  - 限流就是防止流量无限大 把下游服务打挂，用各种办法来限制流量
  - 分为单机限流，分布式限流。
  - 打点限流、漏桶算法、令牌桶算法https://www.cnblogs.com/xuwc/p/9123078.html
  - PID控制算法。这个可以参考一下 https://github.com/Fakeroneyk/testPID.git

- ####  让你设计一个延时任务系统怎么做 

  - 说了两个方案，一个是使用 [redis](https://huanle.feishu.cn/jump/super-jump/word?word=redis) 的 ZSET 来实现，考虑分片来抗高并发，使用 [redis](https://huanle.feishu.cn/jump/super-jump/word?word=redis) 的持久化来实现落地，使用 [redis](https://huanle.feishu.cn/jump/super-jump/word?word=redis) 的哨兵实现故障转移。 一个是使用时间轮的方法。 

- #### 服务发现是怎么实现的

- #### 熔断是怎么实现的

  - 熔断是指流量过大或者失败率太高，不往下游继续打流量的操作
  - 主要就是由监控上述两个指标进行熔断器的关闭
  - 熔断器关闭后有自动唤醒功能，以下就是其中一种实现



- Completer 上传失败、超时、成功的task数量到redis中
- Submmiter起一个协程定时获取redis中的失败、超时、成功的task的数量

```Plain%20Text
失败/超时 数量 failed_num
总的渲染结束的任务数量 total_num
失败率阈值 failed_rate_max
从redis获取数据周期T
间隔时间内  failed_rate = △failed_num/△total_num 
failed_rate >= failed_max 时熔断器打开
直到连续3次 failed_rate < failed_max 时 熔断器关闭
```

- 上送任务前获取熔断器状态，如果熔断器打开，则停止上送3T时间后尝试重新获取熔断器状态，直到熔断器关闭则停止熔断



无法复制加载中的内容



#### DB 存储

- #### 数据库为什么使用B树作为存储数据的数据结构？ 

  - 分叉多，树比较低
  - https://zhuanlan.zhihu.com/p/27700617

- #### mysql常见的存储引擎，innoDB和Myisam区别

  - innoDB支持事务、外键、行锁

#### DB 事务

- ####  binlog 日志和 redolog 日志清楚吗？ 说了两个日志的作用以及两阶段提交 

  - redolog是innodb引擎级别的，mysql服务重启时恢复数据用
  - binlog是mysql server级别的，做数据恢复

- #### mysql中事务的原理，在哪一层实现，存储引擎怎么实现这一步

  - ACID
  - binlog，redolog 
  - 隔离级别

#### DB 索引     // 直接看《mysql是怎样运行的》第六章索引部分，太详细了。

- #### mysql 索引在什么情况下会失效 

  - like前置匹配
  - or两边不全是索引
  - 数据类型不对

- ####  mysql 的索引模型 

- #### 设计过联合索引吗

![img](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=MzUxODgxZTE5ZDM3OWEzOTNiNmY4ZmY1YWYzZTAwMDhfT3BHOGt6TXVGdTRkYVU2aGxzdE1sYnFhM3ByY3ZKNDBfVG9rZW46Ym94Y25uNk5NSnFrTFMyQ1RkUWRpT3VrMURjXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

我们对(a,b)字段建立一个索引，也就是说，你where后条件为

```SQL
a = 1
a = 1 and b = 2
```

是可以匹配索引的。但是要注意的是~你执行

```SQL
b= 2 and a =1
```

也是能匹配到索引的，因为Mysql有优化器会自动调整a,b的顺序与索引顺序一致。 相反的，你执行

```SQL
b = 2
```

就匹配不到索引了。 而你对(a,b,c,d)建立索引,where后条件为

```SQL
a = 1 and b = 2 and c > 3 and d = 4
```

那么，a,b,c三个字段能用到索引，而d就匹配不到。因为遇到了范围查询！

https://zhuanlan.zhihu.com/p/115778804



- #### 联合索引的匹配规则

  - **最左匹配**

- #### 聚簇索引和非聚簇索引的区别，具体体现在哪

  - https://www.cnblogs.com/jiawen010/p/11805241.html
  - **主键的索引 B+树叶子节点存放的是用户数据**
  - **其他索引 B+树叶子节点存放的是主键的值，然后再去主键的索引里面去找到用户数据（回表），好处：节约空间**

- #### B+树的时间复杂度（不太清楚）

- #### B树和B+树总结

  - B+树相对于B树有一些自己的优势，可以归结为下面几点。
  - 1.单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。
  - 2.**所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。**
  - 3.所有的叶子节点形成了一个**有序链表**，更加便于查找。

- #### B+树为什么一般是三层吗（支支吾吾）

  - https://zhuanlan.zhihu.com/p/86137284

- #### 什么情况适合建立索引？

  - 经常查询的列，主键列，排序列(order by)

- #### 如何通过索引避免出现重复ID？

  - 建立唯一索引

- #### 数据库中已经有重复ID数据，如何去重？

```SQL
Delete from table 
    where x1 not in(
        select temp.x2 from (
            select MIN(id) x2 from table
                group by col1,col2
        )as temp
    )
```

- #### redis怎么保证高可用

  - 哨兵机制保证高可用，检测master是否挂了，挂了就选举一个slave作为master
  - 主从切换保证读高并发，master写，slave读

- #### 事务 及 ACID

  - commit / rollback
  - 提交: 当一个事务完成之后,发出commit命令,来让所有参与表的更改生效.
  - 回滚: 当事务 发生故障,应该发出 rollback命令 来让事务引用的每一个表都回到事务开始以前的状态.
  - 原子性 、一致性、隔离性、永久性

- #### 一致性哈希，增桶、减桶。

- #### Redis用过吗**，**讲讲用过哪些类型 

- #### B树和B+树的区别，为什么要用B+树 

  - 1.单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。
  - 2.所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。
  - 3.所有的叶子节点形成了一个有序链表，更加便于查找。

#### zset 延时队列怎么实现的 

1.    1） 将**消息**序列化成**字符串**作为 zset 的 **value**，**到期**处理**时间**为 **score**
2. ​    2）多个线程轮询zset 获取到期任务进行处理 。多线程**保障可用性,并发争抢,不会被多次执行**

#### [redis](https://huanle.feishu.cn/jump/super-jump/word?word=redis) 数据结构有哪些？分别怎么实现的？ 

- hash hashmap
- list 链表
- set hashtable
- sort set skiptable

- #### redis过期策略

  -  noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧
  -  allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
  -  allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧
  -  volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）
  -  volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个keyo
  -  volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除



#### 

- ####  负载均衡[算法](https://huanle.feishu.cn/jump/super-jump/word?word=算法)有哪些

  -  轮询，加权轮询，随机，加权随机



- #### [redis](https://huanle.feishu.cn/jump/super-jump/word?word=redis) 持久化有哪几种方式，怎么选？ 

  - AOF,RDB

- #### [redis](https://huanle.feishu.cn/jump/super-jump/word?word=redis) 主从同步是怎样的过程？ 

  - 总的来说主从复制功能的详细步骤可以分为7个步骤：
  - 设置主节点的地址和端口
  - 建立套接字连接
  - 发送PING命令
  - 权限验证
  - 同步 （从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步）
  - 命令传播（主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。）

- ####  mysql 主从同步怎么搞的？分哪几个过程？如果有一台新机器要加到从机里，怎么个过程。 

- #### **SQL语句在MySQL中的解析过程** 

客户端----连接器----分析器----优化器----执行器----存储引擎----数据

- #### MySQL中的行锁什么时候转变为表锁？行锁有哪些？

  - 使用索引采用行锁，否则采用表锁；
  - 排他锁for update和共享锁lock in share mode

- ####  乐观锁与悲观锁的区别？ 

  - 悲观：事务开始时锁
  - 乐观：事务提交时锁

- ####  binlog 日志是 master 推的还是 slave 来拉的？

  - slave拉的 

- #### 继承的底层原理 

  - 继承方式、虚函数、派生类对象的析构
  - 重写虚函数表

- #### TCP如何保证可靠传输

  - 校验和
  - 序列号
  - 确认应答
  - 超时重传
  - 连接管理
  - 流量控制
  - 拥塞控制

- #### socket通信可以发1K的UDP数据包吗？TCP可以吗？

  - UDP 是64K，TCP没有限制

- #### LRU[算法](https://huanle.feishu.cn/jump/super-jump/word?word=算法)的实现？

- #### tcp_nodelay 

  tcp默认打开nagle算法，用于流量控制。对于延迟敏感的应用，打开比较好。

- #### TCP粘包问题、UDP会粘包嘛

  - udp不会粘包

- #### id生成器怎么实现的，如何实现全局递增

- #### 随机0,1产生均等的随机（0,n） 。。

- #### 四次断开如果服务器没有收到[客户端](https://huanle.feishu.cn/jump/super-jump/word?word=客户端)的确认包，会一直等待吗？等多久？·

  -  1RTO

- #### new一个对象，线程b能访问得到吗。？？？？？什么勾8问题

- #### 包丢了，tcp的发送端措施，除了重传机制，还有别的吗  

  - 高速重传机制，当接受端收到包会返回下一个应该接受的数据包，如果发送端连续三次收到同一个数据包，就直接重传。

- #### DNS哪个层的协议，底层用是哪个协议 

  - 应用层

- #### tcp是如何实现keep-alive的

  - 开启 so_keepalive如果两个小时没有数据传输，就发送一个保持存活探测节点给对方。返回情况有点多，，，

- #### 键盘输入一个字符到显示在显示器上的全过程

  - 键盘输入 ：外中断
  - OS中断流程
  - 调用ioctl系列函数在屏幕上显示

- #### C++对象内存布局？ 

  - 内核空间，栈，堆，内存映射段(动态静态链接库，文件映射)，bss段，数据段，代码段
  - 问了C++对象布局的一些东西，回答得还行，涉及到了虚函数指针、空对象的大小以及vector容器、三五法则。 

- #### 接着面试官又问了一些C++模板方面的问题，

  - 先给了三个重载函数（普通函数、函数模板、特例化的函数模板），根据入参确定调用的函数。接着又问了类型萃取的问题，如何使用模板来判断入参是一个类对象指针，还是一个内置类型指针。 

 

- ####  C++ 的构造函数可以是虚函数吗？ 

  - 不可以，虚函数表在构造函数中构造，如果构造函数为虚函数，找不到虚函数表

- #### c++ 的析构函数可以是纯虚函数

  - 可以，编译器允许这么做，但是需要手动实现，不然子类无法实例化。
  - 纯虚函数还是可以实现的

- ####  协程和线程的区别 

  - \1.  一个线程可以多个协程，一个进程也可以单独拥有多个协程。
  - \2. 线程进程都是同步机制，而协程则是异步。
  - \3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。
  - 4.线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。
  - 5.协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。
  - 6.线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。

- #### 背包问题

- #### 运行时多态和编译时多态  重载和继承

- #### extern 关键字 

  - 函数的声明extern关键词是可有可无的，因为函数本身不加修饰的话就是extern。但是引用的时候一样需要声明的
  - 全局变量在外部使用声明时，extern关键字是必须的，如果变量没有extern修饰且没有显式的初始化，同样成为变量的定义，因此此时必须加extern，而编译器在此标记存储空间在执行时加载内并初始化为0。而局部变量的声明不能有extern的修饰，且局部变量在运行时才在堆栈部分分配内存。
  - 全局变量或函数本质上讲没有区别，函数名是指向函数二进制块开头处的指针。而全局变量是在函数外部声明的变量。函数名也在函数外，因此函数也是全局的

- #### TCP滑动窗口，是否动态可变，用来干嘛(流量控制) 

  - 所谓滑动窗口，可以理解成接收端所能提供的缓冲区大小。TCP利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓 冲区。由于窗口由16位bit所定义，所以接收端TCP 能最大提供65535个字节的缓冲。由此，可以利用窗口大小和第一个数据的序列号计算出最大可接收的数据序列号。 

- #### 五层模型 

- #### TCP在哪层，arp干什么的，在哪层，路由器在哪层，交换机哪层。

- #### 给出两个子网IP，是否走交换机，经过哪些。 

- #### 僵尸进程  

  - 僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。
  - 如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源

- #### mysql有哪些引擎 

  - 

- #### 为什么用本地消息表，为什么不将事务直接发给消息队列

- #### Ping原理，在哪一层

  - 网络层，用ICMP
  - ICMP（Internet Control Message Protocol）Internet控制[报文](https://baike.baidu.com/item/报文/3164352)协议。它是[TCP/IP协议簇](https://baike.baidu.com/item/TCP/IP协议簇)的一个子协议，用于在IP[主机](https://baike.baidu.com/item/主机/455151)、[路由](https://baike.baidu.com/item/路由)器之间传递控制消息。控制消息是指[网络通](https://baike.baidu.com/item/网络通)不通、[主机](https://baike.baidu.com/item/主机/455151)是否可达、[路由](https://baike.baidu.com/item/路由/363497)是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 [1] 

- #### 套接字有哪三种

  - tcp，udp，raw

- #### http可以复用同一个TCP连接吗

  - 可以
  - TCP连接复用技术通过将前端多个客户的HTTP请求复用到后端与服务器建立的一个TCP连接上。这种技术能够大大减小服务器的性能负载，减少与服务器之间新建TCP连接所带来的延时，并最大限度的降低客户端对后端服务器的并发连接数请求，减少服务器的资源占用。

- #### 可以UDP实现吗

- #### 为什么数据库要有外键

  - 约束
  - 解除冗余

- #### innodb索引

- #### 数据库索引为什么用自增id，有什么好处

  - 当我们使用主键递增ID的时候，所有新增的主键都为当前主键的最大值，所以只需要在索引树的最右边加上一个记录即可

- #### 继承条件下对象构造析构顺序是否可以改变 即先构造子类再构造父类

- #### 9交换机路由器区别 工作方式

- #### SEQ是怎么取的；

- #### 描述一下TCP是怎么发送文件的

  - mmap
  - sendfile
  - （这个问题没太听懂他想我回答什么问题，因为他说不用说bind listen accept那些，最后只答了将文件Read进内存，然后按照缓冲区当前的index分批发送）

- #### TCP有了checksum还可能会造成数据错乱吗（我答的有可能，确实不清楚）

- #### tcp/ip的5层，osi七层

- #### http在哪一层，tcp在哪一层，arp在哪一层

- #### arp协议

- #### UDP的特点

- #### 软，硬链接 

- #### 虚拟内存

- #### swap （不知道）linux的虚拟内存

- #### 在两个进程中，申请的指针，可能指向同一片内存吗

  -  不会，进程间内存独立

- #### 什么是中断 

  - 中断是外部设备向处理器发起的请求事件。就是处理器的标准输入接口。

- #### 中间件

  - MQ
    - 优点
      - 解耦
      - 冗余
      - 扩展性
      - 灵活性和峰值处理能力
      - 可恢复性
      - 顺序保证
      - 缓冲
      - 异步通信

![img](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZkMTBlYjZmNzk3ZDEwMjE3ZWM1ZjExZWE1ZmE0MDNfMGVkd2JoQXU4VWdhYW1YUTB2aFhZcEQxMmlWd0ZpTWJfVG9rZW46Ym94Y250bDRBUWpYc2xJWlRkWEhGQVIxVVdUXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

- MQ的幂等是怎么去保证的？怎么防止消息重复消费？
  - version版本号保证幂等，重复消费可以有主键ID，Redis缓存等等.. 
- zookeeper
  - 选举Leader
  - 同步数据
  - 选举Leader过程中算法有很多，但要达到的选举标准是一致的
  - Leader要具有最高的执行ID，类似root权限
  - 集群中大多数的机器得到响应并接受选出的Leader

- #### 

- #### 求数组中每个位置下一个最大的数

  - 单调栈

- #### 怎样理解C++多态特性

  - 基类指针可以访问子类对象、需要继承、虚函数重写

- #### 重载的原理 

  - 重载的函数在编译时产生不同的符号名

- #### const的理解，怎样解决const对象可以通过指针修改 

  - const int a;  int const a; const int* a; int* const a; const int* const a;
  - 指针指向const对象的地址，用指针来修改

- #### vector的底层存储 

  - 元素大小，空间大小，元素大于空间会重新申请空间，拷贝，释放旧空间，使用新空间

- #### map的存储结构

  - 红黑树，unordered_map是哈希表

- #### select的限制 

  - 文件描述符上限  
  - select中的fd_set**集合容量的限制**
  - select是轮询的，当并发量高的时候效率低

- #### epoll相对于select的优势 

  - 文件描述符数量上限取决于内存大小，比select大
  - 轮询机制不同，epoll使用红黑树来存放节点，有读写消息时会把文件描述符放入链表中，在epoll_wait时进行处理，select轮询每个文件描述符，效率较低

- #### 你知道字节序吗？字节序如何转化？

  - 大端、小端

- #### 字节对齐是什么？为什么要进行字节对齐？什么因素会影响字节对齐呢？可以让字节以1对齐么？

  - 加快CPU访问速度，比如int4字节 在003地址上，要取值三次，在002地址上，要取值两次

- #### STL有使用过哪些呢？我回答了vector、list、pair，后续又追问vector是个什么呢？[链表](https://huanle.feishu.cn/jump/super-jump/word?word=链表)你使用的哪个呢？pair是个什么？什么情况下使用的？

  - vector是个可动态扩容的数组，

- #### 你知道map吗？怎么实现的？我回答了STL里面的map，底层使用了[红黑树](https://huanle.feishu.cn/jump/super-jump/word?word=红黑树)，后续追问[红黑树](https://huanle.feishu.cn/jump/super-jump/word?word=红黑树)是什么呢？有什么特点？[红黑树](https://huanle.feishu.cn/jump/super-jump/word?word=红黑树)自平衡是自动平衡吗？怎么实现自平衡的？[红黑树](https://huanle.feishu.cn/jump/super-jump/word?word=红黑树)和普通的[二叉树](https://huanle.feishu.cn/jump/super-jump/word?word=二叉树)有什么区别呢？

  - 根节点是黑的
  - 红节点不会相连
  - 红节点的子节点全是黑节点
  - 最长链的长度不会超过最短链的两倍
  - 叶子节点都是黑的
  - 任意节点到叶子的路径都有相同数量的黑色节点

- #### **变量的声明和定义有什么区别呢？变量的声明和定义在编译和链接阶段有什么区别呢？**

  - 定义只能一个，声明可以有多个，编译时只需要有声明，链接时会根据声明去符号表里面找定义，没有定义则链接失败

- #### **项目中用到了什么技术点呢？**

  - 分布式、平行扩展、可伸缩、动态扩容、Rector模式

- #### **Linux下用什么工具排查问题呢？**

  - 主要用GDB，也会用Linux相关命令查询系统状态，比如netstat、tcpdump
  - free、df等

- #### **TIME_WAIT是什么？**

  - close发起一端收到SYN后进入的状态，等待2MSL后关闭连接

- #### **讲下TCP断开链接的过程？然后我讲了四次握手，后续追问TCP四次握手在哪一步骤真正断开了链接呢？**

  - time_wait状态结束

- #### **对于SQL了解吗？索引有什么用？为什么要加入索引？**

  - 提高检索速度，减少检索的行数

- #### **在浏览器输入****[www.qq.com](http://www.qq.com/)****，会打开****[腾讯](https://huanle.feishu.cn/jump/super-jump/word?word=腾讯)****的首页，在这个操作中用了什么协议呢？经过了哪些步骤呢？**

  - 向DNS服务器请求ip
  - 跟对应ip进行TCP连接
  - 发送http请求，服务器返回静态网页文件
  - 浏览器渲染
  - 应用层:HTTP\DNS\HTTPS
  - 传输层:TCP
  - 网络层:IP、ARP

#### **最后问了一道****[算法题](https://huanle.feishu.cn/jump/super-jump/word?word=算法题)****，这道****[牛客题霸](https://huanle.feishu.cn/jump/super-jump/word?word=牛客题霸)****上有原题，大家可以去看看：NC15** 

**[求二叉树的层序遍历](https://huanle.feishu.cn/jump/super-jump/practice?questionId=644)**  **https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=190&tqId=35337&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey**

### 

- #### list和vector实现有什么区别？讲讲vector的resize操作？

  - list是链表，不连续的空间，不支持随机访问
  - vector是可扩容的数组，连续的空间，支持随机访问
  - resize的大小与当前vector占用空间进行对比，如果小于就不改占用空间大小，只改动end()的位置，如果大于当前空间大小，则重新申请空间并拷贝

- #### linux查看网络状态命令是什么？使用场景？

  - netstat 
  - 查看网络连接的状态，遇到网络不通的情况时，可以用这个命令查看与对端连接的情况来进行bug的定位

- #### TCP和UDP有什么区别？应用场景？三次握手四次断开的过程？UDP有可靠性保证吗？

  - TCP是可靠连接，流传输，UDP是以数据包为单位的，不稳定
  - 对稳定性要求高，如金融系统用TCP。要求传的多、快用UDP 、如视频网站
  - UDP的可靠性只能在应用层实现(自己实现)

- #### 指针和引用的区别？

  - 指针有自己的地址，指向变量
  - 引用只是变量的别名，跟变量的地址相同
  - 指针可以为空，引用不可以为空
  - 指针所指对象可以改变，引用不行

- #### #define和const的区别？

  - define是在预编译时做文本替换，const常量在编译时处理
  - define没有类型，const有类型
  - define还可以指定函数，const不行

- #### char arr[20]和char *p = new char[20]的区别？初始化和未初始化的情况？

  - 前一个分配到栈上，后一个分配到堆上
  - 前一个首地址就是数组的起始地址，后一个返回的是个指针，指向数组头
  - 前一个不初始化、后一个初始化

- #### C++内存分配有哪几种方式？画出C++内存布局图？

  - 栈、堆、静态区

- #### 已知进程名，使用命令查看当前进程打开的文件句柄？

  - lsof|grep xxx 

- #### 已知进程名，使用命令查看当前进程的网络连接状态？

  - netstat -anp|grep xxx

- #### 已知进程名，查看eth0网卡与ip10.10.10.10:10653之间的TCP数据包？

  - Tcpdump -i eth0 host 10.10.10.10 and port 10653

- #### free()函数入参是一个void*指针，它是如何知道被指向的大小的？

  - 假设你用malloc需要申请100字节，实际是申请了104个字节。把前4字节存成该块内存的实际大小，并把前4字节后的地址返回给你。 free释放的时候会根据传入的地址向前偏移4个字节 从这4字节获取具体的内存块大小并释放。 

- #### 查找[二叉树](https://huanle.feishu.cn/jump/super-jump/word?word=二叉树)中第k小的元素？

  - 中序遍历

- #### C++ lambda表达式的特性，什么情况下使用？ 

  - 在函数内实现
  - 可以获取上下文变量,拷贝、引用
  - 简洁、不想在类内写一个函数、无复杂逻辑

- #### C++虚函数表、函数重载、函数重写（override）特性？ 

  - 重载是同一个类中有相同函数名，不同参数个数/列表的函数
  - 重写是子类对父类virtual方法的重写
  - C++通过虚函数表来实现多态

- #### C++智能指针特性、右值特性、正则表达式、map、unorder_map？ 

  - unique_ptr,shared_ptr,weak_ptr.唯一指针、引用计数、防止shared_ptr循环
  - 右值不可被复制、可以减少拷贝的消耗、临时值
  - 正则不会？？？？？？？？？

- #### C++ new和c语言的malloc的区别？ 

  - new不用指定申请空间大小，malloc要指定大小
  - new用delete释放，malloc用free释放
  - new是关键字，malloc是函数
  - new申请空间并调用构造函数
  - new返回对象类型的指针、malloc返回void*

- #### linux网络编程api（socket、bind、listen、accept、close、connect） 

- #### 

- #### 析构函数不加virtual会发生什么，原理。 

  - 基类指针先调用析构，子类对象有空间没释放，造成内存泄漏

- #### liunx下如何shell下查看cpu内存资源使用情况用什么命令

  - top

- #### 

- #### kill一个进程的过程是什么样子的

  - 发送信号给这个进程，这个进程对信号进行处理

- #### 浅拷贝，深拷贝

  - 类的对象有堆上内存时，直接赋值后的对象内成员指针指向原数据的成员指针所指的内存，需要拷贝后才是深拷贝

- #### 链表插入时间复杂度

  - O(n)

- #### 虚函数表

- #### 虚函数如何实现的，具体调用过程，如何实现的多态

  - https://www.jianshu.com/p/587ab12f7c88

- #### avl树旋转调整原理，只需要分情况画图说明

- #### 学过编译原理吗 说下c++转成exe过程（不知道该说编译过程还是编译 链接什么的，回答的是前者，词法分析语法分析云云）

.c,.h文件  经过**预处理器** 生成 .i中间文件 经过**c编译器**生成 .s汇编文件 经过**汇编器** 生成 .o 可重定位文件 经过**链接器**生成 可执行文件

可重定位文件：



# 网络

- ### 如何诊断网络问题？

从 客户端 → 网络链路 → 服务器 → 进程内部  四个步骤排查

- 客户端： 检查4G网络/WIFI或者有无代理
- 网络链：通过wireshark、tcpdump抓包，检查三次握手状态，netstat -ano检查端口状态
- 服务器：检查ehth0网卡的收发包情况，再观察grafana+prometheus分工具观察rtt和网络情况
- 进程内部：检查协议解码有无问题（粘包解包）再检查有无逻辑层卡帧问题导致误判为网络问题

- ### TCP三次握手，两次行不行   

  - 不可以，Client第一次发的SYN在网络中滞留，超时重发了第二次SYN，第二次的可能先到达并完成握手，后第一次又到达，服务器继续分配内存，回SYN+ACK，但是再Client无效，浪费了Server资源

![img](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=ODEyMGI4N2Q2MjQzODk3Mzg4NmEwNGIxY2RhNmRhMjlfSHpvUUN1aTVvOHNIZ0Q0TlFyV3A5dGhZUHZ6cnUyQmlfVG9rZW46QmhIZGJnQm1Sb3llZkV4dXB0UGNJdXFGbkNxXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)



- ### TCP四次握手，time_wait状态出现原因

1. 确保被动关闭方收到最后一个 ACK（若 ACK 丢失，被动方会重发 FIN，主动方可在此时重传）；
2. 等待 2MSL（报文最大生存时间），让连接中残留的旧报文过期，避免干扰新连接。

![img](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=YmU4NTg5ZGZhYjgyMmI2OGI1ZDJjYWMyNmNiZTAzMWJfTlZvTHoyem4zNkpmTGt6TG4wRFRwaEs1eHptaGhxQzZfVG9rZW46U1lHYWIzVlRxb09BZkR4WVFZemNWUXhubnFmXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

- ### **TCP中拥塞控制vs流量控制**

  - 流量控制

面向端到端，主要用来形容对方的接受能力，在报文中通过rwnd（接收窗口），在接收方收到请求方的写请求后，响应ACK的时候带上当前写缓冲区的剩余大小

- 拥塞控制

   面向发送方与网络链路，在报文中cwnd（拥塞窗口体现），单位一般为mss，另有阈值X

- 慢启动

启动时，会设置初始窗口为1mss，每次收到ACK后翻倍，即2mss 4mss 直到阈值

- 拥塞避免

到达阈值X后，变为线性增长，5mss 6mss。。。。。

- 快重传

如连续三次收到同样的ACK，则快速重传一次，并设置阈值为当前窗口的一半，并将当前窗口设置为当前阈值

- 超时重传

如果在超时时间内未收到ACK，则认为网络当前较为拥挤，调整阈值为当前cwnd的一半，并且将cwnd从1开始慢启动

- ### **TCP**段(mss) 是多少，如何得来

```Plain%20Text
MTU = 1500字节 是数据链路层对帧的最大长度限制
MSS(tcp段) = 1500字节 - 20字节(IP头) - 20(tcp头)
```

- ### 发送、接收方关键函数

```Plain%20Text
// 发送方
socket() // 创建fd
bind() // 绑定IP 端口
listen() // 监听请求
accept() // 获取连接 （此时拿到的连接已完成三次握手）

// 接收方
socket() // 创建fd
connect() // 连接地址
```

- ### send /recv 过程

```Perl
用户进程（User Space）
┌──────────────────────┐
│  send(buf) / recv()  │
└─────────┬────────────┘
          │  (系统调用)
          ▼
内核（Kernel Space）
┌───────────────────────────────┐
│   Socket 缓冲区                │
│  ┌───────────────┐             │
│  │发送缓冲区 sndbuf│◄─── send() │
│  └───────────────┘             │
│  ┌───────────────┐             │
│  │接收缓冲区 rcvbuf│───► recv() │
│  └───────────────┘             │
└───────────┬────────────────────┘
            │
            ▼
      TCP 协议栈（内核）
 ┌─────────────────────────┐
 │ - 分段 (MSS)            │
 │ - 拥塞窗口 (cwnd)        │
 │ - 接收窗口 (rwnd)        │◄── 从对端 ACK 包获取
 │ - 超时/快速重传          │
 │ - ACK 处理               │
 └───────────┬─────────────┘
             │
             ▼
         网络传输 (IP 层)
             │
             ▼
       对端内核 TCP 协议栈
 ┌─────────────────────────┐
 │ - 根据 rwnd 控制发送方   │
 │ - 处理 ACK / 窗口更新    │
 │ - 将数据放入 rcvbuf     │
 └───────────┬─────────────┘
             │
             ▼
      对端用户进程（User Space）
      ┌───────────────────┐
      │    recv() 调用    │
      └───────────────────┘
```

### Epoll

epoll是linux内核提供的I/O多路复用方案，解决传统select/poll的性能瓶颈（低效轮询）

核心设计：

- 事件驱动，不再依赖主动查询，改为抛出事件驱动
- 红黑树（查、插都为logn） 内部红黑树管理fd，添加、删除复杂度都为O(logn)
- 就绪链表：内核维护就绪事件链表，当 fd 状态就绪时，会被加入该链表，用户态调用 `epoll_wait` 时直接从链表取结果，无需遍历全部 fd

- ET LT区别？

  - LT （Level Trigger）
    - 当fd满足就绪条件，每次epoll_wait都会返回该fd （性能相对低，一次未处理完，每次都会返回该fd）
  - ET （Edge Trigger）
    - fd一次就绪仅通知一次，需要应用层去处理一次需要处理完所有就绪的数据 （性能相对较高，但需要应用层维护）

- ### 在 TCP 建立连接的三次握手连接阶段，如果客户端发送的第三个ACK包丢了，那么客户端和服务端分别进行什么处理呢？

  - Server 端
    - 第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。
    - 而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.
    - 如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。
  - Client 端
    - 在linux c 中，client 一般是通过 connect() 函数来连接服务器的，
      - 阻塞fd的connect等到三次握手完成后返回
      - 非阻塞fd的connect会立即返回值，在等到epoll抛出epollout事件，并且***异步connect需要getsockopt(SO_ERROR)==0***，即使连接失败，也会抛epollout

# 操作系统

- ### 内存泄漏诊断

  - 静态代码检查工具
  - 动态内存检查工具valgrand
  - gperftools+pprof查看内存消耗大的块

- ### timestamp,  datetime的区别

  - timestamp（时间戳）本质是数值型（整数或浮点数），表示从某个「基准时间点」开始经过的秒数（或毫秒数、微秒数）。最常用的基准是「Unix 纪元时间」：`1970-01-01 00:00:00 UTC`。例如：`1620000000` 表示从 Unix 纪元开始经过 1620000000 秒，对应北京时间 `2021-05-03 16:00:00`。
  - datetime（日期时间）本质是结构化数据，直接存储「年 - 月 - 日 时：分: 秒」（可能包含毫秒 / 微秒），是人类可直接阅读的时间格式。例如：`2021-05-03 16:00:00` 或 `2023-10-01T08:30:00.123`。

- ###  fork函数的作用？ 

  - 创建一个和当前**进程**一样的子**进程**
  - 调用一次，返回两次 `pid = fork();` pid>0为父进程，pid=0为子进程
  - 子进程会复制父进程所有的代码段、数据段，堆栈环境变量等等，并且有完全独立的地址空间，现代大部分操作系统优化了fork，采用COPY ON Write机制，降低fork的开销
  - 通常fork + exec来在子进程中执行新的任务

- ### 僵尸进程是什么？

  -  一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程PID仍然保存在系统中并且是Z+状态。这种进程称之为僵死进程
  - 无法通过kill -9杀死僵尸进程，因为他已经终止，仅有有残留的信息
  - 父进程也可以通过注册SIGCHILD信号处理函数，异步的去wait，进而回收子进程残留数据
  - 如果是父进程提前退出，则子进程会被init(PID为1)进程收养，init进程会注册子进程的退出信号

- ### 信号量本质是什么？锁和信号量的区别是什么？

  - 本质：内核维护的整形计数器，用来控制同时访问某个共享资源的线程数
  - 锁必须谁拿谁还，并且同时只能有一方持有
  - 信号量可以多方持有，并且归还无需持有方，信号量计数为0时，进入队列等候，计数>0时唤醒队列中成员

- ### 进程的三种状态和状态转换

- ### 信号的区别

- ### 进程通信方式，哪种最快 

  - 信号、共享内存、socket、管道、信号量、最快是共享内存

# 数据库

- ### MySQL的索引是用来干嘛的？ 

- ### 有什么索引，分别是用来干嘛的？ 

- ### MyISAM和InnoDB的区别

# 语言（C++) 

- ### 函数的多态讲一下？ 

  - 静态多态（编译时）

重载（相同函数名，不同的参数列表），编译时会生成不同的函数符号

- 动态多态（运行时）

重写（子类重写基类中的虚函数），虽然在编译时，已经确定各个类中的虚函数表，但是当基类指针指向子类实例的时候，具体执行的函数由子类实例中虚指针指向的虚函数表决定

- ### 虚函数讲一下？

  - 虚函数
    - Virtual关键字，有函数体，子类可重写
  - 纯虚函数
    - virtual关键字，且 virtual func()= 0；，包含纯虚函数的 类是抽象类，不可实例化
  - 通过虚函数表实现，编译时类的虚函数表已经确定，运行时类实例中通过虚指针索引到类的虚函数表，调用时查表查询具体执行的函数
  - 析构可以是虚函数，并且基类的虚构一般建议是虚函数，否则可能会导致子类析构无法调用导致内存溢出

- ### 内联函数？

  - inline关键字声明的函数，核心目的是为了减少函数调用开销，发生在编译时，编译器根据情况将函数在调用处直接展开
  - 相比于宏更安全，编译期有类型检查等等
  - 但可能会增加代码体积，导致编译过慢等等

- ### 宏

  - 发生在预处理阶段（文本替换）没有类型检查等，适合简单的计算，包含有参宏和无参宏
  - 副作用是可能导致重复计算，解决是每个变量都加上()

- ### Const理解

- ### Const 函数？ 普通指针优先调用const成员还是非const成员？放在函数前后有什么区别？

  - 函数后加const修饰符，表示该函数内不能修改成员变量，编译期检查报错，可以被const和非const对象调用
  - const对象优先调用const函数，非const对象优先调用非const函数，在编译器决定，编译器会根据对象的const属性优先匹配对应的函数（编译期对象的const属性已知）
  - 函数前表示返回对象不可修改，函数后表示不能修改成员变量

- ### 什么是迭代器失效？ 

  - 迭代器的里指针不再指向原来的数据
  - vector在添加、删除、swap之后都会造成迭代器失效

- ### C++ new和c语言的malloc的区别？

- ### C++智能指针特性

- unique_ptr,shared_ptr,weak_ptr.唯一指针、引用计数、防止shared_ptr循环

- ### 右值特性

- 右值不可被复制、可以减少拷贝的消耗、临时值

- ### 正则表达式

- 正则不会？？？？？？？？？ 

- ### map、unorder_map？ 

  - map红黑树
  - unordered_map 是哈希表

# 算法

### vector相关

### 红黑树









\2. Mysql ORM数据结构是什么

\3. socket有什么接口，lt与et的区别

\4. Epoll 有什么接口 

\5. const成员函数？一个普通指针优先调用const成员还是非const成员

- #### C++的静态链接和动态链接讲一下 

  - 将目标文件链接成二进制的过程是静态链接
  - 静态链接比动态链接有更大的空间浪费，每个二进制都会包含一份静态链接的代码和数据，动态链接装载到内存中可同时供多个进程使用
  - 静态链接主要做的事情是根据符号表的信息进行引用符号的重定位
  - 动态链接利用fPIC参数可以生成地址无关的代码，保证多个进程可以使用同一个动态链接库

- #### 内核态和用户态的区别，如何切换，什么情况下会进行切换 

  - 系统调用
  - 异常
  - 外围设备的中断

- #### 排查线上某进程CPU为100%。

  - 先查看哪个进程100%
  - 用gperftools抓热点
  - 根据工具提供的数据去对应占用高的函数看代码

- ####  dynamic_cast是干嘛的？转换错误会返回什么？ 

  - 基类向子类的转化，做检查
  - 指针失败返回null，引用失败抛出异常

- ####  智能指针知道吗？ 

  - shared_ptr、weak_ptr、unique_ptr

- ####  CPU大端和小端的区别 

  - 字节序的两种表示方法
  - 小端：低地址段放低位字节，高地址段放高位字节
  - 大端：低地址段放高位字节，高地址段放低位字节

- #### 进程和线程的区别 

  - 1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。
  - 2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
  - 3.进程是资源分配的最小单位，线程是CPU调度的最小单位；
  - 4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。
  - 5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预
  - 6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。
  - 7进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉
  - 8.进程适应于多核、多机分布；线程适用于多核

- #### 进程，线程，协程

  - 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
  - 线程是指进程内的一个执行单元,也是进程内的可调度实体。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
  - 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。从技术的角度来说，“协程就是你可以暂停执行的函数”。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

- #### HTTP的GET和POST的区别 

  - 作用    GET用于获取资源，POST用于传输实体主体
  - 参数位置   GET的参数放在URL中，POST的参数存储在实体主体中，并且GET方法提交的请求的URL中的数据做多是2048字节，POST请求没有大小限制。
  - 安全性    GET方法因为参数放在URL中，安全性相对于POST较差一些
  - 幂等性    GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求，收到的结果都是一样的.

- #### HTTPS的SSL握手流程 

1. 客户端向服务端发起第一次握手请求，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。
2. 服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。
3. 服务端将证书发给客服端。
4. 客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。
5. 客服端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。
6. 服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。
7. 通信双方可用对称密钥来加密解密信息。



- 简单描述SSL的会话过程

1. SSL会话主要分为三步：
2. 1.客户端向服务器端索要并验证证书；
3. 2.双方协商生成“[会话密钥](https://www.zhihu.com/search?q=会话密钥&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType":"article","sourceId":143347041})”；对成密钥
4. 3.双方采用“会话密钥”进行加密通信；

- #### TCP和UDP的区别

  - TCP面向连接、数据流、数据可靠
  - UDP不用连接、数据包、数据不可靠

- #### TCP如何保证可靠性，什么情况下用UDP比较好 

  - neack确认和超时重发

- #### TCP报文结构

![img](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTcwNmI4MzgxNzE0MGQ4YTY5ZGFkNTE5ZTUxN2RmZWNfOEdzMFN3U3UyaUVlWnRJM0IyeG93SnY0S0Fhd3BOMkpfVG9rZW46Ym94Y25OQXNVOW1xSU1sRVB4VmlxWm8wWlBiXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

- 头部长度
  - 20字节

- #### UDP结构



- #### IP结构

- 

![img](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQwZDhhYjUyYTViMjUzZmZkYjFjMDE4YjE4OTIyNWNfSkxHZ0JtWTk0QkNVcG50c0UxUkxqSW9wUFNOR2xvUDJfVG9rZW46Ym94Y25BYUd6SXAxMDVNY1MzcTdycHNwUFBoXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

#### 

- #### TCP粘包和拆包

  - 原因
    - 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包
    - 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
    - 进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包。
    - 接收方法不及时读取套接字缓冲区数据，这将发生粘包。
  - 解决办法
    - 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
    - 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
    - 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。

- #### TCP拥塞控制(慢启动、拥塞避免、快速重传) 

  - 拥塞窗口阈值x，拥塞窗口大小为s,初始值为1
  - TCP建立连接时拥塞窗口大小为1，使用慢启动算法，窗口内数据都收到ACK后，拥塞窗口大小翻倍，直到s>=x，使用拥塞避免算法，拥塞窗口大小每次改变不翻倍，而是加一
  - TCP对每一个报文有一个重传定时器RTO，当超时时没有收到ACK，会进行重发，并且认为网络进入了拥塞阶段，此时拥塞窗口阈值变为当前拥塞窗口的一半，即x=s/2，s=1，重新进入慢启动阶段。
  - 快速重传:当发送方收到三个相同的ack时，设置阈值为拥塞窗口大小的一半，拥塞窗口大小设置为阈值，重传丢失的报文段，进入拥塞避免
  - 快速恢复：发送方收到三个相同的ack时，将拥塞避免阈值和拥塞窗口设置为拥塞窗口的一般。

- #### tcp流量控制

  -  所谓流量控制就是让发送发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制。原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。
  -  TCP的数据传输分为交互数据流和成块数据流，交互数据流一般是一些交互式应用程序的命令，所以这些数据很小，而考虑到TCP报头和IP报头的总和就有40字节，如果数据量很小的话，那么网络的利用效率就较低。数据传输使用Nagle算法，Nagle算法很简单，就是规定一个TCP连接最多只能有一个未被确认的未完成的小分组。在该分组的确认到达之前不能发送其他的小分组。 

- #### C++生成EXE可执行文件需要包含哪些要素(可以说说具体每步干了啥)

  - 预编译
  - 编译
  - 汇编
  - 链接

- #### C++对象生成时，该对象内存结构是怎样的

  - 基类的虚函数表指针、成员变量
  - 子类的虚函数表指针、成员变量
  - 函数在代码段，成员变量在堆或者栈
  - 子类重写基类的虚函数，基类指针访问子类成员函数时，会访问到被重写的函数指针

- #### C++ STL用过吗，讲讲迭代器分为哪几种类型，

- ？ 

![img](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzg1M2NiMWI3MWZiNjgwMTNjYTg1NGYxOTBjMzIwNjFfWUZ4MGh6WlpuZ2RmZkdUdnRvY0JoU3hkTHhsbFV0ckNfVG9rZW46Ym94Y25jNmZMMEVkdUdsWnpUMkxlS1VXNWZjXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

- vector是随机访问迭代器，list是双向迭代器
- 对每个迭代器参数而言，其能力必须与规定的最低类别至少相当。向算法传递一个能力更差的迭代器会产生错误！
- 如sort通用排序算法，要求其迭代器参数是随即访问迭代器。由于array、deque、vector、string所提供的迭代器都是随即访问迭代器(用于访问内置数组的指针也是)，所以均可使用该sort通用排序算法。而list和forward_list提供的是双向和前向迭代器，因此这两个顺序容器类型不能使用通用的sort排序算法。

- #### const放在函数前和放在函数后有什么区别

  - 放在前面代表返回值为不可修改的
  - 放在后面表示传入的this指针为只读，不可修改对象内属性

- ####  static和全局变量有什么区别

  - static变量只能在本文件中使用

- #### protobuf

  - 压缩原理
    - Varint 32 8位表示7位，高位代表后面的长度
    - Varint 确实是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint ，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。
    - 300 如果用 int32 表示，需要 4 个字节，现在用 Varint 表示，只需要 2 个字节了。缩小了一半！



- ####  越界问题一般出现在哪里

  - 数组访问、stl的访问，如栈的top()、memncopy

- ####  指针错误一般是怎样的，空指针会存在什么样错误（我只回答了野指针 空指针的错误不清楚

  - 段错误，访问地址无效，一旦一个程序发生了越界访问，cpu 就会产生相应的保护，于是 segmentation fault 就出现了，通过上面的解释，段错误应该就是访问了不可访问的内存，这个内存区要么是不存在的，要么是受到系统保护的，还有可能是缺少文件或者文件损坏。
  - 空指针上没有值，一般指向0x00000000地址
  - 类的空指针访问成员函数：类的成员函数并不与具体对象绑定，所有的对象共用同一份成员函数体，当程序被编译后，成员函数的地址即已确定，这份共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是隐式传递给成员函数的this指针
    - 静态成员函数，不需要this指针,所以即使是空指针，也不影响对Func正常调用。
    - 虽然某些func需要传递隐式指针，但是函数体中并没有使用到这个隐式指针，也就是说没有通过这个隐式指针去使用非静态的成员变量，也是可以执行的

- ####  两个无符号数相加如何判断溢出； 

  - 设x+y = s1
  - 若发生溢出，则s<x||s<y

- ####  25匹马五个赛道比出前三的问题 

- #### 单例模式实现；  

```C%2B%2B
#include <bits/stdc++.h> 
 
using namespace std; 
 
template<typename T> 
class Single{ 
public: 
    static T& Instance(){ 
        static T* instance = new T(); 
        return *instance; 
    } 
protected: 
    Single(){} 
private: 
    Single(const Single& ); 
    Single& operator = (const Single&); 
}; 
 
template<typename T> 
T* Single<T>::instance = NULL; 
 
class A{ 
public: 
    int x; 
    A(){ 
        x = 0; 
    } 
    void pp(){ 
        cout <<x++<<endl; 
    } 
}; 
 
int main() 
{ 
    for(int i = 0; i < 10 ;i ++){ 
         Single<A>::Instance().pp(); 
    } 
    return 0; 
} 
```

- ####  map和unordered_map的优缺点，适用于什么场景？  

  - map基于红黑树、unordered_map基于哈希表，

- ####  建立一个服务端需要哪些操作，我讲了常用的那些api。 

  - socket、listen、accept

- ####  操作系统（shell命令---好几个不会：查内存、磁盘使用情况什么的、同一进程下线程共享哪些东西、线程同步问题） 

  - free、df -hT
  - 线程共享代码段、数据段、堆
  - 临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；
  - 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
  - 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
  - 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

- ####  https原理

  - tcp建立连接后SSL或者TLS验证身份再发送http请求

- ####  内联函数有了解吗？内联函数和宏定义有什么区别？ 

  - （1）什么是内联函数？
  - 内联函数是指那些定义在类体内的成员函数，即该函数的函数体放在类体内。
  - （2）为什么要引入内联函数？
  -  当然，引入内联函数的主要目的是：解决程序中函数调用的效率问题。另外，前面我们讲到了宏，里面有这么一个例子：
  -  \#define ABS(x) ((x)>0? (x):-(x))
  -  当++i出现时，宏就会歪曲我们的意思，换句话说就是：宏的定义很容易产生二意性。
  - 我们可以看到宏有一些难以避免的问题，怎么解决呢？前面我们已经尽力替换了。
  - （3）为什么inline能取代宏？
  -  inline 定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，（像宏一样展开），没有了调用的开销，效率也很高。 
  -  很明显，类的内联函数也是一个真正的函数，编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。
  -  inline 可以作为某个类的成员函数，当然就可以在其中使用所在类的保护成员及私有成员。
  - （4）内联函数和宏的区别？
  - 内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联欢函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关上内联扩展，将与一般函数一样进行调用，比较方便。 
  - （5）什么时候用内联函数？
  -  内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话，将会获得比较好的效率。
  -  （7）内联函数的优缺点？
  - 我们可以把它作为一般的函数一样调用，但是由于内联函数在需要的时候，会像宏一样展开，所以执行速度确比一般函数的执行速度要快。当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。(换句话说就是，你使用内联函数，只不过是向编译器提出一个申请，编译器可以拒绝你的申请）这样，内联函数就和普通函数执行效率一样了。

- #### 内存泄漏的处理方法

  - 使用varglind，mtrace检测

- #### 请你来回答一下什么是memory leak，也就是内存泄漏

  - 内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏的分类：
  - \1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.
  - \2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
  - \3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

- #### 造成内存泄漏的原因

  - 程序循环new创建出来的对象没有及时的delete掉，导致了内存的泄露；
  - delete掉一个void*类型的指针，导致没有调用到对象的析构函数，析构的所有清理工作都没有去执行从而导致内存的泄露；
  - new创建了一组对象数组，内存回收的时候却只调用了delete而非delete []来处理，导致只有对象数组的第一个对象的析构函数得到执行并回收了内存占用，数组的其他对象所占内存得不到回收，导致内存泄露；
  - 没有将基类的析构函数定义为虚函数
  -  new一个数组的时候，中途发生异常，会导致之前初始化的部分泄漏
  - new了一个对象，执行中途发生异常，在处理异常的地方没有处理

- ####  请问C++11有哪些新特性？

  - C++11 最常用的新特性如下：auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导
  - nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。
  - 智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。
  - 初始化列表：使用初始化列表来对类进行初始化
  - 右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
  - atomic原子操作用于多线程资源互斥操作
  - 新增STL容器array以及tuple

- ####  [redis](https://www.nowcoder.com/jump/super-jump/word?word=redis) 跳表

- #### socket阻塞、非阻塞

- #### redis底层结构



# byteD

- #### kmp

```C%2B%2B
void get_next(string s,vector<int>& next){ 
    int len = s.size(); 
    next.resize(len); 
    next[0] = -1; 
    int j = 0; 
    int k = -1; 
    while(j<len - 1){ 
        if(k == -1 || s[j] == s[k]){ 
            if(s[++j] == s[++k]){ 
                next[j] = next[k]; 
            } 
            else{ 
                next[j] = k; 
            } 
        } 
        else{ 
            k = next[k]; 
        } 
    } 
}
```

- #### 三次握手。超时会怎么样

  - 一次握手A发送SYN传输失败，A,B都不会申请资源，连接失败。如果一段时间内发出多个SYN连接请求，那么A只会接受它最后发送的那个SYN的SYN+ACK回应，忽略其他回应全部回应，B中多申请的资源也会释放
  - 第二次握手B发送SYN+ACK传输失败，A不会申请资源，B申请了资源，但收不到A的ACK，过一段时间释放资源。如果是收到了多个A的SYN请求，B都会回复SYN+ACK，但A只会承认其中它最早发送的那个SYN的回应，并回复最后一次握手的ACK
  - 第三次握手ACK传输失败，B没有收到ACK，释放资源，对于后序的A的传输数据返回RST。实际上B会因为没有收到A的ACK会多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到A的ACK，则释放资源，对A的数据传输返回RST复最后一次握手的ACK

- #### 网络问题汇总

  - https://blog.csdn.net/paranior/article/details/115209752

- #### 如果更新db成功但是更新缓存失败引发数据不一致，怎么解决？

  - 删除缓存，如果删除失败，就用消息队列中间件去持续删除，直到成功

- #### 缓存的穿透/雪崩问题：

  - 缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。
  - 缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
  - 缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。
  - 缓存雪崩的原因及解决方案
  - ​        1、缓存大面积失效
  - ​        解决方案：避免缓存设置相近的有效期；为有效期增加随机值；统一规划有效期，失效时间均匀分布。
  - ​        2、对热点数据持续高并发
  - ​        解决方案：使用互斥锁：jvm锁机制；分布式锁机制
  - ​        3、有效期本身的缺陷
  - ​        解决方案：缓存永不过期，异步更新。
  - ​        优点：不阻塞线程，用户体验好，不会出现雪崩效应。
  - ​        缺点：不保证一致性，代码复杂度增大（每个value值都要维护异步更新代码），容易堆积垃圾数据。
  - 空查询导致的缓存穿透可以使用布隆过滤器，或者从db里查询到空数据时在缓存中设置空数据，并设置过期时间
  - 缓存击穿:SETNX。用锁来阻挡查询，锁完后load db，返回后写缓存，删锁

- #### 为什么要使用缓存？ 缓存的更新策略有哪些？怎么进行选择？

  - 减少数据库压力。https://blog.csdn.net/jsjwk/article/details/81775880

- #### 10G数据，数据都是int32位，内存只有1G，如何去除重复元素

  - Bitmap

- #### 中断

  - 中断分内中断和外中断
  - 外中断一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备 的中断请求。
  - 内部中断：是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断是不可屏蔽的中断。 软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序
  - 内中断有异常，陷阱，故障，终止

- #### 空class sizeof 是多少？

  - 1

# **语言**

- #### const 关键字的使用场景

- #### static 关键字的使用场景

- #### explict 关键字的使用场景

  - explicit关键字的作用就是防止类构造函数的隐式自动转换.
  - explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了

- #### volatile 关键字的使用场景

  - volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。
  - 如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象
  - 使用地方
    - \1) 中断服务程序中修改的供其它程序检测的变量需要加volatile； 
    - \2) 多任务环境下各任务间共享的标志应该加volatile； 
    - \3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义

- #### 什么是多态

- #### 虚函数的实现原理

- #### 构造函数可以是虚函数吗

- #### 析构函数可以是虚函数吗，应用场景

- #### 智能指针有哪些，实现原理以及用法

- #### 什么是模板特化

- #### 只能在栈上分配对象

- #### 只能在堆上分配对象

- #### new 和 malloc 区别

  - new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持
  - 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸
  - new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
  - new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
  -  new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
  - new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。
  - C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

- #### C++ 内存空间布局

- #### 为什么模板类放在.h中

- #### 如何限制对象只能在堆上创建

  - 可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。

- #### 如何限制对象只能在堆上创建

  - 只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可
  - 栈上：将构造函数设为私有

- #### 如何让类不能被继承

  - final关键字

- #### 什么是单例模式，工厂模式

- #### C++ auto 类型推导的原理

  - auto使用的是模板实参推断（Template Argument Deduction）的机制。auto被一个虚构的模板类型参数T替代，然后进行推断，即相当于把变量设为一个函数参数，将其传递给模板并推断为实参，auto相当于利用了其中进行的实参推断，承担了模板参数T的作用。
  - 唯一例外的是对初始化列表的推断，auto会将其视为std::initializer_list，而模板则不能对其推断

- #### 泛型编程如何实现的

- #### 指针和引用的区别

- #### 单继承，多继承（菱形继承）虚函数指针

- #### linux是怎么分配内存的

  - 内存
  - 虚拟内存
  - Buffer cache

- #### memset初始化一个类

  - 记住对于有虚拟函数的类对象，决不能使用memset来进行初始化操作，究其原因是因为初始化obj的时候，将obj包含的指向虚函数表VTBL的指针也清除了

- #### 多线程可以使用智能指针吗？

  - 多线程中可以使用智能指针，但是得加锁

- vector为什么是成倍扩容

  - 假定有 n 个元素,倍增因子为 m
  - 完成这 n 个元素往一个 vector 中的 push_back操作，需要重新分配内存的次数大约为 logm(n)
  - 第 i 次重新分配将会导致复制 m^i (也就是当前的vector.size() 大小)个旧空间中元素
    - Sigma(1~logm(n) m^i = 等比求和，首项m，公比m 大约就是n
  - n 次 push_back 操作所花费的时间复制度为O(n)
  - 均摊一次是O（1），vector 中 push_back 操作的时间复杂度为**常量时间**

# 网络

- #### 三次握手和四次挥手

- #### TIME_CLOSE 和 TIME_WAIT 的状态和意义

- #### CLOSE_WAIT等待时间的意义

- #### TIME_WAIT的时间可以修改吗

  - 可以的，setsocket

- #### TIME_WAIT太多怎么办，为什么

  - 在**高并发短连接**的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。
  - 原因：对于一个处理大量短连接的服务器，如果是由服务器主动关闭客户端的连接，将导致服务器存在大量的处于TIME_WAIT状态的socket，严重影响服务器的处理能力，甚至耗尽可用的socket
  - 解决办法：修改参数TcpTimedWaitDelay，缩短 TIME_WAIT 的等待时间。

- #### TIME_WAIT存在的意义是什么

  - 保证对端收到最后一个ACK（否则对端可能会重发FIN）
  - 保证延迟数据段过期（否则新连接可能会收到旧连接的包）

https://draveness.me/whys-the-design-tcp-time-wait/

- #### 设置SO_REUSEADDR之后如果收到上一个连接的数据包怎么办？

- #### TCP 如何保证可靠传输

- #### 流量控制和拥塞控制

- #### CRC 循环校验的算法

- #### 如何使用 UDP 实现可靠传输

- #### 为什么不能是两次握手

- #### SYN FLOOD 是什么

  - Syn-Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问

- #### HTTPs 和 HTTP 的区别

- #### HTTPS 的原理，客户端为什么信任第三方证书

- #### HTTP 方法了解哪些

- #### HTTP 异常状态码知道哪些

- #### HTTP 长连接短连接使用场景是什么

- #### Arp 攻击

- #### NAT 原理

- #### DNS 服务器与提供内容的服务器的区别

- #### 怎么实现 DNS 劫持

- #### 对称加密和非对称的区别，非对称加密有哪些

- #### AES 的过程

- #### 安全攻击有哪些

- #### DDOS 有哪些，如何防范

- #### tpc最多超级重传多少次

  - Linux有两个参数限制超时重传次数tcp_retries1 ，tcp_retries2 
  -  如果超时发生在三次握手期间，此时有专门的tcp_syn_retries来负责限定重传次数
  - 一旦重传超过阈值tcp_retries1，主要的动作就是更新路由缓存
  -  重传超过tcp_retries2会直接放弃重传，关闭TCP流

- ##### 在 TCP 建立连接的三次握手连接阶段，如果客户端发送的第三个ACK包丢了，那么客户端和服务端分别进行什么处理呢？

  - Server 端
    - 第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。
    - 而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.
    - 如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。
  - Client 端
    - 在linux c 中，client 一般是通过 connect() 函数来连接服务器的，而connect()是在 TCP的三次握手的第二次握手完成后就成功返回值。也就是说 client 在接收到 SYN+ACK包，它的TCP连接状态就为 established （已连接），表示该连接已经建立。那么如果 第三次握手中的ACK包丢失的情况下，Client 向 server端发送数据，Server端将以 RST包响应，方能感知到Server的错误。

- #### SSL和TLS

  - 对称加密算法
    - DES(56bit)
    - triple-DES（最长168bit的密钥）
    - AES（最高256bit的密钥）
  - 非对称加密
    - RSA
  - 非对称加密的安全隐患
    - public key（网络传递）被拦截篡改
  - CA
    - 加密pubilc key，传递的是CA加密之后的数字证书
    - CA把自己的CA证书集成在了浏览器和操作系统里面。A拿到浏览器或者操作系统的时候，已经有了CA证书，没有必要通过网络获取，那自然也不存在劫持的问题（不在CA体系里面，没有CA的private key）
    - CA证书被篡改了（可以继续攻击）

- TCP场景下，如果传送多个小包，如何实现更优的传递

https://www.cnblogs.com/williamjie/p/9390308.html

# 数据结构

- #### vector 底层实现

- #### 如何控制 vector 的内存分配

- #### map, hashmap 底层实现

- #### map 的 key 如果是结构体需要注意什么问题

- #### hash冲突如何解决

# 数据库

- #### mysql 索引

  - 普通索引index :加速查找
  - 唯一索引
    - 主键索引：primary key ：加速查找+约束（不为空且唯一）
    - 唯一索引：unique：加速查找+约束 （唯一）
  - 联合索引
    - primary key(id,name):联合主键索引
    - unique(id,name):联合唯一索引
    - index(id,name):联合普通索引
  - 全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。
  - 空间索引spatial :了解就好，几乎不用

- #### B 和 B+ 区别

  - B树的每个节点存储了key和data，key是一条数据记录的键值，是唯一的，data存储的是数据记录除key以外的数据。而B+树只在叶子节点存储data数据，这样非叶子节点就能存储更多的key。所以B+树相较于B树来说更加的矮胖，因为索引树很大不能一次IO读取进内存，树的深度越浅，查找数据时IO的次数就越少，效率就更快。

1. B+树的每个叶子节点的指针指向相邻的叶子节点，构成一个有序链表，可以按照关键码排序的次序遍历全部记录。由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树叶子节点指针为null，则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

- #### Redis 的数据结构

  - String类型
  - Mapmap
  - List（双端的）
  - Set
  - Zset
    - ziplist
      - ziplist 是一个紧挨着的存储空间，并且是没有预留空间的，随意对于ziplist优势在于节省空间，但是在容量大到一定程度扩容就是影响他的性能的主要原因之一（会在下面两种情况下转为skipList）
        - ziplist所保存的元素超过服务器属性server.zset_max_ziplist_entries 的值（默认值为 128 ）
        - 新添加元素的 member 的长度大于服务器属性 server.zset_max_ziplist_value 的值（默认值为 64）
    - skipList
      - Redis 的跳跃表共有 64 层，意味着最多可以容纳 2^64 次方个元素。每一个 kv 块对应的结构如下面的代码中的 zslnode 结构，kvheader 也是这个结构
      - 链表和二分查找
      - 插入
        - 随机计算层数的zslRandomLevel() :注意p值由`ZSKIPLIST_P`常量定义，值为0.25，即被插入到高层的概率为1/4。

```C%2B%2B
int zslRandomLevel(void) { int level = 1; while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF)) level += 1; return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL; }
```

- #### Redis持久化

  - RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。
    - save、bgsave、自动化
  - 全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。

- #### AOF 重写

(1) 随着AOF文件越来越大，里面会有大部分是重复命令或者可以合并的命令（100次incr = set key 100）

(2) 重写的好处：减少AOF日志尺寸，减少内存占用，加快数据库恢复时间。

- AOF重写功能：Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个文件所保存的数据库状态是相同的，但是新的AOF文件不会包含任何浪费空间的冗余命令，通常体积会较旧AOF文件小很多。

- #### 渐进式Rehash

  - 因为在进行渐进式 rehash 的过程中， 字典会同时使用 `ht[0]` 和 `ht[1]` 两个哈希表， 所以在渐进式 rehash 进行期间，     字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 `ht[0]` 里面进行查找， 如果没找到的话， 就会继续到 `ht[1]` 里面进行查找， 诸如此类。
  - 另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 `ht[1]` 里面， 而 `ht[0]` 则不再进行任何添加操作： 这一措施保证了 `ht[0]` 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表

- #### 一致性 Hash

  - 一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，有很好的容错性和可扩展性。
  - 一致性Hash算法引入了`虚拟节点机制`，即对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。数据定位算法不变，只需要增加一步：虚拟节点到实际点的映射。

![img](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=MmQ3MDdiN2RiMWQ0NzA5YWNjMjNkZTk0YzhlYTFhYmJfSkVFaTJGUGRWNWpDbm5BdUVGa1NUM25hQUx2SVJuMGFfVG9rZW46Ym94Y25lSHhqa21yNldZRXZtelZUNzlJbUNoXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)



- 根据一致性哈希算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。
- 下面分析一致性哈希算法的容错性和可扩展性。现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。
- **综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。**

- #### Redis 集群哈希槽

- #### Redis 集群高可用

  - 主从同步
    - 主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。

- #### Redis KEY 过期策略

  - **惰性删除**：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key（无法保证冷数据被及时删掉）
  - **定期删除**：Redis会定期主动淘汰一批已过期的key（随机抽取一批key检查）
  - **内存淘汰机制**：当前已用内存超过maxmemory限定时，触发主动清理策略

- #### 数据库注入的过程，如何防范

- #### MVCC

  - InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id，这是事务在启动的时候向系统申请的，是按照申请顺序递增的；
  - 而每行存储的数据也是有多个版本的，每次更新数据的时候都会生成一个新的数据版本，并且把当前事务的transaction id赋值给数据版本，计做row_trx_id，在同一行数据中会保存多个版本的数据（如下图），每个版本都有自己的row_trx_id，然后在新的数据版本中可以通过指针拿到旧的数据版本；

1. DB_ROW_ID：行id，如果有主键就没有这一列；
2. DB_TRX_ID：记录插入或者更新该行数据的事务ID
3. DB_ROLL_PTR：回滚指针，指向undo log记录；通过回滚指针连接同一条数据的多个版本，形成一个版本链；

- #### redo log、binlog、undo log 区别与作用

  - redo log(重做日志)：
    - redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。
  - binlog（二进制日志）
    - binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠binlog是没有`crash-safe`能力的
  - redo log和binlog区别
    - redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。
    - redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑
    - redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。
    - binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。
  - 回滚日志（undo log）
    - 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读

- #### 为什么用B+树做索引，不用hash呢

  - 哈希表是把索引字段映射成对应的哈希码然后再存放在对应的位置，这样的话，如果我们要进行模糊查找的话，显然哈希表这种结构是不支持的，只能遍历这个表。而B+树则可以通过最左前缀原则快速找到对应的数据。
  - 如果我们要进行范围查找，例如查找ID为100 ~ 400的人，哈希表同样不支持，只能遍历全表。
  - 索引字段通过哈希映射成哈希码，如果很多字段都刚好映射到相同值的哈希码的话，那么形成的索引结构将会是一条很长的链表，这样的话，查找的时间就会大大增加。

- #### 主键索引和非主键索引的区别

  - https://www.cnblogs.com/jiawen010/p/11805241.html

  - 非主键索引的叶子节点存放的是

    主键的值

    ，而主键索引的叶子节点存放的是

    整行数据

    ，其中非主键索引也被称为

    二级索引

    ，而主键索引也被称为

    聚簇索引

    。

    - 如果查询语句是 select * from table where ID = 100,即**主键查询的方式**，则只需要搜索 ID 这棵 B+树。
    - 如果查询语句是 select * from table where k = 1，即**非主键的查询方式**，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，这个过程也被称为**回表**。

- #### 如何用redis实现分布式锁

  - SETNX，命令
  - 互斥性：任意时刻只能有一个客户端拥有锁，不能同时多个客户端获取
  - 安全性：锁只能被持有该锁的用户删除，而不能被其他用户删除
  - 死锁：获取锁的客户端因为某些原因而宕机，而未能释放锁，其他客户端无法获取此锁，需要有机制来避免该类问题的发生
  - 容错：当部分节点宕机，客户端仍能获取锁或者释放锁

- #### redis扩容和收缩

- #### **覆盖索引**

  - 解释一： 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。
  - 解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。
  - 解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。



- 覆盖索引必须要存储索引的列，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引

# 操作系统

- #### 内存分配malloc流程

1. 获取分配区的锁，防止多线程冲突。
2. 计算出实际需要分配的内存的chunk实际大小。
3. 判断chunk的大小，如果小于max_fast（64Ｂ），则尝试去fast bins上取适合的chunk，如果有则分配结束。否则，下一步；
4. 判断chunk大小是否小于512B，如果是，则从small bins上去查找chunk，如果有合适的，则分配结束。否则下一步；
5. ptmalloc首先会遍历fast bins中的chunk，将相邻的chunk进行合并，并链接到unsorted bin中然后遍历 unsorted bins。如果unsorted bins上只有一个chunk并且大于待分配的chunk，则进行切割，并且剩余的chunk继续扔回unsorted bins；如果unsorted bins上有大小和待分配chunk相等的，则返回，并从unsorted bins删除；如果unsorted bins中的某一chunk大小 属于small bins的范围，则放入small bins的头部；如果unsorted bins中的某一chunk大小 属于large bins的范围，则找到合适的位置放入。若未分配成功，转入下一步；
6. 从large bins中查找找到合适的chunk之后，然后进行切割，一部分分配给用户，剩下的放入unsorted bin中。
7. 如果搜索fast bins和bins都没有找到合适的chunk，那么就需要操作top chunk来进行分配了
8. 当top chunk大小比用户所请求大小还大的时候，top chunk会分为两个部分：User chunk（用户请求大小）和Remainder chunk（剩余大小）。其中Remainder chunk成为新的top chunk。
9. 　　当top chunk大小小于用户所请求的大小时，top chunk就通过sbrk（main arena）或mmap（thread arena）系统调用来扩容。
10. 到了这一步，说明 top chunk 也不能满足分配要求，所以，于是就有了两个选择: 如 果是主分配区，调用 sbrk()，增加 top chunk 大小；如果是非主分配区，调用 mmap 来分配一个新的 sub-heap，增加 top chunk 大小；或者使用 mmap()来直接分配。在 这里，需要依靠 chunk 的大小来决定到底使用哪种方法。判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值，如果是的话，则转下一步，调用 mmap 分配， 否则跳到第 10 步，增加 top chunk 的大小。
11. 使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。 然后将内存指针返回给用户。
12. 判断是否为第一次调用 malloc，若是主分配区，则需要进行一次初始化工作，分配 一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap。若已经初 始化过了，主分配区则调用 sbrk()增加 heap 空间，分主分配区则在 top chunk 中切 割出一个 chunk，使之满足分配需求，并将内存指针返回给用户。

- #### 怎么通过逻辑地址找到物理地址  

  -  逻辑地址由段基值和偏移量组成，16乘以段基值加上偏移量就是物理地址。<------得看分页还是分段还是段页式

- #### 进程和线程的区别

  - 进程是执行中的一段程序，而一个进程中执行中的每个任务即为一个线程
  - 一个线程只可以属于一个进程，但一个进程能包含多个线程
  - 线程无地址空间，它包括在进程的地址空间里
  - 线程的开销或代价比进程的小

- #### 进程间的通讯方式

- #### 进程切换的上下文细节

- #### 线程切换的上下文细节

- #### CPU 的最小调度单位

  - 线程

- #### 多线程同步、多进程通信方式

  - 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
  - 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
  - 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
  - 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
  - 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
  - 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
  - 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
  - 线程间通信：
  - 1.互斥锁
  -  mutex;
  -  lock_guard (在构造函数里加锁，在析构函数里解锁）
  -  `unique_lock` 自动加锁、解锁
  - 2.读写锁
  -  `shared_lock`
  - 3.信号量

1.  c++11中未实现，可以自己使用mutex和conditon_variable 实现

- #### 操作系统的栈和堆的区别

  - **栈（操作系统）**：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈，栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放
  - **堆（操作系统）**： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些

- #### 用户态和内核态的区别

  - 内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态**；**
  - 当程序运行在0级特权级上时，就可以称之为运行在内核态
  - 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。
  - **处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的**
  - **处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。**

- #### 用户态和内核态切换的代价

  - 系统调用一般都需要保存用户程序得上下文(context), 在进入内核得时候需要保存用户态得寄存器，在内核态返回用户态得时候会恢复这些寄存器得内容。这是一个开销的地方。 如果需要在不同用户程序间切换的话，那么还要更新cr3寄存器，这样会更换每个程序的虚拟内存到物理内存映射表的地址，也是一个比较高负担的操作

- #### errno

  - errno 是记录系统调用的最后一次错误代码
  - 什么时候会修改
    - 所以在用 errno 时必须调用放手动置 errno 为 0, 系统提供的 api 内部是不会去将 errno 置为 0 的
    - 因为 errno 是全局的，整个线程都生效，在一个很大的项目中，errno 在哪里不小心被置为非 0 值是极有可能的，因此，需要使用者非常小心。

- #### fork 的过程

![img](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=ODE2NGZhYmI2NDMzY2M0NTNkNmI1MDkzM2Q4OTYzYTNfQzFyaWxyZnZxZ05GQ3F3bmlJRmNOeE5tQVhkSnNRWHNfVG9rZW46Ym94Y25kVkFhUmcwekVrU0xHUWZyV2VUZFhnXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)



- #### 内存置换算法

  - 最佳置换算法(OPT)
  - 先进先出(FIFO)页面置换算法
  - 最近最久未使用(LRU)置换算法
  - 时钟(CLOCK)置换算法 

- #### 什么是虚拟内存，作用

  - 虚拟内存是一种计算机系统内存管理技术。它使得应用程序认为它拥有连续可用的内存，即一个连续完整的地址空间。而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。
    - 虚拟内存地址空间是连续的，没有碎片
    - 虚拟内存的最大空间就是cpu的最大寻址空间，不受内存大小的限制，能提供比内存更大的地址空间

- #### Select，poll，epoll的区别

- #### epoll 的 LT 和 ET 的区别

  - ET： fd成non_blocking,且epoll_wait返回后把事件read到EAGAIN为止
  - 应用层缓冲区不够，需要在应用层记录下该fd还未读完

- #### 什么情况下会发生缺页中断，具体流程

  - 当访问一个还末调入（还不在）内存区的页面时便会发生缺页中断.当发生这种缺页中断时，操作系统检验该访问是否合法，若不合法，则中止该程序；若合法，则查寻出一空闲块并请求I/O把所需的页面读入该空闲块，一量I/O完成就更新进程表和页表并重新执行这一指令.

- #### 如何判断逻辑地址是否已经映射在物理地址上了..

  - 逻辑地址：在具有地址变换功能的计算机中，访问指令给出的操作数。
  - 物理地址：用于内存芯片级单元寻址，与CPU连接的地址总线相对应。
  - 线性地址：逻辑地址和物理地址转换的中间层，即硬件平台页式转换前的地址。

- #### docker

  - Linux容器
    - Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离，就像是给正常的进程外面套了一个保护层，对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。
  - Docker和Linux容器是什么关系
    - Docker属于Linux容器一种封装，提供简单易用的容器使用接口；它将应用程序与该程序的依赖打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机运行一样
  - docker与虚拟机的区别
    - Docker 是一个能把开发的应用程序自动部署到容器的开源引擎
    - 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作

![img](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ5OGFlOTBiZGMxMTkwMDc2ZTE0NDE0MDUwYTZiMWZfZk4zUlRMb2pWWDhIZEs5Vk1IbDNDRjlIUFprZ2dLcGNfVG9rZW46Ym94Y25JbzRHb1IzS0J1VnFiNmpNUHMzVzFYXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

- 虚拟机是在一台物理机上，利用虚拟化技术，虚拟出来多个操作系统，每个操作系统之间是隔离的。
- (1) docker是开源的应用容器引擎，依然需要先在电脑上安装操作系统，然后安装Docker容器管理器。
- (2) 虚拟机是在硬件级别进行虚拟化,而docker是在操作系统的层面虚拟化
- (3) 虚拟机是通过模拟硬件搭建操作系统,而docker则是复用操作系统
- (4) 虚拟机实现了操作系统之间的隔离,docker只是进程之间的隔离,所以虚拟机的隔离级别更高,安全性更强
- (5) docker的运行速度更快
- (6) docker的文件要小的多,虚拟机要大

- #### 页表所在的位置

  - 进程内存空间里

- #### 环形缓冲区的好处（循环队列）

  - 数据迁移少

- #### 动态链接和静态链接

  - 静态链接的缺点很明显，一是浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本；另一方面就是更新比较困难，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。
  - 动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失

- #### 怎么查看端口号占用情况

  - Netstat -nap | grep xxx

- #### 段页式存储一般要访问几次内存

  - 一般是三次
    - 第一次由段表地址寄存器得段表始址后访问段表，由此取出对应段的页表在内存中的地址。 
    - 第二次则是访问页表得到所要访问的物理地址。
    - 第三次才能访问真正需要访问的物理单元。

- #### 段页式管理的实现原理

  - 虚地址的构成
    - 虚拟空间的最小单位是页而不是段，从而内存可用区也就被划分成为着干个大小相等的页面，且每段所拥有的程序和数据在内存中可以分开存放。分段的大小也不再受内存可用区的限制。
  - 段表和页表
    - 系统必须为每个作业或进程建立一张段表以管理内存分配与释放、缺段处理、存储保护相地址变换等。另外，由于一个段又被划分成了若干页，每个段又必须建立一张页表以把段中的虚页变换成内存中的实际页面。
  - 动态地址变换过程
    - 在一般使用段页式存储管理方式的计算机系统中，都在内存中辟出一块固定的区域存放进程的段表和页表。

- #### 死锁

  - 是指两个或两个以上的进程（线程）在执行过程中，因**争夺资源**而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。 由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程（线程）在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。
  - 原因
    - 系统资源不足；
    - 进程（线程）推进的顺序不恰当；
    - 资源分配不当。
  - 形成场景
    - 忘记释放锁：在申请锁和释放锁之间直接return
    - 单线程重复申请锁：一个线程，刚出临界区，又去申请资源。
    - 多线程多锁申请：两个线程，两个锁，他们都已经申请了一个锁了，都想申请对方的锁
    - 环形锁的申请：多个线程申请锁的顺序形成相互依赖的环形
  - 死锁的条件
    - **互斥条件：**简单的说就是进程抢夺的资源必须是临界资源，一段时间内，该资源只能同时被一个进程所占有。
    - **请求和保持条件**：当一个进程持有了一个（或者更多）资源，申请另外的资源的时候发现申请的资源被其他进程所持有，当前进程阻塞，但不会释放自己所持有的资源。
    - **不可抢占条件：**进程已经获得的资源在未使用完毕的情况下不可被其他进程所抢占在很多情况下这些条件都是合乎要求的
    - **循环等待条件：**存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源。
  - 预防死锁
    - 打破条件。。哈哈哈
  - 死锁避免
    - 有序资源分配法
    - 银行家算法（最具有代表性）

- #### 函数调用过程：

函数调用大致包括以下几个步骤：

参数入栈：将参数从右向左依次压入系统栈中

返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行

代码区跳转：处理器从当前代码区跳转到被调用函数的入口处

栈帧调整：具体包括保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP入栈）

将当前栈帧切换到新栈帧。（将ESP值装入EBP，更新栈帧底部）

给新栈帧分配空间。（把ESP减去所需空间的大小，抬高栈顶）



- #### 函数返回的步骤如下：

 　　<1>保存返回值，通常将函数的返回值保存在寄存器EAX中。

 　　<2>弹出当前帧，恢复上一个栈帧。具体包括：

​    　　(1)在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间。

​    　　(2)将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复出上一个栈帧。

​    　　(3)将函数返回地址弹给EIP寄存器。

 　　<3>跳转：按照函数返回地址跳回母函数中继续执行。

# 算法

- https://blog.csdn.net/Code_star_one/article/details/109600676



- #### 两个排序数组找中位数

- #### [平衡二叉树](https://huanle.feishu.cn/jump/super-jump/word?word=平衡二叉树)的特点价值，查找效率

  - 所有叶子节点高度差不超过1，log(n)

- #### 为什么使用[红黑树](https://huanle.feishu.cn/jump/super-jump/word?word=红黑树)

  - AVL树的自旋比较耗时，需要折中自旋耗时以及最差情况的查询耗时，红黑树最长链不超过最短链的两倍

- #### 手写快排

```C%2B%2B
//快速排序
void quick_sort(int s[], int l, int r)
{
    if (l < r)
    {
        //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1
        int i = l, j = r, x = s[l];
        while (i < j)
        {
            while(i < j && s[j] >= x) // 从右向左找第一个小于x的数
                j--;  
            if(i < j) 
                s[i++] = s[j];
            
            while(i < j && s[i] < x) // 从左向右找第一个大于等于x的数
                i++;  
            if(i < j) 
                s[j--] = s[i];
        }
        s[i] = x;
        quick_sort(s, l, i - 1); // 递归调用 
        quick_sort(s, i + 1, r);
    }
}
//快速排序
void quick_sort(int arr[], int L, int R){
  if(L>R){
     return;
  }
  //随机一个L到R的数，与R交换；swap(arr,L,R)是伪代码，交换arr中的L,R
  swap(arr,L+(int)(Math.random()*(R-L+1)),R)
  //border[]荷兰国旗问题相等的两边界
  int[]border=getBorder(arr,L,R);
  quick_sort(arr,L,border[0]-1);
  quick_sort(arr,border[1]+1,R);
}


int[] getBorder(int arr[], int L, int R){
  if(L==R){
      return new int[]{L,R};
  }
  int index=L;
  int pL=L-1;
  int pR=R;
  while(index<=pR){
      if(arr[index]==arr[R]){
          index++;
      }else if(arr[index]>arr[R]){
          swap(arr,index,--pR);
      }else{
          swap(arr,index++,++pL);
      }
  }
  swap(arr,pR,R);
  return new int[]{pL+1,pR};
}
```

- #### 快排在什么情况下时间复杂度会比较高

  - 需要排序的序列与目标数组反置