# C++

## 多态与继承

### 运行时多态和编译时多态  重载和继承

### 怎样理解C++多态特性

- 基类指针可以访问子类对象、需要继承、虚函数重写

### 函数的多态讲一下？

#### 静态多态（编译时）

重载（相同函数名，不同的参数列表），编译时会生成不同的函数符号

#### 动态多态（运行时）

重写（子类重写基类中的虚函数），虽然在编译时，已经确定各个类中的虚函数表，但是当基类指针指向子类实例的时候，具体执行的函数由子类实例中虚指针指向的虚函数表决定

### 重载的原理

- 重载的函数在编译时产生不同的符号名

### 继承的底层原理

- 继承方式、虚函数、派生类对象的析构
- 重写虚函数表

### 继承条件下对象构造析构顺序是否可以改变 即先构造子类再构造父类

### 单继承，多继承（菱形继承）虚函数指针

## 虚函数

### 虚函数讲一下？

#### 虚函数
- Virtual关键字，有函数体，子类可重写
#### 纯虚函数
- virtual关键字，且 virtual func()= 0；，包含纯虚函数的 类是抽象类，不可实例化
- 通过虚函数表实现，编译时类的虚函数表已经确定，运行时类实例中通过虚指针索引到类的虚函数表，调用时查表查询具体执行的函数
- 析构可以是虚函数，并且基类的虚构一般建议是虚函数，否则可能会导致子类析构无法调用导致内存溢出

### C++ 的构造函数可以是虚函数吗？

- 不可以，虚函数表在构造函数中构造，如果构造函数为虚函数，找不到虚函数表

### c++ 的析构函数可以是纯虚函数

- 可以，编译器允许这么做，但是需要手动实现，不然子类无法实例化。
- 纯虚函数还是可以实现的

### 析构函数不加virtual会发生什么，原理。

- 基类指针先调用析构，子类对象有空间没释放，造成内存泄漏

### C++ STL用过吗，讲讲迭代器分为哪几种类型

![迭代器类型](https://huanle.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzg1M2NiMWI3MWZiNjgwMTNjYTg1NGYxOTBjMzIwNjFfWUZ4MGh6WlpuZ2RmZkdUdnRvY0JoU3hkTHhsbFV0ckNfVG9rZW46Ym94Y25jNmZMMEVkdUdsWnpUMkxlS1VXNWZjXzE3NjQ2NDgxNDY6MTc2NDY1MTc0Nl9WNA)

- vector是随机访问迭代器，list是双向迭代器
- 对每个迭代器参数而言，其能力必须与规定的最低类别至少相当。向算法传递一个能力更差的迭代器会产生错误！
- 如sort通用排序算法，要求其迭代器参数是随即访问迭代器。由于array、deque、vector、string所提供的迭代器都是随即访问迭代器(用于访问内置数组的指针也是)，所以均可使用该sort通用排序算法。而list和forward_list提供的是双向和前向迭代器，因此这两个顺序容器类型不能使用通用的sort排序算法。

### 虚函数表

### 虚函数如何实现的，具体调用过程，如何实现的多态

- https://www.jianshu.com/p/587ab12f7c88

### C++虚函数表、函数重载、函数重写（override）特性？

- 重载是同一个类中有相同函数名，不同参数个数/列表的函数
- 重写是子类对父类virtual方法的重写
- C++通过虚函数表来实现多态

## 关键字

### const 关键字的使用场景

### Const理解

- const int a;  int const a; const int* a; int* const a; const int* const a;
- 指针指向const对象的地址，用指针来修改

### Const 函数？ 普通指针优先调用const成员还是非const成员？放在函数前后有什么区别？

- 函数后加const修饰符，表示该函数内不能修改成员变量，编译期检查报错，可以被const和非const对象调用
- const对象优先调用const函数，非const对象优先调用非const函数，在编译器决定，编译器会根据对象的const属性优先匹配对应的函数（编译期对象的const属性已知）
- 函数前表示返回对象不可修改，函数后表示不能修改成员变量

### const放在函数前和放在函数后有什么区别

- 放在前面代表返回值为不可修改的
- 放在后面表示传入的this指针为只读，不可修改对象内属性

### static 关键字的使用场景

### static和全局变量有什么区别

- static变量只能在本文件中使用

### explict 关键字的使用场景

- explicit关键字的作用就是防止类构造函数的隐式自动转换.
- explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了

### volatile 关键字的使用场景

- volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。
- 如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象
- 使用地方
  - \1) 中断服务程序中修改的供其它程序检测的变量需要加volatile；
  - \2) 多任务环境下各任务间共享的标志应该加volatile；
  - \3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义

### extern 关键字

- 函数的声明extern关键词是可有可无的，因为函数本身不加修饰的话就是extern。但是引用的时候一样需要声明的
- 全局变量在外部使用声明时，extern关键字是必须的，如果变量没有extern修饰且没有显式的初始化，同样成为变量的定义，因此此时必须加extern，而编译器在此标记存储空间在执行时加载内并初始化为0。而局部变量的声明不能有extern的修饰，且局部变量在运行时才在堆栈部分分配内存。
- 全局变量或函数本质上讲没有区别，函数名是指向函数二进制块开头处的指针。而全局变量是在函数外部声明的变量。函数名也在函数外，因此函数也是全局的

## 内存管理

### new 和 malloc 区别

- new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持
- 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸
- new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
- new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
- new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
- new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。
- C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

### C++ new和c语言的malloc的区别？

- new不用指定申请空间大小，malloc要指定大小
- new用delete释放，malloc用free释放
- new是关键字，malloc是函数
- new申请空间并调用构造函数
- new返回对象类型的指针、malloc返回void*

### free()函数入参是一个void*指针，它是如何知道被指向的大小的？

- 假设你用malloc需要申请100字节，实际是申请了104个字节。把前4字节存成该块内存的实际大小，并把前4字节后的地址返回给你。 free释放的时候会根据传入的地址向前偏移4个字节 从这4字节获取具体的内存块大小并释放。

### 浅拷贝，深拷贝

- 类的对象有堆上内存时，直接赋值后的对象内成员指针指向原数据的成员指针所指的内存，需要拷贝后才是深拷贝

### memset初始化一个类

- 记住对于有虚拟函数的类对象，决不能使用memset来进行初始化操作，究其原因是因为初始化obj的时候，将obj包含的指向虚函数表VTBL的指针也清除了

### 只能在栈上分配对象

### 只能在堆上分配对象

### 如何限制对象只能在堆上创建

- 可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。

### 如何限制对象只能在堆上创建

- 只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可
- 栈上：将构造函数设为私有

## 智能指针

### 智能指针有哪些，实现原理以及用法

### C++智能指针特性

- unique_ptr,shared_ptr,weak_ptr.唯一指针、引用计数、防止shared_ptr循环

### 智能指针知道吗？

- shared_ptr、weak_ptr、unique_ptr

### 多线程可以使用智能指针吗？

- 多线程中可以使用智能指针，但是得加锁

## STL容器

### list和vector实现有什么区别？讲讲vector的resize操作？

- list是链表，不连续的空间，不支持随机访问
- vector是可扩容的数组，连续的空间，支持随机访问
- resize的大小与当前vector占用空间进行对比，如果小于就不改占用空间大小，只改动end()的位置，如果大于当前空间大小，则重新申请空间并拷贝

### vector 底层实现

### vector的底层存储

- 元素大小，空间大小，元素大于空间会重新申请空间，拷贝，释放旧空间，使用新空间

### 如何控制 vector 的内存分配

### 什么是迭代器失效？

- 迭代器的里指针不再指向原来的数据
- vector在添加、删除、swap之后都会造成迭代器失效

### vector为什么是成倍扩容

- 假定有 n 个元素,倍增因子为 m
- 完成这 n 个元素往一个 vector 中的 push_back操作，需要重新分配内存的次数大约为 logm(n)
- 第 i 次重新分配将会导致复制 m^i (也就是当前的vector.size() 大小)个旧空间中元素
  - Sigma(1~logm(n) m^i = 等比求和，首项m，公比m 大约就是n
- n 次 push_back 操作所花费的时间复制度为O(n)
- 均摊一次是O（1），vector 中 push_back 操作的时间复杂度为**常量时间**

### STL有使用过哪些呢？我回答了vector、list、pair，后续又追问vector是个什么呢？链表你使用的哪个呢？pair是个什么？什么情况下使用的？

- vector是个可动态扩容的数组，

### 你知道map吗？怎么实现的？我回答了STL里面的map，底层使用了红黑树，后续追问红黑树是什么呢？有什么特点？红黑树自平衡是自动平衡吗？怎么实现自平衡的？红黑树和普通的二叉树有什么区别呢？

- 根节点是黑的
- 红节点不会相连
- 红节点的子节点全是黑节点
- 最长链的长度不会超过最短链的两倍
- 叶子节点都是黑的
- 任意节点到叶子的路径都有相同数量的黑色节点

### map, hashmap 底层实现

### map 的 key 如果是结构体需要注意什么问题

### map的存储结构

- 红黑树，unordered_map是哈希表

### map、unorder_map？

- map红黑树
- unordered_map 是哈希表

### map和unordered_map的优缺点，适用于什么场景？

- map基于红黑树、unordered_map基于哈希表，

## 类型转换

### dynamic_cast是干嘛的？转换错误会返回什么？

- 基类向子类的转化，做检查
- 指针失败返回null，引用失败抛出异常

### C++ auto 类型推导的原理

- auto使用的是模板实参推断（Template Argument Deduction）的机制。auto被一个虚构的模板类型参数T替代，然后进行推断，即相当于把变量设为一个函数参数，将其传递给模板并推断为实参，auto相当于利用了其中进行的实参推断，承担了模板参数T的作用。
- 唯一例外的是对初始化列表的推断，auto会将其视为std::initializer_list，而模板则不能对其推断

## 其他

### #define和const的区别？

- define是在预编译时做文本替换，const常量在编译时处理
- define没有类型，const有类型
- define还可以指定函数，const不行

### char arr[20]和char *p = new char[20]的区别？初始化和未初始化的情况？

- 前一个分配到栈上，后一个分配到堆上
- 前一个首地址就是数组的起始地址，后一个返回的是个指针，指向数组头
- 前一个不初始化、后一个初始化

### 指针和引用的区别

- 指针有自己的地址，指向变量
- 引用只是变量的别名，跟变量的地址相同
- 指针可以为空，引用不可以为空
- 指针所指对象可以改变，引用不行

### 指针和引用的区别？

- 指针有自己的地址，指向变量
- 引用只是变量的别名，跟变量的地址相同
- 指针可以为空，引用不可以为空
- 指针所指对象可以改变，引用不行

### 右值特性

- 右值不可被复制、可以减少拷贝的消耗、临时值

### C++11有哪些新特性？

- C++11 最常用的新特性如下：auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导
- nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。
- 智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。
- 初始化列表：使用初始化列表来对类进行初始化
- 右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
- atomic原子操作用于多线程资源互斥操作
- 新增STL容器array以及tuple

### C++ lambda表达式的特性，什么情况下使用？

- 在函数内实现
- 可以获取上下文变量,拷贝、引用
- 简洁、不想在类内写一个函数、无复杂逻辑

### 内联函数？

- inline关键字声明的函数，核心目的是为了减少函数调用开销，发生在编译时，编译器根据情况将函数在调用处直接展开
- 相比于宏更安全，编译期有类型检查等等
- 但可能会增加代码体积，导致编译过慢等等

### 宏

- 发生在预处理阶段（文本替换）没有类型检查等，适合简单的计算，包含有参宏和无参宏
- 副作用是可能导致重复计算，解决是每个变量都加上()

### 内联函数有了解吗？内联函数和宏定义有什么区别？

- （1）什么是内联函数？
- 内联函数是指那些定义在类体内的成员函数，即该函数的函数体放在类体内。
- （2）为什么要引入内联函数？
-  当然，引入内联函数的主要目的是：解决程序中函数调用的效率问题。另外，前面我们讲到了宏，里面有这么一个例子：
-  \#define ABS(x) ((x)>0? (x):-(x))
-  当++i出现时，宏就会歪曲我们的意思，换句话说就是：宏的定义很容易产生二意性。
- 我们可以看到宏有一些难以避免的问题，怎么解决呢？前面我们已经尽力替换了。
- （3）为什么inline能取代宏？
-  inline 定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，（像宏一样展开），没有了调用的开销，效率也很高。
-  很明显，类的内联函数也是一个真正的函数，编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。
-  inline 可以作为某个类的成员函数，当然就可以在其中使用所在类的保护成员及私有成员。
- （4）内联函数和宏的区别？
- 内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联欢函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关上内联扩展，将与一般函数一样进行调用，比较方便。
- （5）什么时候用内联函数？
-  内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话，将会获得比较好的效率。
-  （7）内联函数的优缺点？
- 我们可以把它作为一般的函数一样调用，但是由于内联函数在需要的时候，会像宏一样展开，所以执行速度确比一般函数的执行速度要快。当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。(换句话说就是，你使用内联函数，只不过是向编译器提出一个申请，编译器可以拒绝你的申请）这样，内联函数就和普通函数执行效率一样了。

### 什么是模板特化

### 泛型编程如何实现的

### 接着面试官又问了一些C++模板方面的问题

- 先给了三个重载函数（普通函数、函数模板、特例化的函数模板），根据入参确定调用的函数。接着又问了类型萃取的问题，如何使用模板来判断入参是一个类对象指针，还是一个内置类型指针。

### 变量的声明和定义有什么区别呢？变量的声明和定义在编译和链接阶段有什么区别呢？

- 定义只能一个，声明可以有多个，编译时只需要有声明，链接时会根据声明去符号表里面找定义，没有定义则链接失败

### C++生成EXE可执行文件需要包含哪些要素(可以说说具体每步干了啥)

- 预编译
- 编译
- 汇编
- 链接

### 学过编译原理吗 说下c++转成exe过程（不知道该说编译过程还是编译 链接什么的，回答的是前者，词法分析语法分析云云）

.c,.h文件  经过**预处理器** 生成 .i中间文件 经过**c编译器**生成 .s汇编文件 经过**汇编器** 生成 .o 可重定位文件 经过**链接器**生成 可执行文件

可重定位文件：

### C++对象生成时，该对象内存结构是怎样的

- 基类的虚函数表指针、成员变量
- 子类的虚函数表指针、成员变量
- 函数在代码段，成员变量在堆或者栈
- 子类重写基类的虚函数，基类指针访问子类成员函数时，会访问到被重写的函数指针

### 为什么模板类放在.h中

### 如何让类不能被继承

- final关键字

### 什么是单例模式，工厂模式

### 单例模式实现；

```C++
#include <bits/stdc++.h>

using namespace std;

template<typename T>
class Single{
public:
    static T& Instance(){
        static T* instance = new T();
        return *instance;
    }
protected:
    Single(){}
private:
    Single(const Single& );
    Single& operator = (const Single&);
};

template<typename T>
T* Single<T>::instance = NULL;

class A{
public:
    int x;
    A(){
        x = 0;
    }
    void pp(){
        cout <<x++<<endl;
    }
};

int main()
{
    for(int i = 0; i < 10 ;i ++){
         Single<A>::Instance().pp();
    }
    return 0;
}
```

### 字节序，字节对齐

### 你知道字节序吗？字节序如何转化？

- 大端、小端

### 字节对齐是什么？为什么要进行字节对齐？什么因素会影响字节对齐呢？可以让字节以1对齐么？

- 加快CPU访问速度，比如int4字节 在003地址上，要取值三次，在002地址上，要取值两次

### CPU大端和小端的区别

- 字节序的两种表示方法
- 小端：低地址段放低位字节，高地址段放高位字节
- 大端：低地址段放高位字节，高地址段放低位字节

### 越界问题一般出现在哪里

- 数组访问、stl的访问，如栈的top()、memncopy

### 指针错误一般是怎样的，空指针会存在什么样错误（我只回答了野指针 空指针的错误不清楚

- 段错误，访问地址无效，一旦一个程序发生了越界访问，cpu 就会产生相应的保护，于是 segmentation fault 就出现了，通过上面的解释，段错误应该就是访问了不可访问的内存，这个内存区要么是不存在的，要么是受到系统保护的，还有可能是缺少文件或者文件损坏。
- 空指针上没有值，一般指向0x00000000地址
- 类的空指针访问成员函数：类的成员函数并不与具体对象绑定，所有的对象共用同一份成员函数体，当程序被编译后，成员函数的地址即已确定，这份共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是隐式传递给成员函数的this指针
  - 静态成员函数，不需要this指针,所以即使是空指针，也不影响对Func正常调用。
  - 虽然某些func需要传递隐式指针，但是函数体中并没有使用到这个隐式指针，也就是说没有通过这个隐式指针去使用非静态的成员变量，也是可以执行的

### 两个无符号数相加如何判断溢出；

- 设x+y = s1
- 若发生溢出，则s<x||s<y

### 空class sizeof 是多少？

- 1

### linux网络编程api（socket、bind、listen、accept、close、connect）

### 建立一个服务端需要哪些操作，我讲了常用的那些api。

- socket、listen、accept

### socket阻塞、非阻塞

### socket有什么接口，lt与et的区别

### Epoll 有什么接口

### new一个对象，线程b能访问得到吗。？？？？？什么勾8问题
